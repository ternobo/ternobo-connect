(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[47],{

/***/ "./node_modules/persian-date/dist/persian-date.js":
/*!********************************************************!*\
  !*** ./node_modules/persian-date/dist/persian-date.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * \n * persian-date -  1.1.0\n * Reza Babakhani <babakhani.reza@gmail.com>\n * http://babakhani.github.io/PersianWebToolkit/docs/persian-date/\n * Under MIT license \n * \n * \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar durationUnit = __webpack_require__(4).durationUnit;\n\nvar Helpers = function () {\n    function Helpers() {\n        _classCallCheck(this, Helpers);\n    }\n\n    _createClass(Helpers, [{\n        key: 'toPersianDigit',\n\n\n        /**\n         * @description return converted string to persian digit\n         * @param digit\n         * @returns {string|*}\n         */\n        value: function toPersianDigit(digit) {\n            var latinDigit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            return digit.toString().replace(/\\d+/g, function (digit) {\n                var enDigitArr = [],\n                    peDigitArr = [],\n                    i = void 0,\n                    j = void 0;\n                for (i = 0; i < digit.length; i += 1) {\n                    enDigitArr.push(digit.charCodeAt(i));\n                }\n                for (j = 0; j < enDigitArr.length; j += 1) {\n                    peDigitArr.push(String.fromCharCode(enDigitArr[j] + (!!latinDigit && latinDigit === true ? 1584 : 1728)));\n                }\n                return peDigitArr.join('');\n            });\n        }\n\n        /**\n         * @param number\n         * @param targetLength\n         * @returns {string}\n         */\n\n    }, {\n        key: 'leftZeroFill',\n        value: function leftZeroFill(number, targetLength) {\n            var output = number + '';\n            while (output.length < targetLength) {\n                output = '0' + output;\n            }\n            return output;\n        }\n\n        /**\n         * @description normalize duration params and return valid param\n         * @return {{unit: *, value: *}}\n         */\n\n    }, {\n        key: 'normalizeDuration',\n        value: function normalizeDuration() {\n            var unit = void 0,\n                value = void 0;\n            if (typeof arguments[0] === 'string') {\n                unit = arguments[0];\n                value = arguments[1];\n            } else {\n                value = arguments[0];\n                unit = arguments[1];\n            }\n            if (durationUnit.year.indexOf(unit) > -1) {\n                unit = 'year';\n            } else if (durationUnit.month.indexOf(unit) > -1) {\n                unit = 'month';\n            } else if (durationUnit.week.indexOf(unit) > -1) {\n                unit = 'week';\n            } else if (durationUnit.day.indexOf(unit) > -1) {\n                unit = 'day';\n            } else if (durationUnit.hour.indexOf(unit) > -1) {\n                unit = 'hour';\n            } else if (durationUnit.minute.indexOf(unit) > -1) {\n                unit = 'minute';\n            } else if (durationUnit.second.indexOf(unit) > -1) {\n                unit = 'second';\n            } else if (durationUnit.millisecond.indexOf(unit) > -1) {\n                unit = 'millisecond';\n            }\n            return {\n                unit: unit,\n                value: value\n            };\n        }\n\n        /**\n         *\n         * @param number\n         * @returns {number}\n         */\n\n    }, {\n        key: 'absRound',\n        value: function absRound(number) {\n            if (number < 0) {\n                return Math.ceil(number);\n            } else {\n                return Math.floor(number);\n            }\n        }\n\n        /**\n         *\n         * @param number\n         * @return {number}\n         */\n\n    }, {\n        key: 'absFloor',\n        value: function absFloor(number) {\n            if (number < 0) {\n                // -0 -> 0\n                return Math.ceil(number) || 0;\n            } else {\n                return Math.floor(number);\n            }\n        }\n    }]);\n\n    return Helpers;\n}();\n\nmodule.exports = Helpers;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TypeChecking = __webpack_require__(10);\nvar Algorithms = __webpack_require__(2);\nvar Helpers = __webpack_require__(0);\nvar Duration = __webpack_require__(5);\nvar Validator = __webpack_require__(11);\nvar toPersianDigit = new Helpers().toPersianDigit;\nvar leftZeroFill = new Helpers().leftZeroFill;\nvar normalizeDuration = new Helpers().normalizeDuration;\nvar fa = __webpack_require__(7);\nvar en = __webpack_require__(6);\n\n/**\n * @description persian date class\n */\n\nvar PersianDateClass = function () {\n\n    /**\n     * @param input\n     * @return {PersianDateClass}\n     */\n    function PersianDateClass(input) {\n        _classCallCheck(this, PersianDateClass);\n\n        this.calendarType = PersianDateClass.calendarType;\n        this.localType = PersianDateClass.localType;\n        this.leapYearMode = PersianDateClass.leapYearMode;\n\n        this.algorithms = new Algorithms(this);\n        this.version = \"1.1.0\";\n        this._utcMode = false;\n        if (this.localType !== 'fa') {\n            this.formatPersian = false;\n        } else {\n            this.formatPersian = '_default';\n        }\n        this.State = this.algorithms.State;\n        this.setup(input);\n        if (this.State.isInvalidDate) {\n            // Return Date like message\n            return new Date([-1, -1]);\n        }\n        return this;\n    }\n\n    /**\n     * @param input\n     */\n\n\n    _createClass(PersianDateClass, [{\n        key: 'setup',\n        value: function setup(input) {\n            // Convert Any thing to Gregorian Date\n            if (TypeChecking.isDate(input)) {\n                this._gDateToCalculators(input);\n            } else if (TypeChecking.isArray(input)) {\n                if (!Validator.validateInputArray(input)) {\n                    this.State.isInvalidDate = true;\n                    return false;\n                }\n                this.algorithmsCalc([input[0], input[1] ? input[1] : 1, input[2] ? input[2] : 1, input[3] ? input[3] : 0, input[4] ? input[4] : 0, input[5] ? input[5] : 0, input[6] ? input[6] : 0]);\n            } else if (TypeChecking.isNumber(input)) {\n                var fromUnix = new Date(input);\n                this._gDateToCalculators(fromUnix);\n            }\n            // instance of pDate\n            else if (input instanceof PersianDateClass) {\n                    this.algorithmsCalc([input.year(), input.month(), input.date(), input.hour(), input.minute(), input.second(), input.millisecond()]);\n                }\n                // ASP.NET JSON Date\n                else if (input && input.substring(0, 6) === '/Date(') {\n                        var fromDotNet = new Date(parseInt(input.substr(6)));\n                        this._gDateToCalculators(fromDotNet);\n                    } else {\n                        var now = new Date();\n                        this._gDateToCalculators(now);\n                    }\n        }\n\n        /**\n         * @param input\n         * @return {*}\n         * @private\n         */\n\n    }, {\n        key: '_getSyncedClass',\n        value: function _getSyncedClass(input) {\n            var syncedCelander = PersianDateClass.toCalendar(this.calendarType).toLocale(this.localType).toLeapYearMode(this.leapYearMode);\n            return new syncedCelander(input);\n        }\n\n        /**\n         * @param inputgDate\n         * @private\n         */\n\n    }, {\n        key: '_gDateToCalculators',\n        value: function _gDateToCalculators(inputgDate) {\n            this.algorithms.calcGregorian([inputgDate.getFullYear(), inputgDate.getMonth(), inputgDate.getDate(), inputgDate.getHours(), inputgDate.getMinutes(), inputgDate.getSeconds(), inputgDate.getMilliseconds()]);\n        }\n\n        /**\n         * @since 1.0.0\n         * @description Helper method that return date range name like week days name, month names, month days names (specially in persian calendar).\n         * @static\n         * @return {*}\n         */\n\n    }, {\n        key: 'rangeName',\n\n\n        /**\n         * @since 1.0.0\n         * @description Helper method that return date range name like week days name, month names, month days names (specially in persian calendar).\n         * @return {*}\n         */\n        value: function rangeName() {\n            var t = this.calendarType;\n            if (this.localType === 'fa') {\n                if (t === 'persian') {\n                    return fa.persian;\n                } else {\n                    return fa.gregorian;\n                }\n            } else {\n                if (t === 'persian') {\n                    return en.persian;\n                } else {\n                    return en.gregorian;\n                }\n            }\n        }\n\n        /**\n         * @since 1.0.0\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toLeapYearMode',\n        value: function toLeapYearMode(input) {\n            this.leapYearMode = input;\n            if (input === 'astronomical' && this.calendarType == 'persian') {\n                this.leapYearMode = 'astronomical';\n            } else if (input === 'algorithmic' && this.calendarType == 'persian') {\n                this.leapYearMode = 'algorithmic';\n            }\n            this.algorithms.updateFromGregorian();\n            return this;\n        }\n\n        /**\n         * @since 1.0.0\n         * @static\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toCalendar',\n\n\n        /**\n         * @since 1.0.0\n         * @param input\n         * @return {PersianDateClass}\n         */\n        value: function toCalendar(input) {\n            this.calendarType = input;\n            this.algorithms.updateFromGregorian();\n            return this;\n        }\n\n        /**\n         * @since 1.0.0\n         * @static\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toLocale',\n\n\n        /**\n         * @since 1.0.0\n         * @param input\n         * @return {PersianDateClass}\n         */\n        value: function toLocale(input) {\n            this.localType = input;\n            if (this.localType !== 'fa') {\n                this.formatPersian = false;\n            } else {\n                this.formatPersian = '_default';\n            }\n            return this;\n        }\n\n        /**\n         * @return {*}\n         * @private\n         */\n\n    }, {\n        key: '_locale',\n        value: function _locale() {\n            var t = this.calendarType;\n            if (this.localType === 'fa') {\n                if (t === 'persian') {\n                    return fa.persian;\n                } else {\n                    return fa.gregorian;\n                }\n            } else {\n                if (t === 'persian') {\n                    return en.persian;\n                } else {\n                    return en.gregorian;\n                }\n            }\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_weekName',\n        value: function _weekName(input) {\n            return this._locale().weekdays[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_weekNameShort',\n        value: function _weekNameShort(input) {\n            return this._locale().weekdaysShort[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_weekNameMin',\n        value: function _weekNameMin(input) {\n            return this._locale().weekdaysMin[input - 1];\n        }\n\n        /**\n         * @param input\n         * @return {*}\n         * @private\n         */\n\n    }, {\n        key: '_dayName',\n        value: function _dayName(input) {\n            return this._locale().persianDaysName[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_monthName',\n        value: function _monthName(input) {\n            return this._locale().months[input - 1];\n        }\n\n        /**\n         * @param input\n         * @private\n         */\n\n    }, {\n        key: '_monthNameShort',\n        value: function _monthNameShort(input) {\n            return this._locale().monthsShort[input - 1];\n        }\n\n        /**\n         * @param obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isPersianDate',\n\n\n        /**\n         * @param obj\n         * @return {boolean}\n         */\n        value: function isPersianDate(obj) {\n            return obj instanceof PersianDateClass;\n        }\n\n        /**\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'clone',\n        value: function clone() {\n            return this._getSyncedClass(this.State.gDate);\n        }\n\n        /**\n         * @since 1.0.0\n         * @param dateArray\n         * @return {*}\n         */\n\n    }, {\n        key: 'algorithmsCalc',\n        value: function algorithmsCalc(dateArray) {\n            if (this.isPersianDate(dateArray)) {\n                dateArray = [dateArray.year(), dateArray.month(), dateArray.date(), dateArray.hour(), dateArray.minute(), dateArray.second(), dateArray.millisecond()];\n            }\n            if (this.calendarType === 'persian' && this.leapYearMode == 'algorithmic') {\n                return this.algorithms.calcPersian(dateArray);\n            } else if (this.calendarType === 'persian' && this.leapYearMode == 'astronomical') {\n                return this.algorithms.calcPersiana(dateArray);\n            } else if (this.calendarType === 'gregorian') {\n                dateArray[1] = dateArray[1] - 1;\n                return this.algorithms.calcGregorian(dateArray);\n            }\n        }\n\n        /**\n         * @since 1.0.0\n         * @return {*}\n         */\n\n    }, {\n        key: 'calendar',\n        value: function calendar() {\n            var key = void 0;\n            if (this.calendarType == 'persian') {\n                if (this.leapYearMode == 'astronomical') {\n                    key = 'persianAstro';\n                } else if (this.leapYearMode == 'algorithmic') {\n                    key = 'persianAlgo';\n                }\n            } else {\n                key = 'gregorian';\n            }\n            return this.State[key];\n        }\n\n        /**\n         * @description return Duration object\n         * @param input\n         * @param key\n         * @returns {Duration}\n         */\n\n    }, {\n        key: 'duration',\n\n\n        /**\n         * @description return Duration object\n         * @param input\n         * @param key\n         * @returns {Duration}\n         */\n        value: function duration(input, key) {\n            return new Duration(input, key);\n        }\n\n        /**\n         * @description check if passed object is duration\n         * @param obj\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isDuration',\n\n\n        /**\n         * @description check if passed object is duration\n         * @param obj\n         * @returns {boolean}\n         */\n        value: function isDuration(obj) {\n            return obj instanceof Duration;\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'years',\n        value: function years(input) {\n            return this.year(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'year',\n        value: function year(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([input, this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()]);\n                return this;\n            } else {\n                return this.calendar().year;\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'month',\n        value: function month(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), input, this.date()]);\n                return this;\n            } else {\n                return this.calendar().month + 1;\n            }\n        }\n\n        /**\n         * Day of week\n         * @returns {Function|Date.toJSON.day|date_json.day|PersianDate.day|day|output.day|*}\n         */\n\n    }, {\n        key: 'days',\n        value: function days() {\n            return this.day();\n        }\n\n        /**\n         * @returns {Function|Date.toJSON.day|date_json.day|PersianDate.day|day|output.day|*}\n         */\n\n    }, {\n        key: 'day',\n        value: function day() {\n            return this.calendar().weekday;\n        }\n\n        /**\n         * Day of Months\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'dates',\n        value: function dates(input) {\n            return this.date(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'date',\n        value: function date(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), input]);\n                return this;\n            } else {\n                return this.calendar().day;\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'hour',\n        value: function hour(input) {\n            return this.hours(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'hours',\n        value: function hours(input) {\n            if (input || input === 0) {\n                if (input === 0) {\n                    input = 24;\n                }\n                this.algorithmsCalc([this.year(), this.month(), this.date(), input]);\n                return this;\n            } else {\n                return this.State.gDate.getHours();\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'minute',\n        value: function minute(input) {\n            return this.minutes(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'minutes',\n        value: function minutes(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), this.date(), this.hour(), input]);\n                return this;\n            } else {\n                return this.State.gDate.getMinutes();\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'second',\n        value: function second(input) {\n            return this.seconds(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'seconds',\n        value: function seconds(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), this.date(), this.hour(), this.minute(), input]);\n                return this;\n            } else {\n                return this.State.gDate.getSeconds();\n            }\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         * Getter Setter\n         */\n\n    }, {\n        key: 'millisecond',\n        value: function millisecond(input) {\n            return this.milliseconds(input);\n        }\n\n        /**\n         * @param input\n         * @returns {*}\n         */\n\n    }, {\n        key: 'milliseconds',\n        value: function milliseconds(input) {\n            if (input || input === 0) {\n                this.algorithmsCalc([this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), input]);\n                return this;\n            } else {\n                return this.State.gregorian.millisecond;\n            }\n        }\n\n        /**\n         * Return Milliseconds since the Unix Epoch (1318874398806)\n         * @returns {*}\n         * @private\n         */\n        //    _valueOf () {\n        //        return this.State.gDate.valueOf();\n        //    }\n\n\n    }, {\n        key: 'unix',\n\n\n        /**\n         * Return Unix Timestamp (1318874398)\n         * @param timestamp\n         * @returns {*}\n         */\n        value: function unix(timestamp) {\n            var output = void 0;\n            if (timestamp) {\n                return this._getSyncedClass(timestamp * 1000);\n            } else {\n                var str = this.State.gDate.valueOf().toString();\n                output = str.substring(0, str.length - 3);\n            }\n            return parseInt(output);\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'valueOf',\n        value: function valueOf() {\n            return this.State.gDate.valueOf();\n        }\n\n        /**\n         * @param year\n         * @param month\n         * @returns {*}\n         * @since 1.0.0\n         */\n\n    }, {\n        key: 'getFirstWeekDayOfMonth',\n\n\n        /**\n         * @param year\n         * @param month\n         * @returns {*}\n         * @since 1.0.0\n         */\n        value: function getFirstWeekDayOfMonth(year, month) {\n            return this._getSyncedClass([year, month, 1]).day();\n        }\n\n        /**\n         * @param input\n         * @param val\n         * @param asFloat\n         * @returns {*}\n         */\n\n    }, {\n        key: 'diff',\n        value: function diff(input, val, asFloat) {\n            var self = this,\n                inputMoment = input,\n                zoneDiff = 0,\n                diff = self.State.gDate - inputMoment.toDate() - zoneDiff,\n                year = self.year() - inputMoment.year(),\n                month = self.month() - inputMoment.month(),\n                date = (self.date() - inputMoment.date()) * -1,\n                output = void 0;\n\n            if (val === 'months' || val === 'month') {\n                output = year * 12 + month + date / 30;\n            } else if (val === 'years' || val === 'year') {\n                output = year + (month + date / 30) / 12;\n            } else {\n                output = val === 'seconds' || val === 'second' ? diff / 1e3 : // 1000\n                val === 'minutes' || val === 'minute' ? diff / 6e4 : // 1000 * 60\n                val === 'hours' || val === 'hour' ? diff / 36e5 : // 1000 * 60 * 60\n                val === 'days' || val === 'day' ? diff / 864e5 : // 1000 * 60 * 60 * 24\n                val === 'weeks' || val === 'week' ? diff / 6048e5 : // 1000 * 60 * 60 * 24 * 7\n                diff;\n            }\n            return asFloat ? output : Math.round(output);\n        }\n\n        /**\n         * @param key\n         * @returns {*}\n         */\n\n    }, {\n        key: 'startOf',\n        value: function startOf(key) {\n            var syncedCelander = PersianDateClass.toCalendar(this.calendarType).toLocale(this.localType);\n            var newArray = new PersianDateClass(this.valueOf() - (this.calendar().weekday - 1) * 86400000).toArray();\n            // Simplify this\\\n            /* jshint ignore:start */\n            switch (key) {\n                case 'years':\n                case 'year':\n                    return new syncedCelander([this.year(), 1, 1]);\n                case 'months':\n                case 'month':\n                    return new syncedCelander([this.year(), this.month(), 1]);\n                case 'days':\n                case 'day':\n                    return new syncedCelander([this.year(), this.month(), this.date(), 0, 0, 0]);\n                case 'hours':\n                case 'hour':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), 0, 0]);\n                case 'minutes':\n                case 'minute':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), 0]);\n                case 'seconds':\n                case 'second':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), this.seconds()]);\n                case 'weeks':\n                case 'week':\n                    return new syncedCelander(newArray);\n                default:\n                    return this.clone();\n            }\n            /* jshint ignore:end */\n        }\n\n        /**\n         * @param key\n         * @returns {*}\n         */\n        /* eslint-disable no-case-declarations */\n\n    }, {\n        key: 'endOf',\n        value: function endOf(key) {\n            var syncedCelander = PersianDateClass.toCalendar(this.calendarType).toLocale(this.localType);\n            // Simplify this\n            switch (key) {\n                case 'years':\n                case 'year':\n                    var days = this.isLeapYear() ? 30 : 29;\n                    return new syncedCelander([this.year(), 12, days, 23, 59, 59]);\n                case 'months':\n                case 'month':\n                    var monthDays = this.daysInMonth(this.year(), this.month());\n                    return new syncedCelander([this.year(), this.month(), monthDays, 23, 59, 59]);\n                case 'days':\n                case 'day':\n                    return new syncedCelander([this.year(), this.month(), this.date(), 23, 59, 59]);\n                case 'hours':\n                case 'hour':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), 59, 59]);\n                case 'minutes':\n                case 'minute':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), 59]);\n                case 'seconds':\n                case 'second':\n                    return new syncedCelander([this.year(), this.month(), this.date(), this.hours(), this.minutes(), this.seconds()]);\n                case 'weeks':\n                case 'week':\n                    var weekDayNumber = this.calendar().weekday;\n                    return new syncedCelander([this.year(), this.month(), this.date() + (7 - weekDayNumber)]);\n                default:\n                    return this.clone();\n            }\n            /* eslint-enable no-case-declarations */\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'sod',\n        value: function sod() {\n            return this.startOf('day');\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'eod',\n        value: function eod() {\n            return this.endOf('day');\n        }\n\n        /** Get the timezone offset in minutes.\n         * @return {*}\n         */\n\n    }, {\n        key: 'zone',\n        value: function zone(input) {\n            if (input || input === 0) {\n                this.State.zone = input;\n                return this;\n            } else {\n                return this.State.zone;\n            }\n        }\n\n        /**\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'local',\n        value: function local() {\n            var utcStamp = void 0;\n            if (this._utcMode) {\n                var ThatDayOffset = new Date(this.toDate()).getTimezoneOffset();\n                var offsetMils = ThatDayOffset * 60 * 1000;\n                if (ThatDayOffset < 0) {\n                    utcStamp = this.valueOf() - offsetMils;\n                } else {\n                    /* istanbul ignore next */\n                    utcStamp = this.valueOf() + offsetMils;\n                }\n                this.toCalendar(PersianDateClass.calendarType);\n                var utcDate = new Date(utcStamp);\n                this._gDateToCalculators(utcDate);\n                this._utcMode = false;\n                this.zone(ThatDayOffset);\n                return this;\n            } else {\n                return this;\n            }\n        }\n\n        /**\n         * @param input\n         * @return {*}\n         */\n\n    }, {\n        key: 'utc',\n\n\n        /**\n         * @description Current date/time in UTC mode\n         * @param input\n         * @returns {*}\n         */\n        value: function utc(input) {\n            var utcStamp = void 0;\n            if (input) {\n                return this._getSyncedClass(input).utc();\n            }\n            if (this._utcMode) {\n                return this;\n            } else {\n                var offsetMils = this.zone() * 60 * 1000;\n                if (this.zone() < 0) {\n                    utcStamp = this.valueOf() + offsetMils;\n                } else {\n                    /* istanbul ignore next */\n                    utcStamp = this.valueOf() - offsetMils;\n                }\n                var utcDate = new Date(utcStamp),\n                    d = this._getSyncedClass(utcDate);\n                this.algorithmsCalc(d);\n                this._utcMode = true;\n                this.zone(0);\n                return this;\n            }\n        }\n\n        /**\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isUtc',\n        value: function isUtc() {\n            return this._utcMode;\n        }\n\n        /**\n         * @returns {boolean}\n         * @link https://fa.wikipedia.org/wiki/%D8%B3%D8%A7%D8%B9%D8%AA_%D8%AA%D8%A7%D8%A8%D8%B3%D8%AA%D8%A7%D9%86%DB%8C\n         */\n\n    }, {\n        key: 'isDST',\n        value: function isDST() {\n            var month = this.month(),\n                day = this.date();\n            if (month == 1 && day > 1 || month == 6 && day < 31 || month < 6 && month >= 2) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * @returns {boolean}\n         */\n\n    }, {\n        key: 'isLeapYear',\n        value: function isLeapYear(year) {\n            if (year === undefined) {\n                year = this.year();\n            }\n            if (this.calendarType == 'persian' && this.leapYearMode === 'algorithmic') {\n                return this.algorithms.leap_persian(year);\n            }\n            if (this.calendarType == 'persian' && this.leapYearMode === 'astronomical') {\n                return this.algorithms.leap_persiana(year);\n            } else if (this.calendarType == 'gregorian') {\n                return this.algorithms.leap_gregorian(year);\n            }\n        }\n\n        /**\n         * @param yearInput\n         * @param monthInput\n         * @returns {number}\n         */\n\n    }, {\n        key: 'daysInMonth',\n        value: function daysInMonth(yearInput, monthInput) {\n            var year = yearInput ? yearInput : this.year(),\n                month = monthInput ? monthInput : this.month();\n            if (this.calendarType === 'persian') {\n                if (month < 1 || month > 12) return 0;\n                if (month < 7) return 31;\n                if (month < 12) return 30;\n                if (this.isLeapYear(year)) {\n                    return 30;\n                }\n                return 29;\n            }\n            if (this.calendarType === 'gregorian') {\n                return new Date(year, month, 0).getDate();\n            }\n        }\n\n        /**\n         * @description Return Native Javascript Date\n         * @returns {*|PersianDate.gDate}\n         */\n\n    }, {\n        key: 'toDate',\n        value: function toDate() {\n            return this.State.gDate;\n        }\n\n        /**\n         * @description Returns Array Of Persian Date\n         * @returns {array}\n         */\n\n    }, {\n        key: 'toArray',\n        value: function toArray() {\n            return [this.year(), this.month(), this.date(), this.hour(), this.minute(), this.second(), this.millisecond()];\n        }\n\n        /**\n         * @returns {*}\n         */\n\n    }, {\n        key: 'formatNumber',\n        value: function formatNumber() {\n            var output = void 0,\n                self = this;\n\n            // if default conf dosent set follow golbal config\n            if (this.formatPersian === '_default') {\n                if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n                    /* istanbul ignore next */\n                    if (self.formatPersian === false) {\n                        output = false;\n                    } else {\n                        // Default Conf\n                        output = true;\n                    }\n                }\n                /* istanbul ignore next */\n                else {\n                        if (window.formatPersian === false) {\n                            output = false;\n                        } else {\n                            // Default Conf\n                            output = true;\n                        }\n                    }\n            } else {\n                if (this.formatPersian === true) {\n                    output = true;\n                } else if (this.formatPersian === false) {\n                    output = false;\n                } else {\n                    Error('Invalid Config \"formatPersian\" !!');\n                }\n            }\n            return output;\n        }\n\n        /**\n         * @param inputString\n         * @returns {*}\n         */\n\n    }, {\n        key: 'format',\n        value: function format(inputString) {\n            if (this.State.isInvalidDate) {\n                return false;\n            }\n            var self = this,\n                formattingTokens = /([[^[]*])|(\\\\)?(Mo|MM?M?M?|Do|DD?D?D?|dddddd?|ddddd?|dddd?|do?|w[o|w]?|YYYY|YY|a|A|hh?|HH?|mm?|ss?|SS?S?|zz?|ZZ?|X|LT|ll?l?l?|LL?L?L?)/g,\n                info = {\n                year: self.year(),\n                month: self.month(),\n                hour: self.hours(),\n                minute: self.minutes(),\n                second: self.seconds(),\n                date: self.date(),\n                timezone: self.zone(),\n                unix: self.unix()\n            },\n                formatToPersian = self.formatNumber();\n\n            var checkPersian = function checkPersian(i) {\n                if (formatToPersian) {\n                    return toPersianDigit(i);\n                } else {\n                    return i;\n                }\n            };\n\n            /* jshint ignore:start */\n            function replaceFunction(input) {\n                switch (input) {\n                    // AM/PM\n                    case 'a':\n                        {\n                            if (formatToPersian) return info.hour >= 12 ? 'ب ظ' : 'ق ظ';else return info.hour >= 12 ? 'PM' : 'AM';\n                        }\n                    // Hours (Int)\n                    case 'H':\n                        {\n                            return checkPersian(info.hour);\n                        }\n                    case 'HH':\n                        {\n                            return checkPersian(leftZeroFill(info.hour, 2));\n                        }\n                    case 'h':\n                        {\n                            return checkPersian(info.hour % 12);\n                        }\n                    case 'hh':\n                        {\n                            return checkPersian(leftZeroFill(info.hour % 12, 2));\n                        }\n                    // Minutes\n                    case 'm':\n                        {\n                            return checkPersian(leftZeroFill(info.minute, 2));\n                        }\n                    // Two Digit Minutes\n                    case 'mm':\n                        {\n                            return checkPersian(leftZeroFill(info.minute, 2));\n                        }\n                    // Second\n                    case 's':\n                        {\n                            return checkPersian(info.second);\n                        }\n                    case 'ss':\n                        {\n                            return checkPersian(leftZeroFill(info.second, 2));\n                        }\n                    // Day (Int)\n                    case 'D':\n                        {\n                            return checkPersian(leftZeroFill(info.date));\n                        }\n                    // Return Two Digit\n                    case 'DD':\n                        {\n                            return checkPersian(leftZeroFill(info.date, 2));\n                        }\n                    // Return day Of Month\n                    case 'DDD':\n                        {\n                            var t = self.startOf('year');\n                            return checkPersian(leftZeroFill(self.diff(t, 'days'), 3));\n                        }\n                    // Return Day of Year\n                    case 'DDDD':\n                        {\n                            var _t = self.startOf('year');\n                            return checkPersian(leftZeroFill(self.diff(_t, 'days'), 3));\n                        }\n                    // Return day Of week\n                    case 'd':\n                        {\n                            return checkPersian(self.calendar().weekday);\n                        }\n                    // Return week day name abbr\n                    case 'ddd':\n                        {\n                            return self._weekNameShort(self.calendar().weekday);\n                        }\n                    case 'dddd':\n                        {\n                            return self._weekName(self.calendar().weekday);\n                        }\n                    // Return Persian Day Name\n                    case 'ddddd':\n                        {\n                            return self._dayName(self.calendar().day);\n                        }\n                    // Return Persian Day Name\n                    case 'dddddd':\n                        {\n                            return self._weekNameMin(self.calendar().weekday);\n                        }\n                    // Return Persian Day Name\n                    case 'w':\n                        {\n                            var _t2 = self.startOf('year'),\n                                day = parseInt(self.diff(_t2, 'days') / 7) + 1;\n                            return checkPersian(day);\n                        }\n                    // Return Persian Day Name\n                    case 'ww':\n                        {\n                            var _t3 = self.startOf('year'),\n                                _day = leftZeroFill(parseInt(self.diff(_t3, 'days') / 7) + 1, 2);\n                            return checkPersian(_day);\n                        }\n                    // Month  (Int)\n                    case 'M':\n                        {\n                            return checkPersian(info.month);\n                        }\n                    // Two Digit Month (Str)\n                    case 'MM':\n                        {\n                            return checkPersian(leftZeroFill(info.month, 2));\n                        }\n                    // Abbr String of Month (Str)\n                    case 'MMM':\n                        {\n                            return self._monthNameShort(info.month);\n                        }\n                    // Full String name of Month (Str)\n                    case 'MMMM':\n                        {\n                            return self._monthName(info.month);\n                        }\n                    // Year\n                    // Two Digit Year (Str)\n                    case 'YY':\n                        {\n                            var yearDigitArray = info.year.toString().split('');\n                            return checkPersian(yearDigitArray[2] + yearDigitArray[3]);\n                        }\n                    // Full Year (Int)\n                    case 'YYYY':\n                        {\n                            return checkPersian(info.year);\n                        }\n                    /* istanbul ignore next */\n                    case 'Z':\n                        {\n                            var flag = '+',\n                                hours = Math.round(info.timezone / 60),\n                                minutes = info.timezone % 60;\n\n                            if (minutes < 0) {\n                                minutes *= -1;\n                            }\n                            if (hours < 0) {\n                                flag = '-';\n                                hours *= -1;\n                            }\n\n                            var z = flag + leftZeroFill(hours, 2) + ':' + leftZeroFill(minutes, 2);\n                            return checkPersian(z);\n                        }\n                    /* istanbul ignore next */\n                    case 'ZZ':\n                        {\n                            var _flag = '+',\n                                _hours = Math.round(info.timezone / 60),\n                                _minutes = info.timezone % 60;\n\n                            if (_minutes < 0) {\n                                _minutes *= -1;\n                            }\n                            if (_hours < 0) {\n                                _flag = '-';\n                                _hours *= -1;\n                            }\n                            var _z = _flag + leftZeroFill(_hours, 2) + '' + leftZeroFill(_minutes, 2);\n                            return checkPersian(_z);\n                        }\n                    /* istanbul ignore next */\n                    case 'X':\n                        {\n                            return self.unix();\n                        }\n                    // 8:30 PM\n                    case 'LT':\n                        {\n                            return self.format('H:m a');\n                        }\n                    // 09/04/1986\n                    case 'L':\n                        {\n                            return self.format('YYYY/MM/DD');\n                        }\n                    // 9/4/1986\n                    case 'l':\n                        {\n                            return self.format('YYYY/M/D');\n                        }\n                    // September 4th 1986\n                    case 'LL':\n                        {\n                            return self.format('MMMM DD YYYY');\n                        }\n                    // Sep 4 1986\n                    case 'll':\n                        {\n                            return self.format('MMM DD YYYY');\n                        }\n                    //September 4th 1986 8:30 PM\n                    case 'LLL':\n                        {\n                            return self.format('MMMM YYYY DD   H:m  a');\n                        }\n                    // Sep 4 1986 8:30 PM\n                    case 'lll':\n                        {\n                            return self.format('MMM YYYY DD   H:m  a');\n                        }\n                    //Thursday, September 4th 1986 8:30 PM\n                    case 'LLLL':\n                        {\n                            return self.format('dddd D MMMM YYYY  H:m  a');\n                        }\n                    // Thu, Sep 4 1986 8:30 PM\n                    case 'llll':\n                        {\n                            return self.format('ddd D MMM YYYY  H:m  a');\n                        }\n                }\n            }\n\n            /* jshint ignore:end */\n\n            if (inputString) {\n                return inputString.replace(formattingTokens, replaceFunction);\n            } else {\n                var _inputString = 'YYYY-MM-DD HH:mm:ss a';\n                return _inputString.replace(formattingTokens, replaceFunction);\n            }\n        }\n\n        /**\n         * @param key\n         * @param value\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'add',\n        value: function add(key, value) {\n            if (value === 0) {\n                return this;\n            }\n            var unit = normalizeDuration(key, value).unit,\n                arr = this.toArray();\n            value = normalizeDuration(key, value).value;\n            if (unit === 'year') {\n                var normalizedDate = arr[2],\n                    monthDays = this.daysInMonth(arr[0] + value, arr[1]);\n                if (arr[2] > monthDays) {\n                    normalizedDate = monthDays;\n                }\n                var tempDate = new PersianDateClass([arr[0] + value, arr[1], normalizedDate, arr[3], arr[4], arr[5], arr[6], arr[7]]);\n                return tempDate;\n            }\n            if (unit === 'month') {\n                var tempYear = Math.floor(value / 12);\n                var remainingMonth = value - tempYear * 12,\n                    calcedMonth = null;\n                if (arr[1] + remainingMonth > 12) {\n                    tempYear += 1;\n                    calcedMonth = arr[1] + remainingMonth - 12;\n                } else {\n                    calcedMonth = arr[1] + remainingMonth;\n                }\n                var normalizaedDate = arr[2],\n                    tempDateArray = new PersianDateClass([arr[0] + tempYear, calcedMonth, 1, arr[3], arr[4], arr[5], arr[6], arr[7]]).toArray(),\n                    _monthDays = this.daysInMonth(arr[0] + tempYear, calcedMonth);\n                if (arr[2] > _monthDays) {\n                    normalizaedDate = _monthDays;\n                }\n                return new PersianDateClass([tempDateArray[0], tempDateArray[1], normalizaedDate, tempDateArray[3], tempDateArray[4], tempDateArray[5], tempDateArray[6], tempDateArray[7]]);\n            }\n            if (unit === 'day') {\n                var calcedDay = new PersianDateClass(this.valueOf()).hour(12),\n                    newMillisecond = calcedDay.valueOf() + value * 86400000,\n                    newDate = new PersianDateClass(newMillisecond);\n                return newDate.hour(arr[3]);\n            }\n            if (unit === 'week') {\n                var _calcedDay = new PersianDateClass(this.valueOf()).hour(12),\n                    _newMillisecond = _calcedDay.valueOf() + 7 * value * 86400000,\n                    _newDate = new PersianDateClass(_newMillisecond);\n                return _newDate.hour(arr[3]);\n            }\n            if (unit === 'hour') {\n                var _newMillisecond2 = this.valueOf() + value * 3600000;\n                return this.unix(_newMillisecond2 / 1000);\n            }\n            if (unit === 'minute') {\n                var _newMillisecond3 = this.valueOf() + value * 60000;\n                return this.unix(_newMillisecond3 / 1000);\n            }\n            if (unit === 'second') {\n                var _newMillisecond4 = this.valueOf() + value * 1000;\n                return this.unix(_newMillisecond4 / 1000);\n            }\n            if (unit === 'millisecond') {\n                var _newMillisecond5 = this.valueOf() + value;\n                return this.unix(_newMillisecond5 / 1000);\n            }\n            return this._getSyncedClass(this.valueOf());\n        }\n\n        /**\n         * @param key\n         * @param value\n         * @returns {PersianDate}\n         */\n\n    }, {\n        key: 'subtract',\n        value: function subtract(key, value) {\n            return this.add(key, value * -1);\n        }\n\n        /**\n         * check if a date is same as b\n         * @param dateA\n         * @param dateB\n         * @since 1.0.0\n         * @return {boolean}\n         * @static\n         */\n\n    }, {\n        key: 'isSameDay',\n\n\n        /**\n         * @param dateB\n         * @since 1.0.0\n         * @return {PersianDateClass|*|boolean}\n         */\n        value: function isSameDay(dateB) {\n            return this && dateB && this.date() == dateB.date() && this.year() == dateB.year() && this.month() == dateB.month();\n        }\n\n        /**\n         * @desc check if a month is same as b\n         * @param {Date} dateA\n         * @param {Date} dateB\n         * @return {boolean}\n         * @since 1.0.0\n         * @static\n         */\n\n    }, {\n        key: 'isSameMonth',\n\n\n        /**\n         * @desc check two for month similarity\n         * @param dateA\n         * @param dateB\n         * @since 1.0.0\n         * @return {*|boolean}\n         */\n        value: function isSameMonth(dateB) {\n            return this && dateB && this.year() == this.year() && this.month() == dateB.month();\n        }\n    }], [{\n        key: 'rangeName',\n        value: function rangeName() {\n            var p = PersianDateClass,\n                t = p.calendarType;\n            if (p.localType === 'fa') {\n                if (t === 'persian') {\n                    return fa.persian;\n                } else {\n                    return fa.gregorian;\n                }\n            } else {\n                if (t === 'persian') {\n                    return en.persian;\n                } else {\n                    return en.gregorian;\n                }\n            }\n        }\n    }, {\n        key: 'toLeapYearMode',\n        value: function toLeapYearMode(input) {\n            var d = PersianDateClass;\n            d.leapYearMode = input;\n            return d;\n        }\n    }, {\n        key: 'toCalendar',\n        value: function toCalendar(input) {\n            var d = PersianDateClass;\n            d.calendarType = input;\n            return d;\n        }\n\n        /**\n         * @since 1.0.0\n         * @static\n         * @param input\n         * @return {PersianDateClass}\n         */\n\n    }, {\n        key: 'toLocale',\n        value: function toLocale(input) {\n            var d = PersianDateClass;\n            d.localType = input;\n            if (d.localType !== 'fa') {\n                d.formatPersian = false;\n            } else {\n                d.formatPersian = '_default';\n            }\n            return d;\n        }\n    }, {\n        key: 'isPersianDate',\n        value: function isPersianDate(obj) {\n            return obj instanceof PersianDateClass;\n        }\n    }, {\n        key: 'duration',\n        value: function duration(input, key) {\n            return new Duration(input, key);\n        }\n    }, {\n        key: 'isDuration',\n        value: function isDuration(obj) {\n            return obj instanceof Duration;\n        }\n    }, {\n        key: 'unix',\n        value: function unix(timestamp) {\n            if (timestamp) {\n                return new PersianDateClass(timestamp * 1000);\n            } else {\n                return new PersianDateClass().unix();\n            }\n        }\n    }, {\n        key: 'getFirstWeekDayOfMonth',\n        value: function getFirstWeekDayOfMonth(year, month) {\n            return new PersianDateClass([year, month, 1]).day();\n        }\n    }, {\n        key: 'utc',\n        value: function utc(input) {\n            if (input) {\n                return new PersianDateClass(input).utc();\n            } else {\n                return new PersianDateClass().utc();\n            }\n        }\n    }, {\n        key: 'isSameDay',\n        value: function isSameDay(dateA, dateB) {\n            return dateA && dateB && dateA.date() == dateB.date() && dateA.year() == dateB.year() && dateA.month() == dateB.month();\n        }\n    }, {\n        key: 'isSameMonth',\n        value: function isSameMonth(dateA, dateB) {\n            return dateA && dateB && dateA.year() == dateB.year() && dateA.month() == dateB.month();\n        }\n    }]);\n\n    return PersianDateClass;\n}();\n\n/**\n * @type {PersianDateClass}\n */\n\n\nmodule.exports = PersianDateClass;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Start algorithm class\nvar ASTRO = __webpack_require__(3);\nvar State = __webpack_require__(9);\n\nvar Algorithms = function () {\n    function Algorithms(parent) {\n        _classCallCheck(this, Algorithms);\n\n        this.parent = parent;\n        this.ASTRO = new ASTRO();\n        this.State = new State();\n        /*  You may notice that a variety of array variables logically local\n         to functions are declared globally here.  In JavaScript, construction\n         of an array variable from source code occurs as the code is\n         interpreted.  Making these variables pseudo-globals permits us\n         to avoid overhead constructing and disposing of them in each\n         call on the function in which whey are used.  */\n        // TODO this block didnt used in main agorithm\n        this.J0000 = 1721424.5; // Julian date of Gregorian epoch: 0000-01-01\n        this.J1970 = 2440587.5; // Julian date at Unix epoch: 1970-01-01\n        this.JMJD = 2400000.5; // Epoch of Modified Julian Date system\n        this.NormLeap = [false /*\"Normal year\"*/, true /*\"Leap year\"*/];\n        // TODO END\n        this.GREGORIAN_EPOCH = 1721425.5;\n        this.PERSIAN_EPOCH = 1948320.5;\n    }\n\n    /**\n     * @desc LEAP_GREGORIAN  --  Is a given year in the Gregorian calendar a leap year ?\n     * @param year\n     * @return {boolean}\n     */\n\n\n    _createClass(Algorithms, [{\n        key: 'leap_gregorian',\n        value: function leap_gregorian(year) {\n            return year % 4 === 0 && !(year % 100 === 0 && year % 400 !== 0);\n        }\n\n        /**\n         * @desc Determine Julian day number from Gregorian calendar date\n         * @param {*} year\n         * @param {*} month\n         * @param {*} day\n         */\n\n    }, {\n        key: 'gregorian_to_jd',\n        value: function gregorian_to_jd(year, month, day) {\n            return this.GREGORIAN_EPOCH - 1 + 365 * (year - 1) + Math.floor((year - 1) / 4) + -Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400) + Math.floor((367 * month - 362) / 12 + (month <= 2 ? 0 : this.leap_gregorian(year) ? -1 : -2) + day);\n        }\n\n        /**\n         * @desc Calculate Gregorian calendar date from Julian day\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'jd_to_gregorian',\n        value: function jd_to_gregorian(jd) {\n            var wjd = void 0,\n                depoch = void 0,\n                quadricent = void 0,\n                dqc = void 0,\n                cent = void 0,\n                dcent = void 0,\n                quad = void 0,\n                dquad = void 0,\n                yindex = void 0,\n                year = void 0,\n                yearday = void 0,\n                leapadj = void 0,\n                month = void 0,\n                day = void 0;\n\n            wjd = Math.floor(jd - 0.5) + 0.5;\n            depoch = wjd - this.GREGORIAN_EPOCH;\n            quadricent = Math.floor(depoch / 146097);\n            dqc = this.ASTRO.mod(depoch, 146097);\n            cent = Math.floor(dqc / 36524);\n            dcent = this.ASTRO.mod(dqc, 36524);\n            quad = Math.floor(dcent / 1461);\n            dquad = this.ASTRO.mod(dcent, 1461);\n            yindex = Math.floor(dquad / 365);\n            year = quadricent * 400 + cent * 100 + quad * 4 + yindex;\n            if (!(cent === 4 || yindex === 4)) {\n                year++;\n            }\n            yearday = wjd - this.gregorian_to_jd(year, 1, 1);\n            leapadj = wjd < this.gregorian_to_jd(year, 3, 1) ? 0 : this.leap_gregorian(year) ? 1 : 2;\n            month = Math.floor(((yearday + leapadj) * 12 + 373) / 367);\n            day = wjd - this.gregorian_to_jd(year, month, 1) + 1;\n\n            return [year, month, day];\n        }\n\n        /**\n         * @param {*} year\n         */\n        //    leap_julian (year) {\n        //        return this.ASTRO.mod(year, 4) === ((year > 0) ? 0 : 3);\n        //    }\n\n\n        /**\n         * @desc Calculate Julian calendar date from Julian day\n         * @param {*} td\n         */\n        //    jd_to_julian (td) {\n        //        let z, a, b, c, d, e, year, month, day;\n        //\n        //        td += 0.5;\n        //        z = Math.floor(td);\n        //\n        //        a = z;\n        //        b = a + 1524;\n        //        c = Math.floor((b - 122.1) / 365.25);\n        //        d = Math.floor(365.25 * c);\n        //        e = Math.floor((b - d) / 30.6001);\n        //\n        //        month = Math.floor((e < 14) ? (e - 1) : (e - 13));\n        //        year = Math.floor((month > 2) ? (c - 4716) : (c - 4715));\n        //        day = b - d - Math.floor(30.6001 * e);\n        //\n        //        /*  If year is less than 1, subtract one to convert from\n        //         a zero based date system to the common era system in\n        //         which the year -1 (1 B.C.E) is followed by year 1 (1 C.E.).  */\n        //\n        //        if (year < 1) {\n        //            year--;\n        //        }\n        //\n        //        return [year, month, day];\n        //    }\n\n\n        /**\n         * @desc TEHRAN_EQUINOX  --  Determine Julian day and fraction of the\n         March equinox at the Tehran meridian in\n         a given Gregorian year.\n         * @param {*} year\n         */\n\n    }, {\n        key: 'tehran_equinox',\n        value: function tehran_equinox(year) {\n            var equJED = void 0,\n                equJD = void 0,\n                equAPP = void 0,\n                equTehran = void 0,\n                dtTehran = void 0;\n\n            //  March equinox in dynamical time\n            equJED = this.ASTRO.equinox(year, 0);\n\n            //  Correct for delta T to obtain Universal time\n            equJD = equJED - this.ASTRO.deltat(year) / (24 * 60 * 60);\n\n            //  Apply the equation of time to yield the apparent time at Greenwich\n            equAPP = equJD + this.ASTRO.equationOfTime(equJED);\n\n            /*  Finally, we must correct for the constant difference between\n             the Greenwich meridian andthe time zone standard for\n             Iran Standard time, 52°30' to the East.  */\n\n            dtTehran = (52 + 30 / 60.0 + 0 / (60.0 * 60.0)) / 360;\n            equTehran = equAPP + dtTehran;\n\n            return equTehran;\n        }\n\n        /**\n         * @desc TEHRAN_EQUINOX_JD  --  Calculate Julian day during which the\n         March equinox, reckoned from the Tehran\n         meridian, occurred for a given Gregorian\n         year.\n         * @param {*} year\n         */\n\n    }, {\n        key: 'tehran_equinox_jd',\n        value: function tehran_equinox_jd(year) {\n            var ep = void 0,\n                epg = void 0;\n\n            ep = this.tehran_equinox(year);\n            epg = Math.floor(ep);\n\n            return epg;\n        }\n\n        /**\n         * @desc  PERSIANA_YEAR  --  Determine the year in the Persian\n         astronomical calendar in which a\n         given Julian day falls.  Returns an\n         array of two elements:\n          [0]  Persian year\n         [1]  Julian day number containing\n         equinox for this year.\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'persiana_year',\n        value: function persiana_year(jd) {\n            var guess = this.jd_to_gregorian(jd)[0] - 2,\n                lasteq = void 0,\n                nexteq = void 0,\n                adr = void 0;\n\n            lasteq = this.tehran_equinox_jd(guess);\n            while (lasteq > jd) {\n                guess--;\n                lasteq = this.tehran_equinox_jd(guess);\n            }\n            nexteq = lasteq - 1;\n            while (!(lasteq <= jd && jd < nexteq)) {\n                lasteq = nexteq;\n                guess++;\n                nexteq = this.tehran_equinox_jd(guess);\n            }\n            adr = Math.round((lasteq - this.PERSIAN_EPOCH) / this.ASTRO.TropicalYear) + 1;\n\n            return [adr, lasteq];\n        }\n\n        /**\n         * @desc Calculate date in the Persian astronomical\n         calendar from Julian day.\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'jd_to_persiana',\n        value: function jd_to_persiana(jd) {\n            var year = void 0,\n                month = void 0,\n                day = void 0,\n                adr = void 0,\n                equinox = void 0,\n                yday = void 0;\n\n            jd = Math.floor(jd) + 0.5;\n            adr = this.persiana_year(jd);\n            year = adr[0];\n            equinox = adr[1];\n            day = Math.floor((jd - equinox) / 30) + 1;\n\n            yday = Math.floor(jd) - this.persiana_to_jd(year, 1, 1) + 1;\n            month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);\n            day = Math.floor(jd) - this.persiana_to_jd(year, month, 1) + 1;\n\n            return [year, month, day];\n        }\n\n        /**\n         * @desc Obtain Julian day from a given Persian\n         astronomical calendar date.\n         * @param {*} year\n         * @param {*} month\n         * @param {*} day\n         */\n\n    }, {\n        key: 'persiana_to_jd',\n        value: function persiana_to_jd(year, month, day) {\n            var adr = void 0,\n                equinox = void 0,\n                guess = void 0,\n                jd = void 0;\n\n            guess = this.PERSIAN_EPOCH - 1 + this.ASTRO.TropicalYear * (year - 1 - 1);\n            adr = [year - 1, 0];\n\n            while (adr[0] < year) {\n                adr = this.persiana_year(guess);\n                guess = adr[1] + (this.ASTRO.TropicalYear + 2);\n            }\n            equinox = adr[1];\n\n            jd = equinox + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + (day - 1);\n            return jd;\n        }\n\n        /**\n         * @desc Is a given year a leap year in the Persian astronomical calendar ?\n         * @param {*} year\n         */\n\n    }, {\n        key: 'leap_persiana',\n        value: function leap_persiana(year) {\n            return this.persiana_to_jd(year + 1, 1, 1) - this.persiana_to_jd(year, 1, 1) > 365;\n        }\n\n        /**\n         * @desc Is a given year a leap year in the Persian calendar ?\n         * also nasa use this algorithm https://eclipse.gsfc.nasa.gov/SKYCAL/algorithm.js search for 'getLastDayOfPersianMonth' and you can find it\n         * @param {*} year\n         *\n         */\n\n    }, {\n        key: 'leap_persian',\n        value: function leap_persian(year) {\n            return ((year - (year > 0 ? 474 : 473)) % 2820 + 474 + 38) * 682 % 2816 < 682;\n        }\n\n        /**\n         * @desc Determine Julian day from Persian date\n         * @param {*} year\n         * @param {*} month\n         * @param {*} day\n         */\n\n    }, {\n        key: 'persian_to_jd',\n        value: function persian_to_jd(year, month, day) {\n            var epbase = void 0,\n                epyear = void 0;\n\n            epbase = year - (year >= 0 ? 474 : 473);\n            epyear = 474 + this.ASTRO.mod(epbase, 2820);\n\n            return day + (month <= 7 ? (month - 1) * 31 : (month - 1) * 30 + 6) + Math.floor((epyear * 682 - 110) / 2816) + (epyear - 1) * 365 + Math.floor(epbase / 2820) * 1029983 + (this.PERSIAN_EPOCH - 1);\n        }\n\n        /**\n         * @desc Calculate Persian date from Julian day\n         * @param {*} jd\n         */\n\n    }, {\n        key: 'jd_to_persian',\n        value: function jd_to_persian(jd) {\n            var year = void 0,\n                month = void 0,\n                day = void 0,\n                depoch = void 0,\n                cycle = void 0,\n                cyear = void 0,\n                ycycle = void 0,\n                aux1 = void 0,\n                aux2 = void 0,\n                yday = void 0;\n\n            jd = Math.floor(jd) + 0.5;\n\n            depoch = jd - this.persian_to_jd(475, 1, 1);\n            cycle = Math.floor(depoch / 1029983);\n            cyear = this.ASTRO.mod(depoch, 1029983);\n            if (cyear === 1029982) {\n                ycycle = 2820;\n            } else {\n                aux1 = Math.floor(cyear / 366);\n                aux2 = this.ASTRO.mod(cyear, 366);\n                ycycle = Math.floor((2134 * aux1 + 2816 * aux2 + 2815) / 1028522) + aux1 + 1;\n            }\n            year = ycycle + 2820 * cycle + 474;\n            if (year <= 0) {\n                year--;\n            }\n            yday = jd - this.persian_to_jd(year, 1, 1) + 1;\n            month = yday <= 186 ? Math.ceil(yday / 31) : Math.ceil((yday - 6) / 30);\n            day = jd - this.persian_to_jd(year, month, 1) + 1;\n            return [year, month, day];\n        }\n\n        /**\n         *\n         * @param {*} weekday\n         */\n\n    }, {\n        key: 'gWeekDayToPersian',\n        value: function gWeekDayToPersian(weekday) {\n            if (weekday + 2 === 8) {\n                return 1;\n            } else if (weekday + 2 === 7) {\n                return 7;\n            } else {\n                return weekday + 2;\n            }\n        }\n\n        /**\n         * @desc updateFromGregorian  --  Update all calendars from Gregorian.\n         \"Why not Julian date?\" you ask.  Because\n         starting from Gregorian guarantees we're\n         already snapped to an integral second, so\n         we don't get roundoff errors in other\n         calendars.\n         */\n\n    }, {\n        key: 'updateFromGregorian',\n        value: function updateFromGregorian() {\n            var j = void 0,\n                year = void 0,\n                mon = void 0,\n                mday = void 0,\n                hour = void 0,\n                min = void 0,\n                sec = void 0,\n                weekday = void 0,\n                utime = void 0,\n                perscal = void 0;\n\n            year = this.State.gregorian.year;\n            mon = this.State.gregorian.month;\n            mday = this.State.gregorian.day;\n            hour = 0; //this.State.gregorian.hour;\n            min = 0; //this.State.gregorian.minute;\n            sec = 0; //this.State.gregorian.second;\n\n            this.State.gDate = new Date(year, mon, mday, this.State.gregorian.hour, this.State.gregorian.minute, this.State.gregorian.second, this.State.gregorian.millisecond);\n\n            if (this.parent._utcMode === false) {\n                this.State.zone = this.State.gDate.getTimezoneOffset();\n            }\n\n            // Added for this algorithms cant parse 2016,13,32 successfully\n            this.State.gregorian.year = this.State.gDate.getFullYear();\n            this.State.gregorian.month = this.State.gDate.getMonth();\n            this.State.gregorian.day = this.State.gDate.getDate();\n\n            //  Update Julian day\n            // ---------------------------------------------------------------------------\n            j = this.gregorian_to_jd(year, mon + 1, mday) + Math.floor(sec + 60 * (min + 60 * hour) + 0.5) / 86400.0;\n\n            this.State.julianday = j;\n            this.State.modifiedjulianday = j - this.JMJD;\n\n            //  Update day of week in Gregorian box\n            // ---------------------------------------------------------------------------\n            weekday = this.ASTRO.jwday(j);\n            // Move to 1 indexed number\n            this.State.gregorian.weekday = weekday + 1;\n\n            //  Update leap year status in Gregorian box\n            // ---------------------------------------------------------------------------\n            this.State.gregorian.leap = this.NormLeap[this.leap_gregorian(year) ? 1 : 0];\n\n            //  Update Julian Calendar\n            // ---------------------------------------------------------------------------\n            //        julcal = this.jd_to_julian(j);\n            //\n            //        this.State.juliancalendar.year = julcal[0];\n            //        this.State.juliancalendar.month = julcal[1] - 1;\n            //        this.State.juliancalendar.day = julcal[2];\n            //        this.State.juliancalendar.leap = this.NormLeap[this.leap_julian(julcal[0]) ? 1 : 0];\n            weekday = this.ASTRO.jwday(j);\n            //        this.State.juliancalendar.weekday = weekday;\n\n            //  Update Persian Calendar\n            // ---------------------------------------------------------------------------\n            if (this.parent.calendarType == 'persian' && this.parent.leapYearMode == 'algorithmic') {\n                perscal = this.jd_to_persian(j);\n                this.State.persian.year = perscal[0];\n                this.State.persian.month = perscal[1] - 1;\n                this.State.persian.day = perscal[2];\n                this.State.persian.weekday = this.gWeekDayToPersian(weekday);\n                this.State.persian.leap = this.NormLeap[this.leap_persian(perscal[0]) ? 1 : 0];\n            }\n\n            //  Update Persian Astronomical Calendar\n            // ---------------------------------------------------------------------------\n            if (this.parent.calendarType == 'persian' && this.parent.leapYearMode == 'astronomical') {\n                perscal = this.jd_to_persiana(j);\n                this.State.persianAstro.year = perscal[0];\n                this.State.persianAstro.month = perscal[1] - 1;\n                this.State.persianAstro.day = perscal[2];\n                this.State.persianAstro.weekday = this.gWeekDayToPersian(weekday);\n                this.State.persianAstro.leap = this.NormLeap[this.leap_persiana(perscal[0]) ? 1 : 0];\n            }\n            //  Update Gregorian serial number\n            // ---------------------------------------------------------------------------\n            if (this.State.gregserial.day !== null) {\n                this.State.gregserial.day = j - this.J0000;\n            }\n\n            //  Update Unix time()\n            // ---------------------------------------------------------------------------\n            utime = (j - this.J1970) * (60 * 60 * 24 * 1000);\n\n            this.State.unixtime = Math.round(utime / 1000);\n        }\n\n        /**\n         * @desc Perform calculation starting with a Gregorian date\n         * @param {*} dateArray\n         */\n\n    }, {\n        key: 'calcGregorian',\n        value: function calcGregorian(dateArray) {\n            if (dateArray[0] || dateArray[0] === 0) {\n                this.State.gregorian.year = dateArray[0];\n            }\n            if (dateArray[1] || dateArray[1] === 0) {\n                this.State.gregorian.month = dateArray[1];\n            }\n            if (dateArray[2] || dateArray[2] === 0) {\n                this.State.gregorian.day = dateArray[2];\n            }\n            if (dateArray[3] || dateArray[3] === 0) {\n                this.State.gregorian.hour = dateArray[3];\n            }\n            if (dateArray[4] || dateArray[4] === 0) {\n                this.State.gregorian.minute = dateArray[4];\n            }\n            if (dateArray[5] || dateArray[5] === 0) {\n                this.State.gregorian.second = dateArray[5];\n            }\n            if (dateArray[6] || dateArray[6] === 0) {\n                this.State.gregorian.millisecond = dateArray[6];\n            }\n            this.updateFromGregorian();\n        }\n\n        /**\n         * @desc Perform calculation starting with a Julian date\n         */\n\n    }, {\n        key: 'calcJulian',\n        value: function calcJulian() {\n            var j = void 0,\n                date = void 0;\n            j = this.State.julianday;\n            date = this.jd_to_gregorian(j);\n            this.State.gregorian.year = date[0];\n            this.State.gregorian.month = date[1] - 1;\n            this.State.gregorian.day = date[2];\n            //        this.State.gregorian.hour = this.pad(time[0], 2, \" \");\n            //        this.State.gregorian.minute = this.pad(time[1], 2, \"0\");\n            //        this.State.gregorian.second = this.pad(time[2], 2, \"0\");\n            this.updateFromGregorian();\n        }\n\n        /**\n         * @desc Set Julian date and update all calendars\n         * @param {*} j\n         */\n\n    }, {\n        key: 'setJulian',\n        value: function setJulian(j) {\n            this.State.julianday = j;\n            this.calcJulian();\n        }\n\n        /**\n         * @desc  Update from Persian calendar\n         * @param {*} dateArray\n         */\n\n    }, {\n        key: 'calcPersian',\n        value: function calcPersian(dateArray) {\n            if (dateArray[0] || dateArray[0] === 0) {\n                this.State.persian.year = dateArray[0];\n            }\n            if (dateArray[1] || dateArray[1] === 0) {\n                this.State.persian.month = dateArray[1];\n            }\n            if (dateArray[2] || dateArray[2] === 0) {\n                this.State.persian.day = dateArray[2];\n            }\n            if (dateArray[3] || dateArray[3] === 0) {\n                this.State.gregorian.hour = dateArray[3];\n            }\n            if (dateArray[4] || dateArray[4] === 0) {\n                this.State.gregorian.minute = dateArray[4];\n            }\n            if (dateArray[5] || dateArray[5] === 0) {\n                this.State.gregorian.second = dateArray[5];\n            }\n            if (dateArray[6] || dateArray[6] === 0) {\n                this.State.gregorian.millisecond = dateArray[6];\n            }\n\n            this.setJulian(this.persian_to_jd(this.State.persian.year, this.State.persian.month, this.State.persian.day));\n        }\n\n        /**\n         * @desc Update from Persian astronomical calendar\n         * @param {*} dateArray\n         */\n\n    }, {\n        key: 'calcPersiana',\n        value: function calcPersiana(dateArray) {\n            if (dateArray[0] || dateArray[0] === 0) {\n                this.State.persianAstro.year = dateArray[0];\n            }\n            if (dateArray[1] || dateArray[1] === 0) {\n                this.State.persianAstro.month = dateArray[1];\n            }\n            if (dateArray[2] || dateArray[2] === 0) {\n                this.State.persianAstro.day = dateArray[2];\n            }\n\n            if (dateArray[3] || dateArray[3] === 0) {\n                this.State.gregorian.hour = dateArray[3];\n            }\n            if (dateArray[4] || dateArray[4] === 0) {\n                this.State.gregorian.minute = dateArray[4];\n            }\n            if (dateArray[5] || dateArray[5] === 0) {\n                this.State.gregorian.second = dateArray[5];\n            }\n            if (dateArray[6] || dateArray[6] === 0) {\n                this.State.gregorian.millisecond = dateArray[6];\n            }\n            this.setJulian(this.persiana_to_jd(this.State.persianAstro.year, this.State.persianAstro.month, this.State.persianAstro.day + 0.5));\n        }\n    }]);\n\n    return Algorithms;\n}();\n\nmodule.exports = Algorithms;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n JavaScript functions for positional astronomy\n by John Walker  --  September, MIM\n http://www.fourmilab.ch/\n This program is in the public domain.\n */\n\nvar ASTRO = function () {\n    function ASTRO() {\n        _classCallCheck(this, ASTRO);\n\n        //  Frequently-used constants\n        this.J2000 = 2451545.0; // Julian day of J2000 epoch\n        this.JulianCentury = 36525.0; // Days in Julian century\n        this.JulianMillennium = this.JulianCentury * 10; // Days in Julian millennium\n        //        this.AstronomicalUnit = 149597870.0;           // Astronomical unit in kilometres\n        this.TropicalYear = 365.24219878; // Mean solar tropical year\n\n        /*  OBLIQEQ  --  Calculate the obliquity of the ecliptic for a given\n         Julian date.  This uses Laskar's tenth-degree\n         polynomial fit (J. Laskar, Astronomy and\n         Astrophysics, Vol. 157, page 68 [1986]) which is\n         accurate to within 0.01 arc second between AD 1000\n         and AD 3000, and within a few seconds of arc for\n         +/-10000 years around AD 2000.  If we're outside the\n         range in which this fit is valid (deep time) we\n         simply return the J2000 value of the obliquity, which\n         happens to be almost precisely the mean.  */\n        this.oterms = [-4680.93, -1.55, 1999.25, -51.38, -249.67, -39.05, 7.12, 27.87, 5.79, 2.45];\n        /* Periodic terms for nutation in longiude (delta \\Psi) and\n         obliquity (delta \\Epsilon) as given in table 21.A of\n         Meeus, \"Astronomical Algorithms\", first edition. */\n        this.nutArgMult = [0, 0, 0, 0, 1, -2, 0, 0, 2, 2, 0, 0, 0, 2, 2, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, -2, 1, 0, 2, 2, 0, 0, 0, 2, 1, 0, 0, 1, 2, 2, -2, -1, 0, 2, 2, -2, 0, 1, 0, 0, -2, 0, 0, 2, 1, 0, 0, -1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1, 0, 1, 2, 0, -1, 2, 2, 0, 0, -1, 0, 1, 0, 0, 1, 2, 1, -2, 0, 2, 0, 0, 0, 0, -2, 2, 1, 2, 0, 0, 2, 2, 0, 0, 2, 2, 2, 0, 0, 2, 0, 0, -2, 0, 1, 2, 2, 0, 0, 0, 2, 0, -2, 0, 0, 2, 0, 0, 0, -1, 2, 1, 0, 2, 0, 0, 0, 2, 0, -1, 0, 1, -2, 2, 0, 2, 2, 0, 1, 0, 0, 1, -2, 0, 1, 0, 1, 0, -1, 0, 0, 1, 0, 0, 2, -2, 0, 2, 0, -1, 2, 1, 2, 0, 1, 2, 2, 0, 1, 0, 2, 2, -2, 1, 1, 0, 0, 0, -1, 0, 2, 2, 2, 0, 0, 2, 1, 2, 0, 1, 0, 0, -2, 0, 2, 2, 2, -2, 0, 1, 2, 1, 2, 0, -2, 0, 1, 2, 0, 0, 0, 1, 0, -1, 1, 0, 0, -2, -1, 0, 2, 1, -2, 0, 0, 0, 1, 0, 0, 2, 2, 1, -2, 0, 2, 0, 1, -2, 1, 0, 2, 1, 0, 0, 1, -2, 0, -1, 0, 1, 0, 0, -2, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 2, 0, -1, -1, 1, 0, 0, 0, 1, 1, 0, 0, 0, -1, 1, 2, 2, 2, -1, -1, 2, 2, 0, 0, -2, 2, 2, 0, 0, 3, 2, 2, 2, -1, 0, 2, 2];\n\n        this.nutArgCoeff = [-171996, -1742, 92095, 89, /*  0,  0,  0,  0,  1 */\n        -13187, -16, 5736, -31, /* -2,  0,  0,  2,  2 */\n        -2274, -2, 977, -5, /*  0,  0,  0,  2,  2 */\n        2062, 2, -895, 5, /*  0,  0,  0,  0,  2 */\n        1426, -34, 54, -1, /*  0,  1,  0,  0,  0 */\n        712, 1, -7, 0, /*  0,  0,  1,  0,  0 */\n        -517, 12, 224, -6, /* -2,  1,  0,  2,  2 */\n        -386, -4, 200, 0, /*  0,  0,  0,  2,  1 */\n        -301, 0, 129, -1, /*  0,  0,  1,  2,  2 */\n        217, -5, -95, 3, /* -2, -1,  0,  2,  2 */\n        -158, 0, 0, 0, /* -2,  0,  1,  0,  0 */\n        129, 1, -70, 0, /* -2,  0,  0,  2,  1 */\n        123, 0, -53, 0, /*  0,  0, -1,  2,  2 */\n        63, 0, 0, 0, /*  2,  0,  0,  0,  0 */\n        63, 1, -33, 0, /*  0,  0,  1,  0,  1 */\n        -59, 0, 26, 0, /*  2,  0, -1,  2,  2 */\n        -58, -1, 32, 0, /*  0,  0, -1,  0,  1 */\n        -51, 0, 27, 0, /*  0,  0,  1,  2,  1 */\n        48, 0, 0, 0, /* -2,  0,  2,  0,  0 */\n        46, 0, -24, 0, /*  0,  0, -2,  2,  1 */\n        -38, 0, 16, 0, /*  2,  0,  0,  2,  2 */\n        -31, 0, 13, 0, /*  0,  0,  2,  2,  2 */\n        29, 0, 0, 0, /*  0,  0,  2,  0,  0 */\n        29, 0, -12, 0, /* -2,  0,  1,  2,  2 */\n        26, 0, 0, 0, /*  0,  0,  0,  2,  0 */\n        -22, 0, 0, 0, /* -2,  0,  0,  2,  0 */\n        21, 0, -10, 0, /*  0,  0, -1,  2,  1 */\n        17, -1, 0, 0, /*  0,  2,  0,  0,  0 */\n        16, 0, -8, 0, /*  2,  0, -1,  0,  1 */\n        -16, 1, 7, 0, /* -2,  2,  0,  2,  2 */\n        -15, 0, 9, 0, /*  0,  1,  0,  0,  1 */\n        -13, 0, 7, 0, /* -2,  0,  1,  0,  1 */\n        -12, 0, 6, 0, /*  0, -1,  0,  0,  1 */\n        11, 0, 0, 0, /*  0,  0,  2, -2,  0 */\n        -10, 0, 5, 0, /*  2,  0, -1,  2,  1 */\n        -8, 0, 3, 0, /*  2,  0,  1,  2,  2 */\n        7, 0, -3, 0, /*  0,  1,  0,  2,  2 */\n        -7, 0, 0, 0, /* -2,  1,  1,  0,  0 */\n        -7, 0, 3, 0, /*  0, -1,  0,  2,  2 */\n        -7, 0, 3, 0, /*  2,  0,  0,  2,  1 */\n        6, 0, 0, 0, /*  2,  0,  1,  0,  0 */\n        6, 0, -3, 0, /* -2,  0,  2,  2,  2 */\n        6, 0, -3, 0, /* -2,  0,  1,  2,  1 */\n        -6, 0, 3, 0, /*  2,  0, -2,  0,  1 */\n        -6, 0, 3, 0, /*  2,  0,  0,  0,  1 */\n        5, 0, 0, 0, /*  0, -1,  1,  0,  0 */\n        -5, 0, 3, 0, /* -2, -1,  0,  2,  1 */\n        -5, 0, 3, 0, /* -2,  0,  0,  0,  1 */\n        -5, 0, 3, 0, /*  0,  0,  2,  2,  1 */\n        4, 0, 0, 0, /* -2,  0,  2,  0,  1 */\n        4, 0, 0, 0, /* -2,  1,  0,  2,  1 */\n        4, 0, 0, 0, /*  0,  0,  1, -2,  0 */\n        -4, 0, 0, 0, /* -1,  0,  1,  0,  0 */\n        -4, 0, 0, 0, /* -2,  1,  0,  0,  0 */\n        -4, 0, 0, 0, /*  1,  0,  0,  0,  0 */\n        3, 0, 0, 0, /*  0,  0,  1,  2,  0 */\n        -3, 0, 0, 0, /* -1, -1,  1,  0,  0 */\n        -3, 0, 0, 0, /*  0,  1,  1,  0,  0 */\n        -3, 0, 0, 0, /*  0, -1,  1,  2,  2 */\n        -3, 0, 0, 0, /*  2, -1, -1,  2,  2 */\n        -3, 0, 0, 0, /*  0,  0, -2,  2,  2 */\n        -3, 0, 0, 0, /*  0,  0,  3,  2,  2 */\n        -3, 0, 0, 0 /*  2, -1,  0,  2,  2 */\n        ];\n\n        /**\n         * @desc Table of observed Delta T values at the beginning of even numbered years from 1620 through 2002.\n         * @type Array\n         */\n        this.deltaTtab = [121, 112, 103, 95, 88, 82, 77, 72, 68, 63, 60, 56, 53, 51, 48, 46, 44, 42, 40, 38, 35, 33, 31, 29, 26, 24, 22, 20, 18, 16, 14, 12, 11, 10, 9, 8, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 15, 15, 14, 13, 13.1, 12.5, 12.2, 12, 12, 12, 12, 12, 12, 11.9, 11.6, 11, 10.2, 9.2, 8.2, 7.1, 6.2, 5.6, 5.4, 5.3, 5.4, 5.6, 5.9, 6.2, 6.5, 6.8, 7.1, 7.3, 7.5, 7.6, 7.7, 7.3, 6.2, 5.2, 2.7, 1.4, -1.2, -2.8, -3.8, -4.8, -5.5, -5.3, -5.6, -5.7, -5.9, -6, -6.3, -6.5, -6.2, -4.7, -2.8, -0.1, 2.6, 5.3, 7.7, 10.4, 13.3, 16, 18.2, 20.2, 21.1, 22.4, 23.5, 23.8, 24.3, 24, 23.9, 23.9, 23.7, 24, 24.3, 25.3, 26.2, 27.3, 28.2, 29.1, 30, 30.7, 31.4, 32.2, 33.1, 34, 35, 36.5, 38.3, 40.2, 42.2, 44.5, 46.5, 48.5, 50.5, 52.2, 53.8, 54.9, 55.8, 56.9, 58.3, 60, 61.6, 63, 65, 66.6];\n\n        /*  EQUINOX  --  Determine the Julian Ephemeris Day of an\n         equinox or solstice.  The \"which\" argument\n         selects the item to be computed:\n          0   March equinox\n         1   June solstice\n         2   September equinox\n         3   December solstice\n          */\n        /**\n         * @desc Periodic terms to obtain true time\n         * @type Array\n         */\n        this.EquinoxpTerms = [485, 324.96, 1934.136, 203, 337.23, 32964.467, 199, 342.08, 20.186, 182, 27.85, 445267.112, 156, 73.14, 45036.886, 136, 171.52, 22518.443, 77, 222.54, 65928.934, 74, 296.72, 3034.906, 70, 243.58, 9037.513, 58, 119.81, 33718.147, 52, 297.17, 150.678, 50, 21.02, 2281.226, 45, 247.54, 29929.562, 44, 325.15, 31555.956, 29, 60.93, 4443.417, 18, 155.12, 67555.328, 17, 288.79, 4562.452, 16, 198.04, 62894.029, 14, 199.76, 31436.921, 12, 95.39, 14577.848, 12, 287.11, 31931.756, 12, 320.81, 34777.259, 9, 227.73, 1222.114, 8, 15.45, 16859.074];\n\n        this.JDE0tab1000 = [new Array(1721139.29189, 365242.13740, 0.06134, 0.00111, -0.00071), new Array(1721233.25401, 365241.72562, -0.05323, 0.00907, 0.00025), new Array(1721325.70455, 365242.49558, -0.11677, -0.00297, 0.00074), new Array(1721414.39987, 365242.88257, -0.00769, -0.00933, -0.00006)];\n\n        this.JDE0tab2000 = [new Array(2451623.80984, 365242.37404, 0.05169, -0.00411, -0.00057), new Array(2451716.56767, 365241.62603, 0.00325, 0.00888, -0.00030), new Array(2451810.21715, 365242.01767, -0.11575, 0.00337, 0.00078), new Array(2451900.05952, 365242.74049, -0.06223, -0.00823, 0.00032)];\n    }\n\n    /**\n     *\n     * @param Degrees to radians.\n     * @return {number}\n     */\n\n\n    _createClass(ASTRO, [{\n        key: \"dtr\",\n        value: function dtr(d) {\n            return d * Math.PI / 180.0;\n        }\n\n        /**\n         * @desc Radians to degrees.\n         * @param r\n         * @return {number}\n         */\n\n    }, {\n        key: \"rtd\",\n        value: function rtd(r) {\n            return r * 180.0 / Math.PI;\n        }\n\n        /**\n         * @desc Range reduce angle in degrees.\n         * @param a\n         * @return {number}\n         */\n\n    }, {\n        key: \"fixangle\",\n        value: function fixangle(a) {\n            return a - 360.0 * Math.floor(a / 360.0);\n        }\n\n        /**\n         * @desc Range reduce angle in radians.\n         * @param a\n         * @return {number}\n         */\n\n    }, {\n        key: \"fixangr\",\n        value: function fixangr(a) {\n            return a - 2 * Math.PI * Math.floor(a / (2 * Math.PI));\n        }\n\n        /**\n         * @desc  Sine of an angle in degrees\n         * @param d\n         * @return {number}\n         */\n\n    }, {\n        key: \"dsin\",\n        value: function dsin(d) {\n            return Math.sin(this.dtr(d));\n        }\n\n        /**\n         * @desc Cosine of an angle in degrees\n         * @param d\n         * @return {number}\n         */\n\n    }, {\n        key: \"dcos\",\n        value: function dcos(d) {\n            return Math.cos(this.dtr(d));\n        }\n\n        /**\n         * @desc Modulus function which works for non-integers.\n         * @param a\n         * @param b\n         * @return {number}\n         */\n\n    }, {\n        key: \"mod\",\n        value: function mod(a, b) {\n            return a - b * Math.floor(a / b);\n        }\n\n        /**\n         *\n         * @param j\n         * @return {number}\n         */\n\n    }, {\n        key: \"jwday\",\n        value: function jwday(j) {\n            return this.mod(Math.floor(j + 1.5), 7);\n        }\n\n        /**\n         *\n         * @param jd\n         * @return {number|*}\n         */\n\n    }, {\n        key: \"obliqeq\",\n        value: function obliqeq(jd) {\n            var eps, u, v, i;\n            v = u = (jd - this.J2000) / (this.JulianCentury * 100);\n            eps = 23 + 26 / 60.0 + 21.448 / 3600.0;\n\n            if (Math.abs(u) < 1.0) {\n                for (i = 0; i < 10; i++) {\n                    eps += this.oterms[i] / 3600.0 * v;\n                    v *= u;\n                }\n            }\n            return eps;\n        }\n\n        /**\n         * @desc  Calculate the nutation in longitude, deltaPsi, and\n         obliquity, deltaEpsilon for a given Julian date\n         jd.  Results are returned as a two element Array\n         giving (deltaPsi, deltaEpsilon) in degrees.\n         * @param jd\n         * @return Object\n         */\n\n    }, {\n        key: \"nutation\",\n        value: function nutation(jd) {\n            var deltaPsi,\n                deltaEpsilon,\n                i,\n                j,\n                t = (jd - 2451545.0) / 36525.0,\n                t2,\n                t3,\n                to10,\n                ta = [],\n                dp = 0,\n                de = 0,\n                ang;\n\n            t3 = t * (t2 = t * t);\n\n            /* Calculate angles.  The correspondence between the elements\n             of our array and the terms cited in Meeus are:\n              ta[0] = D  ta[0] = M  ta[2] = M'  ta[3] = F  ta[4] = \\Omega\n              */\n\n            ta[0] = this.dtr(297.850363 + 445267.11148 * t - 0.0019142 * t2 + t3 / 189474.0);\n            ta[1] = this.dtr(357.52772 + 35999.05034 * t - 0.0001603 * t2 - t3 / 300000.0);\n            ta[2] = this.dtr(134.96298 + 477198.867398 * t + 0.0086972 * t2 + t3 / 56250.0);\n            ta[3] = this.dtr(93.27191 + 483202.017538 * t - 0.0036825 * t2 + t3 / 327270);\n            ta[4] = this.dtr(125.04452 - 1934.136261 * t + 0.0020708 * t2 + t3 / 450000.0);\n\n            /* Range reduce the angles in case the sine and cosine functions\n             don't do it as accurately or quickly. */\n\n            for (i = 0; i < 5; i++) {\n                ta[i] = this.fixangr(ta[i]);\n            }\n\n            to10 = t / 10.0;\n            for (i = 0; i < 63; i++) {\n                ang = 0;\n                for (j = 0; j < 5; j++) {\n                    if (this.nutArgMult[i * 5 + j] !== 0) {\n                        ang += this.nutArgMult[i * 5 + j] * ta[j];\n                    }\n                }\n                dp += (this.nutArgCoeff[i * 4 + 0] + this.nutArgCoeff[i * 4 + 1] * to10) * Math.sin(ang);\n                de += (this.nutArgCoeff[i * 4 + 2] + this.nutArgCoeff[i * 4 + 3] * to10) * Math.cos(ang);\n            }\n\n            /* Return the result, converting from ten thousandths of arc\n             seconds to radians in the process. */\n\n            deltaPsi = dp / (3600.0 * 10000.0);\n            deltaEpsilon = de / (3600.0 * 10000.0);\n\n            return [deltaPsi, deltaEpsilon];\n        }\n\n        /**\n         * @desc  Determine the difference, in seconds, between\n         Dynamical time and Universal time.\n         * @param year\n         * @return {*}\n         */\n\n    }, {\n        key: \"deltat\",\n        value: function deltat(year) {\n            var dt, f, i, t;\n\n            if (year >= 1620 && year <= 2000) {\n                i = Math.floor((year - 1620) / 2);\n                f = (year - 1620) / 2 - i;\n                /* Fractional part of year */\n                dt = this.deltaTtab[i] + (this.deltaTtab[i + 1] - this.deltaTtab[i]) * f;\n            } else {\n                t = (year - 2000) / 100;\n                if (year < 948) {\n                    dt = 2177 + 497 * t + 44.1 * t * t;\n                } else {\n                    dt = 102 + 102 * t + 25.3 * t * t;\n                    if (year > 2000 && year < 2100) {\n                        dt += 0.37 * (year - 2100);\n                    }\n                }\n            }\n            return dt;\n        }\n\n        /**\n         *\n         * @param year\n         * @param which\n         * @return {*}\n         */\n\n    }, {\n        key: \"equinox\",\n        value: function equinox(year, which) {\n            var deltaL = void 0,\n                i = void 0,\n                j = void 0,\n                JDE0 = void 0,\n                JDE = void 0,\n                JDE0tab = void 0,\n                S = void 0,\n                T = void 0,\n                W = void 0,\n                Y = void 0;\n            /*  Initialise terms for mean equinox and solstices.  We\n             have two sets: one for years prior to 1000 and a second\n             for subsequent years.  */\n\n            if (year < 1000) {\n                JDE0tab = this.JDE0tab1000;\n                Y = year / 1000;\n            } else {\n                JDE0tab = this.JDE0tab2000;\n                Y = (year - 2000) / 1000;\n            }\n\n            JDE0 = JDE0tab[which][0] + JDE0tab[which][1] * Y + JDE0tab[which][2] * Y * Y + JDE0tab[which][3] * Y * Y * Y + JDE0tab[which][4] * Y * Y * Y * Y;\n            T = (JDE0 - 2451545.0) / 36525;\n            W = 35999.373 * T - 2.47;\n            deltaL = 1 + 0.0334 * this.dcos(W) + 0.0007 * this.dcos(2 * W);\n            S = 0;\n            for (i = j = 0; i < 24; i++) {\n                S += this.EquinoxpTerms[j] * this.dcos(this.EquinoxpTerms[j + 1] + this.EquinoxpTerms[j + 2] * T);\n                j += 3;\n            }\n            JDE = JDE0 + S * 0.00001 / deltaL;\n            return JDE;\n        }\n\n        /**\n         * @desc  Position of the Sun.  Please see the comments\n         on the return statement at the end of this function\n         which describe the array it returns.  We return\n         intermediate values because they are useful in a\n         variety of other contexts.\n         * @param jd\n         * @return Object\n         */\n\n    }, {\n        key: \"sunpos\",\n        value: function sunpos(jd) {\n            var T = void 0,\n                T2 = void 0,\n                L0 = void 0,\n                M = void 0,\n                e = void 0,\n                C = void 0,\n                sunLong = void 0,\n                sunAnomaly = void 0,\n                sunR = void 0,\n                Omega = void 0,\n                Lambda = void 0,\n                epsilon = void 0,\n                epsilon0 = void 0,\n                Alpha = void 0,\n                Delta = void 0,\n                AlphaApp = void 0,\n                DeltaApp = void 0;\n\n            T = (jd - this.J2000) / this.JulianCentury;\n            T2 = T * T;\n            L0 = 280.46646 + 36000.76983 * T + 0.0003032 * T2;\n            L0 = this.fixangle(L0);\n            M = 357.52911 + 35999.05029 * T + -0.0001537 * T2;\n            M = this.fixangle(M);\n            e = 0.016708634 + -0.000042037 * T + -0.0000001267 * T2;\n            C = (1.914602 + -0.004817 * T + -0.000014 * T2) * this.dsin(M) + (0.019993 - 0.000101 * T) * this.dsin(2 * M) + 0.000289 * this.dsin(3 * M);\n            sunLong = L0 + C;\n            sunAnomaly = M + C;\n            sunR = 1.000001018 * (1 - e * e) / (1 + e * this.dcos(sunAnomaly));\n            Omega = 125.04 - 1934.136 * T;\n            Lambda = sunLong + -0.00569 + -0.00478 * this.dsin(Omega);\n            epsilon0 = this.obliqeq(jd);\n            epsilon = epsilon0 + 0.00256 * this.dcos(Omega);\n            Alpha = this.rtd(Math.atan2(this.dcos(epsilon0) * this.dsin(sunLong), this.dcos(sunLong)));\n            Alpha = this.fixangle(Alpha);\n            Delta = this.rtd(Math.asin(this.dsin(epsilon0) * this.dsin(sunLong)));\n            AlphaApp = this.rtd(Math.atan2(this.dcos(epsilon) * this.dsin(Lambda), this.dcos(Lambda)));\n            AlphaApp = this.fixangle(AlphaApp);\n            DeltaApp = this.rtd(Math.asin(this.dsin(epsilon) * this.dsin(Lambda)));\n\n            return [//  Angular quantities are expressed in decimal degrees\n            L0, //  [0] Geometric mean longitude of the Sun\n            M, //  [1] Mean anomaly of the Sun\n            e, //  [2] Eccentricity of the Earth's orbit\n            C, //  [3] Sun's equation of the Centre\n            sunLong, //  [4] Sun's true longitude\n            sunAnomaly, //  [5] Sun's true anomaly\n            sunR, //  [6] Sun's radius vector in AU\n            Lambda, //  [7] Sun's apparent longitude at true equinox of the date\n            Alpha, //  [8] Sun's true right ascension\n            Delta, //  [9] Sun's true declination\n            AlphaApp, // [10] Sun's apparent right ascension\n            DeltaApp // [11] Sun's apparent declination\n            ];\n        }\n\n        /**\n         * @desc Compute equation of time for a given moment. Returns the equation of time as a fraction of a day.\n         * @param jd\n         * @return {number|*}\n         */\n\n    }, {\n        key: \"equationOfTime\",\n        value: function equationOfTime(jd) {\n            var alpha = void 0,\n                deltaPsi = void 0,\n                E = void 0,\n                epsilon = void 0,\n                L0 = void 0,\n                tau = void 0;\n            tau = (jd - this.J2000) / this.JulianMillennium;\n            L0 = 280.4664567 + 360007.6982779 * tau + 0.03032028 * tau * tau + tau * tau * tau / 49931 + -(tau * tau * tau * tau / 15300) + -(tau * tau * tau * tau * tau / 2000000);\n            L0 = this.fixangle(L0);\n            alpha = this.sunpos(jd)[10];\n            deltaPsi = this.nutation(jd)[0];\n            epsilon = this.obliqeq(jd) + this.nutation(jd)[1];\n            E = L0 + -0.0057183 + -alpha + deltaPsi * this.dcos(epsilon);\n            E = E - 20.0 * Math.floor(E / 20.0);\n            E = E / (24 * 60);\n            return E;\n        }\n    }]);\n\n    return ASTRO;\n}();\n\nmodule.exports = ASTRO;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Constants\n * @module constants\n */\n\nmodule.exports = {\n    durationUnit: {\n        year: ['y', 'years', 'year'],\n        month: ['M', 'months', 'month'],\n        day: ['d', 'days', 'day'],\n        hour: ['h', 'hours', 'hour'],\n        minute: ['m', 'minutes', 'minute'],\n        second: ['s', 'second', 'seconds'],\n        millisecond: ['ms', 'milliseconds', 'millisecond'],\n        week: ['W', 'w', 'weeks', 'week']\n    }\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helpers = __webpack_require__(0);\nvar normalizeDuration = new Helpers().normalizeDuration;\nvar absRound = new Helpers().absRound;\nvar absFloor = new Helpers().absFloor;\n/**\n * Duration object constructor\n * @param duration\n * @class Duration\n * @constructor\n */\n\nvar Duration = function () {\n    function Duration(key, value) {\n        _classCallCheck(this, Duration);\n\n        var duration = {},\n            data = this._data = {},\n            milliseconds = 0,\n            normalizedUnit = normalizeDuration(key, value),\n            unit = normalizedUnit.unit;\n        duration[unit] = normalizedUnit.value;\n        milliseconds = duration.milliseconds || duration.millisecond || duration.ms || 0;\n\n        var years = duration.years || duration.year || duration.y || 0,\n            months = duration.months || duration.month || duration.M || 0,\n            weeks = duration.weeks || duration.w || duration.week || 0,\n            days = duration.days || duration.d || duration.day || 0,\n            hours = duration.hours || duration.hour || duration.h || 0,\n            minutes = duration.minutes || duration.minute || duration.m || 0,\n            seconds = duration.seconds || duration.second || duration.s || 0;\n        // representation for dateAddRemove\n        this._milliseconds = milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = days + weeks * 7;\n        // It is impossible translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = months + years * 12;\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n        seconds += absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n        minutes += absRound(seconds / 60);\n        data.minutes = minutes % 60;\n        hours += absRound(minutes / 60);\n        data.hours = hours % 24;\n        days += absRound(hours / 24);\n        days += weeks * 7;\n        data.days = days % 30;\n        months += absRound(days / 30);\n        data.months = months % 12;\n        years += absRound(months / 12);\n        data.years = years;\n        return this;\n    }\n\n    _createClass(Duration, [{\n        key: 'valueOf',\n        value: function valueOf() {\n            return this._milliseconds + this._days * 864e5 + this._months * 2592e6;\n        }\n    }]);\n\n    return Duration;\n}();\n\nmodule.exports = Duration;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Constants\n * @module constants\n */\n\nmodule.exports = {\n    gregorian: {\n        months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n        monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n        weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n        weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n        weekdaysMin: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n    },\n    persian: {\n        months: ['Farvardin', 'Ordibehesht', 'Khordad', 'Tir', 'Mordad', 'Shahrivar', 'Mehr', 'Aban', 'Azar', 'Dey', 'Bahman', 'Esfand'],\n        monthsShort: ['Far', 'Ord', 'Kho', 'Tir', 'Mor', 'Sha', 'Meh', 'Aba', 'Aza', 'Dey', 'Bah', 'Esf'],\n        weekdays: ['Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n        weekdaysShort: ['Sat', 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n        weekdaysMin: ['Sa', 'Su', 'Mo', 'Tu', 'We', 'Th', 'Fr'],\n        persianDaysName: ['Urmazd', 'Bahman', 'Ordibehesht', 'Shahrivar', 'Sepandarmaz', 'Khurdad', 'Amordad', 'Dey-be-azar', 'Azar', 'Aban', 'Khorshid', 'Mah', 'Tir', 'Gush', 'Dey-be-mehr', 'Mehr', 'Sorush', 'Rashn', 'Farvardin', 'Bahram', 'Ram', 'Bad', 'Dey-be-din', 'Din', 'Ord', 'Ashtad', 'Asman', 'Zamyad', 'Mantre-sepand', 'Anaram', 'Ziadi']\n    }\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Constants\n * @module constants\n */\n\nmodule.exports = {\n    gregorian: {\n        months: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),\n        monthsShort: 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),\n        weekdays: '\\u06CC\\u06A9\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062F\\u0648\\u0634\\u0646\\u0628\\u0647_\\u0633\\u0647\\u200C\\u0634\\u0646\\u0628\\u0647_\\u0686\\u0647\\u0627\\u0631\\u0634\\u0646\\u0628\\u0647_\\u067E\\u0646\\u062C\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062C\\u0645\\u0639\\u0647_\\u0634\\u0646\\u0628\\u0647'.split('_'),\n        weekdaysShort: '\\u06CC\\u06A9\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062F\\u0648\\u0634\\u0646\\u0628\\u0647_\\u0633\\u0647\\u200C\\u0634\\u0646\\u0628\\u0647_\\u0686\\u0647\\u0627\\u0631\\u0634\\u0646\\u0628\\u0647_\\u067E\\u0646\\u062C\\u200C\\u0634\\u0646\\u0628\\u0647_\\u062C\\u0645\\u0639\\u0647_\\u0634\\u0646\\u0628\\u0647'.split('_'),\n        weekdaysMin: 'ی_د_س_چ_پ_ج_ش'.split('_')\n    },\n    persian: {\n        months: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],\n        monthsShort: ['فرو', 'ارد', 'خرد', 'تیر', 'مرد', 'شهر', 'مهر', 'آبا', 'آذر', 'دی', 'بهم', 'اسف'],\n        weekdays: ['شنبه', 'یکشنبه', 'دوشنبه', 'سه شنبه', 'چهار شنبه', '\\u067E\\u0646\\u062C\\u200C\\u0634\\u0646\\u0628\\u0647', 'جمعه'],\n        weekdaysShort: ['ش', 'ی', 'د', 'س', 'چ', 'پ', 'ج'],\n        weekdaysMin: ['ش', 'ی', 'د', 'س', 'چ', 'پ', 'ج'],\n        persianDaysName: ['اورمزد', 'بهمن', 'اوردیبهشت', 'شهریور', 'سپندارمذ', 'خورداد', 'امرداد', 'دی به آذز', 'آذز', 'آبان', 'خورشید', 'ماه', 'تیر', 'گوش', 'دی به مهر', 'مهر', 'سروش', 'رشن', 'فروردین', 'بهرام', 'رام', 'باد', 'دی به دین', 'دین', 'ارد', 'اشتاد', 'آسمان', 'زامیاد', 'مانتره سپند', 'انارام', 'زیادی']\n    }\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar PersianDateClass = __webpack_require__(1);\nPersianDateClass.calendarType = 'persian';\nPersianDateClass.leapYearMode = 'astronomical';\nPersianDateClass.localType = 'fa';\nmodule.exports = PersianDateClass;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Container = function Container() {\n    _classCallCheck(this, Container);\n\n    this.isInvalidDate = null;\n\n    this.gDate = null;\n    /**\n     *\n     * @type {number}\n     */\n    this.modifiedjulianday = 0;\n\n    /**\n     *\n     * @type {number}\n     */\n    this.julianday = 0;\n\n    /**\n     *\n     * @type {{day: number}}\n     */\n    this.gregserial = {\n        day: 0\n    };\n\n    this.zone = 0;\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, weekday: number, unix: number, leap: number}}\n     */\n    this.gregorian = {\n        year: 0,\n        month: 0,\n        day: 0,\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0,\n        weekday: 0,\n        unix: 0,\n        leap: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.juliancalendar = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.islamic = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.persianAlgo = this.persian = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, month: number, day: number, leap: number, weekday: number}}\n     */\n    this.persianAstro = {\n        year: 0,\n        month: 0,\n        day: 0,\n        leap: 0,\n        weekday: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, week: number, day: number}}\n     */\n    this.isoweek = {\n        year: 0,\n        week: 0,\n        day: 0\n    };\n\n    /**\n     *\n     * @type {{year: number, day: number}}\n     */\n    this.isoday = {\n        year: 0,\n        day: 0\n    };\n};\n\nmodule.exports = Container;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n    /**\n     * @param input\n     * @returns {boolean}\n     */\n    isArray: function isArray(input) {\n        return Object.prototype.toString.call(input) === '[object Array]';\n    },\n\n\n    /**\n     *\n     * @param input\n     * @returns {boolean}\n     */\n    isNumber: function isNumber(input) {\n        return typeof input === 'number';\n    },\n\n\n    /**\n     *\n     * @param input\n     * @returns {boolean}\n     */\n    isDate: function isDate(input) {\n        return input instanceof Date;\n    }\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  /**\n   * @param input\n   * @returns {boolean}\n   */\n  validateInputArray: function validateInputArray(input) {\n    var out = true;\n    // Check month\n    if (input[1] < 1 || input[1] > 12) {\n      out = false;\n    }\n    // Check date\n    if (input[2] < 1 || input[1] > 31) {\n      out = false;\n    }\n    // Check hour \n    if (input[3] < 0 || input[3] > 24) {\n      out = false;\n    }\n    // Check minute \n    if (input[4] < 0 || input[4] > 60) {\n      out = false;\n    }\n    // Check second \n    if (input[5] < 0 || input[5] > 60) {\n      out = false;\n    }\n    return out;\n  }\n};\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGVyc2lhbi1kYXRlL2Rpc3QvcGVyc2lhbi1kYXRlLmpzP2E3N2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUs0QjtBQUNsQyxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2Sjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckIsbUJBQW1CLEVBQUU7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCLG1CQUFtQixFQUFFO0FBQ3JCLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUU7QUFDckI7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixvQkFBb0I7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixFQUFFO0FBQ3JCOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsRUFBRTtBQUNyQjs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3BlcnNpYW4tZGF0ZS9kaXN0L3BlcnNpYW4tZGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogXG4gKiBwZXJzaWFuLWRhdGUgLSAgMS4xLjBcbiAqIFJlemEgQmFiYWtoYW5pIDxiYWJha2hhbmkucmV6YUBnbWFpbC5jb20+XG4gKiBodHRwOi8vYmFiYWtoYW5pLmdpdGh1Yi5pby9QZXJzaWFuV2ViVG9vbGtpdC9kb2NzL3BlcnNpYW4tZGF0ZS9cbiAqIFVuZGVyIE1JVCBsaWNlbnNlIFxuICogXG4gKiBcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicGVyc2lhbkRhdGVcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicGVyc2lhbkRhdGVcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gOCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBkdXJhdGlvblVuaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLmR1cmF0aW9uVW5pdDtcblxudmFyIEhlbHBlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVycygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcnMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIZWxwZXJzLCBbe1xuICAgICAgICBrZXk6ICd0b1BlcnNpYW5EaWdpdCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIHJldHVybiBjb252ZXJ0ZWQgc3RyaW5nIHRvIHBlcnNpYW4gZGlnaXRcbiAgICAgICAgICogQHBhcmFtIGRpZ2l0XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b1BlcnNpYW5EaWdpdChkaWdpdCkge1xuICAgICAgICAgICAgdmFyIGxhdGluRGlnaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gZGlnaXQudG9TdHJpbmcoKS5yZXBsYWNlKC9cXGQrL2csIGZ1bmN0aW9uIChkaWdpdCkge1xuICAgICAgICAgICAgICAgIHZhciBlbkRpZ2l0QXJyID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHBlRGlnaXRBcnIgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgaiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlnaXQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5EaWdpdEFyci5wdXNoKGRpZ2l0LmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZW5EaWdpdEFyci5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwZURpZ2l0QXJyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShlbkRpZ2l0QXJyW2pdICsgKCEhbGF0aW5EaWdpdCAmJiBsYXRpbkRpZ2l0ID09PSB0cnVlID8gMTU4NCA6IDE3MjgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwZURpZ2l0QXJyLmpvaW4oJycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG51bWJlclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZWZ0WmVyb0ZpbGwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVmdFplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gbnVtYmVyICsgJyc7XG4gICAgICAgICAgICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIG5vcm1hbGl6ZSBkdXJhdGlvbiBwYXJhbXMgYW5kIHJldHVybiB2YWxpZCBwYXJhbVxuICAgICAgICAgKiBAcmV0dXJuIHt7dW5pdDogKiwgdmFsdWU6ICp9fVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9ybWFsaXplRHVyYXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbm9ybWFsaXplRHVyYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgdW5pdCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVuaXQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHVuaXQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHVyYXRpb25Vbml0LnllYXIuaW5kZXhPZih1bml0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICd5ZWFyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25Vbml0Lm1vbnRoLmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAnbW9udGgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvblVuaXQud2Vlay5pbmRleE9mKHVuaXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ3dlZWsnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvblVuaXQuZGF5LmluZGV4T2YodW5pdCkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25Vbml0LmhvdXIuaW5kZXhPZih1bml0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdob3VyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb25Vbml0Lm1pbnV0ZS5pbmRleE9mKHVuaXQpID4gLTEpIHtcbiAgICAgICAgICAgICAgICB1bml0ID0gJ21pbnV0ZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uVW5pdC5zZWNvbmQuaW5kZXhPZih1bml0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdzZWNvbmQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvblVuaXQubWlsbGlzZWNvbmQuaW5kZXhPZih1bml0KSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9ICdtaWxsaXNlY29uZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVuaXQ6IHVuaXQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW1iZXJcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Fic1JvdW5kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFic1JvdW5kKG51bWJlcikge1xuICAgICAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG51bWJlclxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhYnNGbG9vcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEhlbHBlcnM7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSGVscGVycztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBUeXBlQ2hlY2tpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBBbGdvcml0aG1zID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBEdXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgVmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgdG9QZXJzaWFuRGlnaXQgPSBuZXcgSGVscGVycygpLnRvUGVyc2lhbkRpZ2l0O1xudmFyIGxlZnRaZXJvRmlsbCA9IG5ldyBIZWxwZXJzKCkubGVmdFplcm9GaWxsO1xudmFyIG5vcm1hbGl6ZUR1cmF0aW9uID0gbmV3IEhlbHBlcnMoKS5ub3JtYWxpemVEdXJhdGlvbjtcbnZhciBmYSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBwZXJzaWFuIGRhdGUgY2xhc3NcbiAqL1xuXG52YXIgUGVyc2lhbkRhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm4ge1BlcnNpYW5EYXRlQ2xhc3N9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUGVyc2lhbkRhdGVDbGFzcyhpbnB1dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGVyc2lhbkRhdGVDbGFzcyk7XG5cbiAgICAgICAgdGhpcy5jYWxlbmRhclR5cGUgPSBQZXJzaWFuRGF0ZUNsYXNzLmNhbGVuZGFyVHlwZTtcbiAgICAgICAgdGhpcy5sb2NhbFR5cGUgPSBQZXJzaWFuRGF0ZUNsYXNzLmxvY2FsVHlwZTtcbiAgICAgICAgdGhpcy5sZWFwWWVhck1vZGUgPSBQZXJzaWFuRGF0ZUNsYXNzLmxlYXBZZWFyTW9kZTtcblxuICAgICAgICB0aGlzLmFsZ29yaXRobXMgPSBuZXcgQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIxLjEuMFwiO1xuICAgICAgICB0aGlzLl91dGNNb2RlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsVHlwZSAhPT0gJ2ZhJykge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQZXJzaWFuID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBlcnNpYW4gPSAnX2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuU3RhdGUgPSB0aGlzLmFsZ29yaXRobXMuU3RhdGU7XG4gICAgICAgIHRoaXMuc2V0dXAoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5TdGF0ZS5pc0ludmFsaWREYXRlKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gRGF0ZSBsaWtlIG1lc3NhZ2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShbLTEsIC0xXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhQZXJzaWFuRGF0ZUNsYXNzLCBbe1xuICAgICAgICBrZXk6ICdzZXR1cCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cChpbnB1dCkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBBbnkgdGhpbmcgdG8gR3JlZ29yaWFuIERhdGVcbiAgICAgICAgICAgIGlmIChUeXBlQ2hlY2tpbmcuaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dEYXRlVG9DYWxjdWxhdG9ycyhpbnB1dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFR5cGVDaGVja2luZy5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmICghVmFsaWRhdG9yLnZhbGlkYXRlSW5wdXRBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5pc0ludmFsaWREYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFtpbnB1dFswXSwgaW5wdXRbMV0gPyBpbnB1dFsxXSA6IDEsIGlucHV0WzJdID8gaW5wdXRbMl0gOiAxLCBpbnB1dFszXSA/IGlucHV0WzNdIDogMCwgaW5wdXRbNF0gPyBpbnB1dFs0XSA6IDAsIGlucHV0WzVdID8gaW5wdXRbNV0gOiAwLCBpbnB1dFs2XSA/IGlucHV0WzZdIDogMF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChUeXBlQ2hlY2tpbmcuaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21Vbml4ID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dEYXRlVG9DYWxjdWxhdG9ycyhmcm9tVW5peCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbnN0YW5jZSBvZiBwRGF0ZVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBQZXJzaWFuRGF0ZUNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc0NhbGMoW2lucHV0LnllYXIoKSwgaW5wdXQubW9udGgoKSwgaW5wdXQuZGF0ZSgpLCBpbnB1dC5ob3VyKCksIGlucHV0Lm1pbnV0ZSgpLCBpbnB1dC5zZWNvbmQoKSwgaW5wdXQubWlsbGlzZWNvbmQoKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBU1AuTkVUIEpTT04gRGF0ZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlucHV0ICYmIGlucHV0LnN1YnN0cmluZygwLCA2KSA9PT0gJy9EYXRlKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tRG90TmV0ID0gbmV3IERhdGUocGFyc2VJbnQoaW5wdXQuc3Vic3RyKDYpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nRGF0ZVRvQ2FsY3VsYXRvcnMoZnJvbURvdE5ldCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dEYXRlVG9DYWxjdWxhdG9ycyhub3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0U3luY2VkQ2xhc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN5bmNlZENsYXNzKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgc3luY2VkQ2VsYW5kZXIgPSBQZXJzaWFuRGF0ZUNsYXNzLnRvQ2FsZW5kYXIodGhpcy5jYWxlbmRhclR5cGUpLnRvTG9jYWxlKHRoaXMubG9jYWxUeXBlKS50b0xlYXBZZWFyTW9kZSh0aGlzLmxlYXBZZWFyTW9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRnRGF0ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dEYXRlVG9DYWxjdWxhdG9ycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ0RhdGVUb0NhbGN1bGF0b3JzKGlucHV0Z0RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtcy5jYWxjR3JlZ29yaWFuKFtpbnB1dGdEYXRlLmdldEZ1bGxZZWFyKCksIGlucHV0Z0RhdGUuZ2V0TW9udGgoKSwgaW5wdXRnRGF0ZS5nZXREYXRlKCksIGlucHV0Z0RhdGUuZ2V0SG91cnMoKSwgaW5wdXRnRGF0ZS5nZXRNaW51dGVzKCksIGlucHV0Z0RhdGUuZ2V0U2Vjb25kcygpLCBpbnB1dGdEYXRlLmdldE1pbGxpc2Vjb25kcygpXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBIZWxwZXIgbWV0aG9kIHRoYXQgcmV0dXJuIGRhdGUgcmFuZ2UgbmFtZSBsaWtlIHdlZWsgZGF5cyBuYW1lLCBtb250aCBuYW1lcywgbW9udGggZGF5cyBuYW1lcyAoc3BlY2lhbGx5IGluIHBlcnNpYW4gY2FsZW5kYXIpLlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyYW5nZU5hbWUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gSGVscGVyIG1ldGhvZCB0aGF0IHJldHVybiBkYXRlIHJhbmdlIG5hbWUgbGlrZSB3ZWVrIGRheXMgbmFtZSwgbW9udGggbmFtZXMsIG1vbnRoIGRheXMgbmFtZXMgKHNwZWNpYWxseSBpbiBwZXJzaWFuIGNhbGVuZGFyKS5cbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByYW5nZU5hbWUoKSB7XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXMuY2FsZW5kYXJUeXBlO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUeXBlID09PSAnZmEnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICdwZXJzaWFuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmEucGVyc2lhbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmEuZ3JlZ29yaWFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHQgPT09ICdwZXJzaWFuJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW4ucGVyc2lhbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW4uZ3JlZ29yaWFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm4ge1BlcnNpYW5EYXRlQ2xhc3N9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0xlYXBZZWFyTW9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b0xlYXBZZWFyTW9kZShpbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5sZWFwWWVhck1vZGUgPSBpbnB1dDtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gJ2FzdHJvbm9taWNhbCcgJiYgdGhpcy5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFwWWVhck1vZGUgPSAnYXN0cm9ub21pY2FsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09ICdhbGdvcml0aG1pYycgJiYgdGhpcy5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFwWWVhck1vZGUgPSAnYWxnb3JpdGhtaWMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zLnVwZGF0ZUZyb21HcmVnb3JpYW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9DYWxlbmRhcicsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvQ2FsZW5kYXIoaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJUeXBlID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLmFsZ29yaXRobXMudXBkYXRlRnJvbUdyZWdvcmlhbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm4ge1BlcnNpYW5EYXRlQ2xhc3N9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0xvY2FsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTG9jYWxlKGlucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsVHlwZSA9IGlucHV0O1xuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUeXBlICE9PSAnZmEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRQZXJzaWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0UGVyc2lhbiA9ICdfZGVmYXVsdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2xvY2FsZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9jYWxlKCkge1xuICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmNhbGVuZGFyVHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsVHlwZSA9PT0gJ2ZhJykge1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhLnBlcnNpYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhLmdyZWdvcmlhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuLnBlcnNpYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuLmdyZWdvcmlhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfd2Vla05hbWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dlZWtOYW1lKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlKCkud2Vla2RheXNbaW5wdXQgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ193ZWVrTmFtZVNob3J0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93ZWVrTmFtZVNob3J0KGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlKCkud2Vla2RheXNTaG9ydFtpbnB1dCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dlZWtOYW1lTWluJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93ZWVrTmFtZU1pbihpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZSgpLndlZWtkYXlzTWluW2lucHV0IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZGF5TmFtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGF5TmFtZShpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZSgpLnBlcnNpYW5EYXlzTmFtZVtpbnB1dCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21vbnRoTmFtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW9udGhOYW1lKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlKCkubW9udGhzW2lucHV0IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfbW9udGhOYW1lU2hvcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21vbnRoTmFtZVNob3J0KGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlKCkubW9udGhzU2hvcnRbaW5wdXQgLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNQZXJzaWFuRGF0ZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGVyc2lhbkRhdGUob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUGVyc2lhbkRhdGVDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UGVyc2lhbkRhdGV9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjbG9uZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTeW5jZWRDbGFzcyh0aGlzLlN0YXRlLmdEYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHBhcmFtIGRhdGVBcnJheVxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWxnb3JpdGhtc0NhbGMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWxnb3JpdGhtc0NhbGMoZGF0ZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1BlcnNpYW5EYXRlKGRhdGVBcnJheSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlQXJyYXkgPSBbZGF0ZUFycmF5LnllYXIoKSwgZGF0ZUFycmF5Lm1vbnRoKCksIGRhdGVBcnJheS5kYXRlKCksIGRhdGVBcnJheS5ob3VyKCksIGRhdGVBcnJheS5taW51dGUoKSwgZGF0ZUFycmF5LnNlY29uZCgpLCBkYXRlQXJyYXkubWlsbGlzZWNvbmQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdwZXJzaWFuJyAmJiB0aGlzLmxlYXBZZWFyTW9kZSA9PSAnYWxnb3JpdGhtaWMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtcy5jYWxjUGVyc2lhbihkYXRlQXJyYXkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PT0gJ3BlcnNpYW4nICYmIHRoaXMubGVhcFllYXJNb2RlID09ICdhc3Ryb25vbWljYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtcy5jYWxjUGVyc2lhbmEoZGF0ZUFycmF5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdncmVnb3JpYW4nKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUFycmF5WzFdID0gZGF0ZUFycmF5WzFdIC0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbGdvcml0aG1zLmNhbGNHcmVnb3JpYW4oZGF0ZUFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NhbGVuZGFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGVuZGFyKCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sZWFwWWVhck1vZGUgPT0gJ2FzdHJvbm9taWNhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gJ3BlcnNpYW5Bc3Rybyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxlYXBZZWFyTW9kZSA9PSAnYWxnb3JpdGhtaWMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9ICdwZXJzaWFuQWxnbyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSAnZ3JlZ29yaWFuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLlN0YXRlW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIHJldHVybiBEdXJhdGlvbiBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICogQHJldHVybnMge0R1cmF0aW9ufVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHVyYXRpb24nLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiByZXR1cm4gRHVyYXRpb24gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtEdXJhdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdXJhdGlvbihpbnB1dCwga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IER1cmF0aW9uKGlucHV0LCBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBjaGVjayBpZiBwYXNzZWQgb2JqZWN0IGlzIGR1cmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0R1cmF0aW9uJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gY2hlY2sgaWYgcGFzc2VkIG9iamVjdCBpcyBkdXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRHVyYXRpb24ob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAneWVhcnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24geWVhcnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnllYXIoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3llYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24geWVhcihpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhbaW5wdXQsIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIHRoaXMuaG91cigpLCB0aGlzLm1pbnV0ZSgpLCB0aGlzLnNlY29uZCgpLCB0aGlzLm1pbGxpc2Vjb25kKCldKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXIoKS55ZWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vbnRoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vbnRoKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgfHwgaW5wdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFt0aGlzLnllYXIoKSwgaW5wdXQsIHRoaXMuZGF0ZSgpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyKCkubW9udGggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERheSBvZiB3ZWVrXG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxEYXRlLnRvSlNPTi5kYXl8ZGF0ZV9qc29uLmRheXxQZXJzaWFuRGF0ZS5kYXl8ZGF5fG91dHB1dC5kYXl8Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RheXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGF5cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxEYXRlLnRvSlNPTi5kYXl8ZGF0ZV9qc29uLmRheXxQZXJzaWFuRGF0ZS5kYXl8ZGF5fG91dHB1dC5kYXl8Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhcigpLndlZWtkYXk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF5IG9mIE1vbnRoc1xuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkYXRlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlcyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkYXRlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgfHwgaW5wdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCBpbnB1dF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhcigpLmRheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdob3VyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhvdXIoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvdXJzKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdob3VycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBob3VycyhpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gMjQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc0NhbGMoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCBpbnB1dF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TdGF0ZS5nRGF0ZS5nZXRIb3VycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21pbnV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaW51dGUoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbnV0ZXMoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21pbnV0ZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWludXRlcyhpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIHRoaXMuaG91cigpLCBpbnB1dF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5TdGF0ZS5nRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2Vjb25kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlY29uZChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcyhpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2Vjb25kcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWNvbmRzKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgfHwgaW5wdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFsZ29yaXRobXNDYWxjKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VyKCksIHRoaXMubWludXRlKCksIGlucHV0XSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0YXRlLmdEYXRlLmdldFNlY29uZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqIEdldHRlciBTZXR0ZXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbGxpc2Vjb25kKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZHMoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21pbGxpc2Vjb25kcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtaWxsaXNlY29uZHMoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dCB8fCBpbnB1dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxnb3JpdGhtc0NhbGMoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXIoKSwgdGhpcy5taW51dGUoKSwgdGhpcy5zZWNvbmQoKSwgaW5wdXRdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBNaWxsaXNlY29uZHMgc2luY2UgdGhlIFVuaXggRXBvY2ggKDEzMTg4NzQzOTg4MDYpXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gICAgX3ZhbHVlT2YgKCkge1xuICAgICAgICAvLyAgICAgICAgcmV0dXJuIHRoaXMuU3RhdGUuZ0RhdGUudmFsdWVPZigpO1xuICAgICAgICAvLyAgICB9XG5cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5peCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIFVuaXggVGltZXN0YW1wICgxMzE4ODc0Mzk4KVxuICAgICAgICAgKiBAcGFyYW0gdGltZXN0YW1wXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuaXgodGltZXN0YW1wKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTeW5jZWRDbGFzcyh0aW1lc3RhbXAgKiAxMDAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IHRoaXMuU3RhdGUuZ0RhdGUudmFsdWVPZigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3ZhbHVlT2YnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlN0YXRlLmdEYXRlLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geWVhclxuICAgICAgICAgKiBAcGFyYW0gbW9udGhcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Rmlyc3RXZWVrRGF5T2ZNb250aCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHllYXJcbiAgICAgICAgICogQHBhcmFtIG1vbnRoXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGaXJzdFdlZWtEYXlPZk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3luY2VkQ2xhc3MoW3llYXIsIG1vbnRoLCAxXSkuZGF5KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGlucHV0XG4gICAgICAgICAqIEBwYXJhbSB2YWxcbiAgICAgICAgICogQHBhcmFtIGFzRmxvYXRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkaWZmJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRpZmYoaW5wdXQsIHZhbCwgYXNGbG9hdCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGlucHV0TW9tZW50ID0gaW5wdXQsXG4gICAgICAgICAgICAgICAgem9uZURpZmYgPSAwLFxuICAgICAgICAgICAgICAgIGRpZmYgPSBzZWxmLlN0YXRlLmdEYXRlIC0gaW5wdXRNb21lbnQudG9EYXRlKCkgLSB6b25lRGlmZixcbiAgICAgICAgICAgICAgICB5ZWFyID0gc2VsZi55ZWFyKCkgLSBpbnB1dE1vbWVudC55ZWFyKCksXG4gICAgICAgICAgICAgICAgbW9udGggPSBzZWxmLm1vbnRoKCkgLSBpbnB1dE1vbWVudC5tb250aCgpLFxuICAgICAgICAgICAgICAgIGRhdGUgPSAoc2VsZi5kYXRlKCkgLSBpbnB1dE1vbWVudC5kYXRlKCkpICogLTEsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAodmFsID09PSAnbW9udGhzJyB8fCB2YWwgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB5ZWFyICogMTIgKyBtb250aCArIGRhdGUgLyAzMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID09PSAneWVhcnMnIHx8IHZhbCA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0geWVhciArIChtb250aCArIGRhdGUgLyAzMCkgLyAxMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdmFsID09PSAnc2Vjb25kcycgfHwgdmFsID09PSAnc2Vjb25kJyA/IGRpZmYgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdmFsID09PSAnbWludXRlcycgfHwgdmFsID09PSAnbWludXRlJyA/IGRpZmYgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB2YWwgPT09ICdob3VycycgfHwgdmFsID09PSAnaG91cicgPyBkaWZmIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgdmFsID09PSAnZGF5cycgfHwgdmFsID09PSAnZGF5JyA/IGRpZmYgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjRcbiAgICAgICAgICAgICAgICB2YWwgPT09ICd3ZWVrcycgfHwgdmFsID09PSAnd2VlaycgPyBkaWZmIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDdcbiAgICAgICAgICAgICAgICBkaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBNYXRoLnJvdW5kKG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0YXJ0T2YnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRPZihrZXkpIHtcbiAgICAgICAgICAgIHZhciBzeW5jZWRDZWxhbmRlciA9IFBlcnNpYW5EYXRlQ2xhc3MudG9DYWxlbmRhcih0aGlzLmNhbGVuZGFyVHlwZSkudG9Mb2NhbGUodGhpcy5sb2NhbFR5cGUpO1xuICAgICAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IFBlcnNpYW5EYXRlQ2xhc3ModGhpcy52YWx1ZU9mKCkgLSAodGhpcy5jYWxlbmRhcigpLndlZWtkYXkgLSAxKSAqIDg2NDAwMDAwKS50b0FycmF5KCk7XG4gICAgICAgICAgICAvLyBTaW1wbGlmeSB0aGlzXFxcbiAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcnMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgMSwgMV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRocyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxXSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5cyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIDAsIDAsIDBdKTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXJzKCksIDAsIDBdKTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGVzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHN5bmNlZENlbGFuZGVyKFt0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSwgdGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgMF0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCB0aGlzLnNlY29uZHMoKV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWtzJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihuZXdBcnJheSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNhc2UtZGVjbGFyYXRpb25zICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VuZE9mJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE9mKGtleSkge1xuICAgICAgICAgICAgdmFyIHN5bmNlZENlbGFuZGVyID0gUGVyc2lhbkRhdGVDbGFzcy50b0NhbGVuZGFyKHRoaXMuY2FsZW5kYXJUeXBlKS50b0xvY2FsZSh0aGlzLmxvY2FsVHlwZSk7XG4gICAgICAgICAgICAvLyBTaW1wbGlmeSB0aGlzXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXJzJzpcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRheXMgPSB0aGlzLmlzTGVhcFllYXIoKSA/IDMwIDogMjk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCAxMiwgZGF5cywgMjMsIDU5LCA1OV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRocyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgICAgICB2YXIgbW9udGhEYXlzID0gdGhpcy5kYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgbW9udGhEYXlzLCAyMywgNTksIDU5XSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5cyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIDIzLCA1OSwgNTldKTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3Vycyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXJzKCksIDU5LCA1OV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCA1OV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3luY2VkQ2VsYW5kZXIoW3RoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpLCB0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCB0aGlzLnNlY29uZHMoKV0pO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWtzJzpcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdlZWtEYXlOdW1iZXIgPSB0aGlzLmNhbGVuZGFyKCkud2Vla2RheTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBzeW5jZWRDZWxhbmRlcihbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAoNyAtIHdlZWtEYXlOdW1iZXIpXSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NvZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VvZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlb2QoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmRPZignZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogR2V0IHRoZSB0aW1lem9uZSBvZmZzZXQgaW4gbWludXRlcy5cbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3pvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gem9uZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKGlucHV0IHx8IGlucHV0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS56b25lID0gaW5wdXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlN0YXRlLnpvbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1BlcnNpYW5EYXRlfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbG9jYWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9jYWwoKSB7XG4gICAgICAgICAgICB2YXIgdXRjU3RhbXAgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXRjTW9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBUaGF0RGF5T2Zmc2V0ID0gbmV3IERhdGUodGhpcy50b0RhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TWlscyA9IFRoYXREYXlPZmZzZXQgKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgaWYgKFRoYXREYXlPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0Y1N0YW1wID0gdGhpcy52YWx1ZU9mKCkgLSBvZmZzZXRNaWxzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIHV0Y1N0YW1wID0gdGhpcy52YWx1ZU9mKCkgKyBvZmZzZXRNaWxzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRvQ2FsZW5kYXIoUGVyc2lhbkRhdGVDbGFzcy5jYWxlbmRhclR5cGUpO1xuICAgICAgICAgICAgICAgIHZhciB1dGNEYXRlID0gbmV3IERhdGUodXRjU3RhbXApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dEYXRlVG9DYWxjdWxhdG9ycyh1dGNEYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91dGNNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lKFRoYXREYXlPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gaW5wdXRcbiAgICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3V0YycsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEN1cnJlbnQgZGF0ZS90aW1lIGluIFVUQyBtb2RlXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1dGMoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciB1dGNTdGFtcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRTeW5jZWRDbGFzcyhpbnB1dCkudXRjKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fdXRjTW9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0TWlscyA9IHRoaXMuem9uZSgpICogNjAgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnpvbmUoKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXRjU3RhbXAgPSB0aGlzLnZhbHVlT2YoKSArIG9mZnNldE1pbHM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgdXRjU3RhbXAgPSB0aGlzLnZhbHVlT2YoKSAtIG9mZnNldE1pbHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB1dGNEYXRlID0gbmV3IERhdGUodXRjU3RhbXApLFxuICAgICAgICAgICAgICAgICAgICBkID0gdGhpcy5fZ2V0U3luY2VkQ2xhc3ModXRjRGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGdvcml0aG1zQ2FsYyhkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91dGNNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUoMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1V0YycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1V0YygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91dGNNb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAbGluayBodHRwczovL2ZhLndpa2lwZWRpYS5vcmcvd2lraS8lRDglQjMlRDglQTclRDglQjklRDglQUFfJUQ4JUFBJUQ4JUE3JUQ4JUE4JUQ4JUIzJUQ4JUFBJUQ4JUE3JUQ5JTg2JURCJThDXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0RTVCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0RTVCgpIHtcbiAgICAgICAgICAgIHZhciBtb250aCA9IHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICBkYXkgPSB0aGlzLmRhdGUoKTtcbiAgICAgICAgICAgIGlmIChtb250aCA9PSAxICYmIGRheSA+IDEgfHwgbW9udGggPT0gNiAmJiBkYXkgPCAzMSB8fCBtb250aCA8IDYgJiYgbW9udGggPj0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0xlYXBZZWFyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHllYXIgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PSAncGVyc2lhbicgJiYgdGhpcy5sZWFwWWVhck1vZGUgPT09ICdhbGdvcml0aG1pYycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbGdvcml0aG1zLmxlYXBfcGVyc2lhbih5ZWFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PSAncGVyc2lhbicgJiYgdGhpcy5sZWFwWWVhck1vZGUgPT09ICdhc3Ryb25vbWljYWwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxnb3JpdGhtcy5sZWFwX3BlcnNpYW5hKHllYXIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PSAnZ3JlZ29yaWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsZ29yaXRobXMubGVhcF9ncmVnb3JpYW4oeWVhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHllYXJJbnB1dFxuICAgICAgICAgKiBAcGFyYW0gbW9udGhJbnB1dFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGF5c0luTW9udGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhcklucHV0LCBtb250aElucHV0KSB7XG4gICAgICAgICAgICB2YXIgeWVhciA9IHllYXJJbnB1dCA/IHllYXJJbnB1dCA6IHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgIG1vbnRoID0gbW9udGhJbnB1dCA/IG1vbnRoSW5wdXQgOiB0aGlzLm1vbnRoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhclR5cGUgPT09ICdwZXJzaWFuJykge1xuICAgICAgICAgICAgICAgIGlmIChtb250aCA8IDEgfHwgbW9udGggPiAxMikgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoIDwgNykgcmV0dXJuIDMxO1xuICAgICAgICAgICAgICAgIGlmIChtb250aCA8IDEyKSByZXR1cm4gMzA7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMZWFwWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAyOTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFyVHlwZSA9PT0gJ2dyZWdvcmlhbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeWVhciwgbW9udGgsIDApLmdldERhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIE5hdGl2ZSBKYXZhc2NyaXB0IERhdGVcbiAgICAgICAgICogQHJldHVybnMgeyp8UGVyc2lhbkRhdGUuZ0RhdGV9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0b0RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9EYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuU3RhdGUuZ0RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgQXJyYXkgT2YgUGVyc2lhbiBEYXRlXG4gICAgICAgICAqIEByZXR1cm5zIHthcnJheX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCksIHRoaXMuaG91cigpLCB0aGlzLm1pbnV0ZSgpLCB0aGlzLnNlY29uZCgpLCB0aGlzLm1pbGxpc2Vjb25kKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZm9ybWF0TnVtYmVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZvcm1hdE51bWJlcigpIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGlmIGRlZmF1bHQgY29uZiBkb3NlbnQgc2V0IGZvbGxvdyBnb2xiYWwgY29uZmlnXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXRQZXJzaWFuID09PSAnX2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuZm9ybWF0UGVyc2lhbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBDb25mXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93LmZvcm1hdFBlcnNpYW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgQ29uZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0UGVyc2lhbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb3JtYXRQZXJzaWFuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBFcnJvcignSW52YWxpZCBDb25maWcgXCJmb3JtYXRQZXJzaWFuXCIgISEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Zvcm1hdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLlN0YXRlLmlzSW52YWxpZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGluZ1Rva2VucyA9IC8oW1teW10qXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfEREP0Q/RD98ZGRkZGRkP3xkZGRkZD98ZGRkZD98ZG8/fHdbb3x3XT98WVlZWXxZWXxhfEF8aGg/fEhIP3xtbT98c3M/fFNTP1M/fHp6P3xaWj98WHxMVHxsbD9sP2w/fExMP0w/TD8pL2csXG4gICAgICAgICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICB5ZWFyOiBzZWxmLnllYXIoKSxcbiAgICAgICAgICAgICAgICBtb250aDogc2VsZi5tb250aCgpLFxuICAgICAgICAgICAgICAgIGhvdXI6IHNlbGYuaG91cnMoKSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IHNlbGYubWludXRlcygpLFxuICAgICAgICAgICAgICAgIHNlY29uZDogc2VsZi5zZWNvbmRzKCksXG4gICAgICAgICAgICAgICAgZGF0ZTogc2VsZi5kYXRlKCksXG4gICAgICAgICAgICAgICAgdGltZXpvbmU6IHNlbGYuem9uZSgpLFxuICAgICAgICAgICAgICAgIHVuaXg6IHNlbGYudW5peCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcm1hdFRvUGVyc2lhbiA9IHNlbGYuZm9ybWF0TnVtYmVyKCk7XG5cbiAgICAgICAgICAgIHZhciBjaGVja1BlcnNpYW4gPSBmdW5jdGlvbiBjaGVja1BlcnNpYW4oaSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXRUb1BlcnNpYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvUGVyc2lhbkRpZ2l0KGkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQU0vUE1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdFRvUGVyc2lhbikgcmV0dXJuIGluZm8uaG91ciA+PSAxMiA/ICfYqCDYuCcgOiAn2YIg2LgnO2Vsc2UgcmV0dXJuIGluZm8uaG91ciA+PSAxMiA/ICdQTScgOiAnQU0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBIb3VycyAoSW50KVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGluZm8uaG91cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0hIJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChpbmZvLmhvdXIsIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihpbmZvLmhvdXIgJSAxMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hoJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChpbmZvLmhvdXIgJSAxMiwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBNaW51dGVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4obGVmdFplcm9GaWxsKGluZm8ubWludXRlLCAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFR3byBEaWdpdCBNaW51dGVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21tJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChpbmZvLm1pbnV0ZSwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihpbmZvLnNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChpbmZvLnNlY29uZCwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBEYXkgKEludClcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoaW5mby5kYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBUd28gRGlnaXRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnREQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4obGVmdFplcm9GaWxsKGluZm8uZGF0ZSwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gZGF5IE9mIE1vbnRoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0RERCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBzZWxmLnN0YXJ0T2YoJ3llYXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGxlZnRaZXJvRmlsbChzZWxmLmRpZmYodCwgJ2RheXMnKSwgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gRGF5IG9mIFllYXJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRERERCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90ID0gc2VsZi5zdGFydE9mKCd5ZWFyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoc2VsZi5kaWZmKF90LCAnZGF5cycpLCAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBkYXkgT2Ygd2Vla1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKHNlbGYuY2FsZW5kYXIoKS53ZWVrZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHdlZWsgZGF5IG5hbWUgYWJiclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl93ZWVrTmFtZVNob3J0KHNlbGYuY2FsZW5kYXIoKS53ZWVrZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGRkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX3dlZWtOYW1lKHNlbGYuY2FsZW5kYXIoKS53ZWVrZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIFBlcnNpYW4gRGF5IE5hbWVcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGRkZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9kYXlOYW1lKHNlbGYuY2FsZW5kYXIoKS5kYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gUGVyc2lhbiBEYXkgTmFtZVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdkZGRkZGQnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl93ZWVrTmFtZU1pbihzZWxmLmNhbGVuZGFyKCkud2Vla2RheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBQZXJzaWFuIERheSBOYW1lXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3cnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfdDIgPSBzZWxmLnN0YXJ0T2YoJ3llYXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5ID0gcGFyc2VJbnQoc2VsZi5kaWZmKF90MiwgJ2RheXMnKSAvIDcpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKGRheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBQZXJzaWFuIERheSBOYW1lXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3d3JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3QzID0gc2VsZi5zdGFydE9mKCd5ZWFyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kYXkgPSBsZWZ0WmVyb0ZpbGwocGFyc2VJbnQoc2VsZi5kaWZmKF90MywgJ2RheXMnKSAvIDcpICsgMSwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihfZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gTW9udGggIChJbnQpXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4oaW5mby5tb250aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFR3byBEaWdpdCBNb250aCAoU3RyKVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbihsZWZ0WmVyb0ZpbGwoaW5mby5tb250aCwgMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBYmJyIFN0cmluZyBvZiBNb250aCAoU3RyKVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNTU0nOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLl9tb250aE5hbWVTaG9ydChpbmZvLm1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRnVsbCBTdHJpbmcgbmFtZSBvZiBNb250aCAoU3RyKVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdNTU1NJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbW9udGhOYW1lKGluZm8ubW9udGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBZZWFyXG4gICAgICAgICAgICAgICAgICAgIC8vIFR3byBEaWdpdCBZZWFyIChTdHIpXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lZJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeWVhckRpZ2l0QXJyYXkgPSBpbmZvLnllYXIudG9TdHJpbmcoKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUGVyc2lhbih5ZWFyRGlnaXRBcnJheVsyXSArIHllYXJEaWdpdEFycmF5WzNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRnVsbCBZZWFyIChJbnQpXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lZWVknOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1BlcnNpYW4oaW5mby55ZWFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsYWcgPSAnKycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5yb3VuZChpbmZvLnRpbWV6b25lIC8gNjApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzID0gaW5mby50aW1lem9uZSAlIDYwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbnV0ZXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob3VycyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZyA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG91cnMgKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHogPSBmbGFnICsgbGVmdFplcm9GaWxsKGhvdXJzLCAyKSArICc6JyArIGxlZnRaZXJvRmlsbChtaW51dGVzLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKHopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdaWic6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mbGFnID0gJysnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG91cnMgPSBNYXRoLnJvdW5kKGluZm8udGltZXpvbmUgLyA2MCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9taW51dGVzID0gaW5mby50aW1lem9uZSAlIDYwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9taW51dGVzIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbWludXRlcyAqPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9ob3VycyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZsYWcgPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3VycyAqPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF96ID0gX2ZsYWcgKyBsZWZ0WmVyb0ZpbGwoX2hvdXJzLCAyKSArICcnICsgbGVmdFplcm9GaWxsKF9taW51dGVzLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tQZXJzaWFuKF96KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYudW5peCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyA4OjMwIFBNXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0xUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ0g6bSBhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIDA5LzA0LzE5ODZcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0KCdZWVlZL01NL0REJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIDkvNC8xOTg2XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdCgnWVlZWS9NL0QnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VwdGVtYmVyIDR0aCAxOTg2XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0xMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ01NTU0gREQgWVlZWScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXAgNCAxOTg2XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ01NTSBERCBZWVlZJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vU2VwdGVtYmVyIDR0aCAxOTg2IDg6MzAgUE1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTExMJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ01NTU0gWVlZWSBERCAgIEg6bSAgYScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXAgNCAxOTg2IDg6MzAgUE1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGxsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXQoJ01NTSBZWVlZIEREICAgSDptICBhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vVGh1cnNkYXksIFNlcHRlbWJlciA0dGggMTk4NiA4OjMwIFBNXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0xMTEwnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdCgnZGRkZCBEIE1NTU0gWVlZWSAgSDptICBhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRodSwgU2VwIDQgMTk4NiA4OjMwIFBNXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xsbGwnOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZvcm1hdCgnZGRkIEQgTU1NIFlZWVkgIEg6bSAgYScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAgICAgICAgICAgaWYgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0U3RyaW5nLnJlcGxhY2UoZm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUZ1bmN0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9pbnB1dFN0cmluZyA9ICdZWVlZLU1NLUREIEhIOm1tOnNzIGEnO1xuICAgICAgICAgICAgICAgIHJldHVybiBfaW5wdXRTdHJpbmcucmVwbGFjZShmb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlRnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtQZXJzaWFuRGF0ZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdW5pdCA9IG5vcm1hbGl6ZUR1cmF0aW9uKGtleSwgdmFsdWUpLnVuaXQsXG4gICAgICAgICAgICAgICAgYXJyID0gdGhpcy50b0FycmF5KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vcm1hbGl6ZUR1cmF0aW9uKGtleSwgdmFsdWUpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVkRGF0ZSA9IGFyclsyXSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGhEYXlzID0gdGhpcy5kYXlzSW5Nb250aChhcnJbMF0gKyB2YWx1ZSwgYXJyWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJyWzJdID4gbW9udGhEYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWREYXRlID0gbW9udGhEYXlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGVtcERhdGUgPSBuZXcgUGVyc2lhbkRhdGVDbGFzcyhbYXJyWzBdICsgdmFsdWUsIGFyclsxXSwgbm9ybWFsaXplZERhdGUsIGFyclszXSwgYXJyWzRdLCBhcnJbNV0sIGFycls2XSwgYXJyWzddXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBEYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFllYXIgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTIpO1xuICAgICAgICAgICAgICAgIHZhciByZW1haW5pbmdNb250aCA9IHZhbHVlIC0gdGVtcFllYXIgKiAxMixcbiAgICAgICAgICAgICAgICAgICAgY2FsY2VkTW9udGggPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChhcnJbMV0gKyByZW1haW5pbmdNb250aCA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBZZWFyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNlZE1vbnRoID0gYXJyWzFdICsgcmVtYWluaW5nTW9udGggLSAxMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxjZWRNb250aCA9IGFyclsxXSArIHJlbWFpbmluZ01vbnRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXphZWREYXRlID0gYXJyWzJdLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wRGF0ZUFycmF5ID0gbmV3IFBlcnNpYW5EYXRlQ2xhc3MoW2FyclswXSArIHRlbXBZZWFyLCBjYWxjZWRNb250aCwgMSwgYXJyWzNdLCBhcnJbNF0sIGFycls1XSwgYXJyWzZdLCBhcnJbN11dKS50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgIF9tb250aERheXMgPSB0aGlzLmRheXNJbk1vbnRoKGFyclswXSArIHRlbXBZZWFyLCBjYWxjZWRNb250aCk7XG4gICAgICAgICAgICAgICAgaWYgKGFyclsyXSA+IF9tb250aERheXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXphZWREYXRlID0gX21vbnRoRGF5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaWFuRGF0ZUNsYXNzKFt0ZW1wRGF0ZUFycmF5WzBdLCB0ZW1wRGF0ZUFycmF5WzFdLCBub3JtYWxpemFlZERhdGUsIHRlbXBEYXRlQXJyYXlbM10sIHRlbXBEYXRlQXJyYXlbNF0sIHRlbXBEYXRlQXJyYXlbNV0sIHRlbXBEYXRlQXJyYXlbNl0sIHRlbXBEYXRlQXJyYXlbN11dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnZGF5Jykge1xuICAgICAgICAgICAgICAgIHZhciBjYWxjZWREYXkgPSBuZXcgUGVyc2lhbkRhdGVDbGFzcyh0aGlzLnZhbHVlT2YoKSkuaG91cigxMiksXG4gICAgICAgICAgICAgICAgICAgIG5ld01pbGxpc2Vjb25kID0gY2FsY2VkRGF5LnZhbHVlT2YoKSArIHZhbHVlICogODY0MDAwMDAsXG4gICAgICAgICAgICAgICAgICAgIG5ld0RhdGUgPSBuZXcgUGVyc2lhbkRhdGVDbGFzcyhuZXdNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0RhdGUuaG91cihhcnJbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgICAgIHZhciBfY2FsY2VkRGF5ID0gbmV3IFBlcnNpYW5EYXRlQ2xhc3ModGhpcy52YWx1ZU9mKCkpLmhvdXIoMTIpLFxuICAgICAgICAgICAgICAgICAgICBfbmV3TWlsbGlzZWNvbmQgPSBfY2FsY2VkRGF5LnZhbHVlT2YoKSArIDcgKiB2YWx1ZSAqIDg2NDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICBfbmV3RGF0ZSA9IG5ldyBQZXJzaWFuRGF0ZUNsYXNzKF9uZXdNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uZXdEYXRlLmhvdXIoYXJyWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgICAgICAgICB2YXIgX25ld01pbGxpc2Vjb25kMiA9IHRoaXMudmFsdWVPZigpICsgdmFsdWUgKiAzNjAwMDAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXgoX25ld01pbGxpc2Vjb25kMiAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdtaW51dGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9uZXdNaWxsaXNlY29uZDMgPSB0aGlzLnZhbHVlT2YoKSArIHZhbHVlICogNjAwMDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5peChfbmV3TWlsbGlzZWNvbmQzIC8gMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pdCA9PT0gJ3NlY29uZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX25ld01pbGxpc2Vjb25kNCA9IHRoaXMudmFsdWVPZigpICsgdmFsdWUgKiAxMDAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXgoX25ld01pbGxpc2Vjb25kNCAvIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgX25ld01pbGxpc2Vjb25kNSA9IHRoaXMudmFsdWVPZigpICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5peChfbmV3TWlsbGlzZWNvbmQ1IC8gMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3luY2VkQ2xhc3ModGhpcy52YWx1ZU9mKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAqIEByZXR1cm5zIHtQZXJzaWFuRGF0ZX1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N1YnRyYWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnRyYWN0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChrZXksIHZhbHVlICogLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrIGlmIGEgZGF0ZSBpcyBzYW1lIGFzIGJcbiAgICAgICAgICogQHBhcmFtIGRhdGVBXG4gICAgICAgICAqIEBwYXJhbSBkYXRlQlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNTYW1lRGF5JyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gZGF0ZUJcbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEByZXR1cm4ge1BlcnNpYW5EYXRlQ2xhc3N8Knxib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2FtZURheShkYXRlQikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMgJiYgZGF0ZUIgJiYgdGhpcy5kYXRlKCkgPT0gZGF0ZUIuZGF0ZSgpICYmIHRoaXMueWVhcigpID09IGRhdGVCLnllYXIoKSAmJiB0aGlzLm1vbnRoKCkgPT0gZGF0ZUIubW9udGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBjaGVjayBpZiBhIG1vbnRoIGlzIHNhbWUgYXMgYlxuICAgICAgICAgKiBAcGFyYW0ge0RhdGV9IGRhdGVBXG4gICAgICAgICAqIEBwYXJhbSB7RGF0ZX0gZGF0ZUJcbiAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICogQHNpbmNlIDEuMC4wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzU2FtZU1vbnRoJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBjaGVjayB0d28gZm9yIG1vbnRoIHNpbWlsYXJpdHlcbiAgICAgICAgICogQHBhcmFtIGRhdGVBXG4gICAgICAgICAqIEBwYXJhbSBkYXRlQlxuICAgICAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgICAgICogQHJldHVybiB7Knxib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2FtZU1vbnRoKGRhdGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcyAmJiBkYXRlQiAmJiB0aGlzLnllYXIoKSA9PSB0aGlzLnllYXIoKSAmJiB0aGlzLm1vbnRoKCkgPT0gZGF0ZUIubW9udGgoKTtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICdyYW5nZU5hbWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmFuZ2VOYW1lKCkge1xuICAgICAgICAgICAgdmFyIHAgPSBQZXJzaWFuRGF0ZUNsYXNzLFxuICAgICAgICAgICAgICAgIHQgPSBwLmNhbGVuZGFyVHlwZTtcbiAgICAgICAgICAgIGlmIChwLmxvY2FsVHlwZSA9PT0gJ2ZhJykge1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhLnBlcnNpYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhLmdyZWdvcmlhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ID09PSAncGVyc2lhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuLnBlcnNpYW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuLmdyZWdvcmlhbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvTGVhcFllYXJNb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvTGVhcFllYXJNb2RlKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgZCA9IFBlcnNpYW5EYXRlQ2xhc3M7XG4gICAgICAgICAgICBkLmxlYXBZZWFyTW9kZSA9IGlucHV0O1xuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RvQ2FsZW5kYXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9DYWxlbmRhcihpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGQgPSBQZXJzaWFuRGF0ZUNsYXNzO1xuICAgICAgICAgICAgZC5jYWxlbmRhclR5cGUgPSBpbnB1dDtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAgICAgKiBAcmV0dXJuIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndG9Mb2NhbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdG9Mb2NhbGUoaW5wdXQpIHtcbiAgICAgICAgICAgIHZhciBkID0gUGVyc2lhbkRhdGVDbGFzcztcbiAgICAgICAgICAgIGQubG9jYWxUeXBlID0gaW5wdXQ7XG4gICAgICAgICAgICBpZiAoZC5sb2NhbFR5cGUgIT09ICdmYScpIHtcbiAgICAgICAgICAgICAgICBkLmZvcm1hdFBlcnNpYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZC5mb3JtYXRQZXJzaWFuID0gJ19kZWZhdWx0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1BlcnNpYW5EYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGVyc2lhbkRhdGUob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUGVyc2lhbkRhdGVDbGFzcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHVyYXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEdXJhdGlvbihpbnB1dCwga2V5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNEdXJhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1bml4JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuaXgodGltZXN0YW1wKSB7XG4gICAgICAgICAgICBpZiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaWFuRGF0ZUNsYXNzKHRpbWVzdGFtcCAqIDEwMDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpYW5EYXRlQ2xhc3MoKS51bml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEZpcnN0V2Vla0RheU9mTW9udGgnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rmlyc3RXZWVrRGF5T2ZNb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzaWFuRGF0ZUNsYXNzKFt5ZWFyLCBtb250aCwgMV0pLmRheSgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1dGMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdXRjKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpYW5EYXRlQ2xhc3MoaW5wdXQpLnV0YygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBlcnNpYW5EYXRlQ2xhc3MoKS51dGMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNTYW1lRGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU2FtZURheShkYXRlQSwgZGF0ZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlQSAmJiBkYXRlQiAmJiBkYXRlQS5kYXRlKCkgPT0gZGF0ZUIuZGF0ZSgpICYmIGRhdGVBLnllYXIoKSA9PSBkYXRlQi55ZWFyKCkgJiYgZGF0ZUEubW9udGgoKSA9PSBkYXRlQi5tb250aCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1NhbWVNb250aCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NhbWVNb250aChkYXRlQSwgZGF0ZUIpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlQSAmJiBkYXRlQiAmJiBkYXRlQS55ZWFyKCkgPT0gZGF0ZUIueWVhcigpICYmIGRhdGVBLm1vbnRoKCkgPT0gZGF0ZUIubW9udGgoKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQZXJzaWFuRGF0ZUNsYXNzO1xufSgpO1xuXG4vKipcbiAqIEB0eXBlIHtQZXJzaWFuRGF0ZUNsYXNzfVxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJzaWFuRGF0ZUNsYXNzO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLy8gU3RhcnQgYWxnb3JpdGhtIGNsYXNzXG52YXIgQVNUUk8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIFN0YXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIEFsZ29yaXRobXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWxnb3JpdGhtcyhwYXJlbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFsZ29yaXRobXMpO1xuXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLkFTVFJPID0gbmV3IEFTVFJPKCk7XG4gICAgICAgIHRoaXMuU3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICAgICAgLyogIFlvdSBtYXkgbm90aWNlIHRoYXQgYSB2YXJpZXR5IG9mIGFycmF5IHZhcmlhYmxlcyBsb2dpY2FsbHkgbG9jYWxcbiAgICAgICAgIHRvIGZ1bmN0aW9ucyBhcmUgZGVjbGFyZWQgZ2xvYmFsbHkgaGVyZS4gIEluIEphdmFTY3JpcHQsIGNvbnN0cnVjdGlvblxuICAgICAgICAgb2YgYW4gYXJyYXkgdmFyaWFibGUgZnJvbSBzb3VyY2UgY29kZSBvY2N1cnMgYXMgdGhlIGNvZGUgaXNcbiAgICAgICAgIGludGVycHJldGVkLiAgTWFraW5nIHRoZXNlIHZhcmlhYmxlcyBwc2V1ZG8tZ2xvYmFscyBwZXJtaXRzIHVzXG4gICAgICAgICB0byBhdm9pZCBvdmVyaGVhZCBjb25zdHJ1Y3RpbmcgYW5kIGRpc3Bvc2luZyBvZiB0aGVtIGluIGVhY2hcbiAgICAgICAgIGNhbGwgb24gdGhlIGZ1bmN0aW9uIGluIHdoaWNoIHdoZXkgYXJlIHVzZWQuICAqL1xuICAgICAgICAvLyBUT0RPIHRoaXMgYmxvY2sgZGlkbnQgdXNlZCBpbiBtYWluIGFnb3JpdGhtXG4gICAgICAgIHRoaXMuSjAwMDAgPSAxNzIxNDI0LjU7IC8vIEp1bGlhbiBkYXRlIG9mIEdyZWdvcmlhbiBlcG9jaDogMDAwMC0wMS0wMVxuICAgICAgICB0aGlzLkoxOTcwID0gMjQ0MDU4Ny41OyAvLyBKdWxpYW4gZGF0ZSBhdCBVbml4IGVwb2NoOiAxOTcwLTAxLTAxXG4gICAgICAgIHRoaXMuSk1KRCA9IDI0MDAwMDAuNTsgLy8gRXBvY2ggb2YgTW9kaWZpZWQgSnVsaWFuIERhdGUgc3lzdGVtXG4gICAgICAgIHRoaXMuTm9ybUxlYXAgPSBbZmFsc2UgLypcIk5vcm1hbCB5ZWFyXCIqLywgdHJ1ZSAvKlwiTGVhcCB5ZWFyXCIqL107XG4gICAgICAgIC8vIFRPRE8gRU5EXG4gICAgICAgIHRoaXMuR1JFR09SSUFOX0VQT0NIID0gMTcyMTQyNS41O1xuICAgICAgICB0aGlzLlBFUlNJQU5fRVBPQ0ggPSAxOTQ4MzIwLjU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTEVBUF9HUkVHT1JJQU4gIC0tICBJcyBhIGdpdmVuIHllYXIgaW4gdGhlIEdyZWdvcmlhbiBjYWxlbmRhciBhIGxlYXAgeWVhciA/XG4gICAgICogQHBhcmFtIHllYXJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQWxnb3JpdGhtcywgW3tcbiAgICAgICAga2V5OiAnbGVhcF9ncmVnb3JpYW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVhcF9ncmVnb3JpYW4oeWVhcikge1xuICAgICAgICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICEoeWVhciAlIDEwMCA9PT0gMCAmJiB5ZWFyICUgNDAwICE9PSAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBEZXRlcm1pbmUgSnVsaWFuIGRheSBudW1iZXIgZnJvbSBHcmVnb3JpYW4gY2FsZW5kYXIgZGF0ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IHllYXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBtb250aFxuICAgICAgICAgKiBAcGFyYW0geyp9IGRheVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ3JlZ29yaWFuX3RvX2pkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdyZWdvcmlhbl90b19qZCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5HUkVHT1JJQU5fRVBPQ0ggLSAxICsgMzY1ICogKHllYXIgLSAxKSArIE1hdGguZmxvb3IoKHllYXIgLSAxKSAvIDQpICsgLU1hdGguZmxvb3IoKHllYXIgLSAxKSAvIDEwMCkgKyBNYXRoLmZsb29yKCh5ZWFyIC0gMSkgLyA0MDApICsgTWF0aC5mbG9vcigoMzY3ICogbW9udGggLSAzNjIpIC8gMTIgKyAobW9udGggPD0gMiA/IDAgOiB0aGlzLmxlYXBfZ3JlZ29yaWFuKHllYXIpID8gLTEgOiAtMikgKyBkYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZSBHcmVnb3JpYW4gY2FsZW5kYXIgZGF0ZSBmcm9tIEp1bGlhbiBkYXlcbiAgICAgICAgICogQHBhcmFtIHsqfSBqZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnamRfdG9fZ3JlZ29yaWFuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGpkX3RvX2dyZWdvcmlhbihqZCkge1xuICAgICAgICAgICAgdmFyIHdqZCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkZXBvY2ggPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgcXVhZHJpY2VudCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkcWMgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY2VudCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkY2VudCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBxdWFkID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRxdWFkID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHlpbmRleCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB5ZWFyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHllYXJkYXkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbGVhcGFkaiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBtb250aCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkYXkgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIHdqZCA9IE1hdGguZmxvb3IoamQgLSAwLjUpICsgMC41O1xuICAgICAgICAgICAgZGVwb2NoID0gd2pkIC0gdGhpcy5HUkVHT1JJQU5fRVBPQ0g7XG4gICAgICAgICAgICBxdWFkcmljZW50ID0gTWF0aC5mbG9vcihkZXBvY2ggLyAxNDYwOTcpO1xuICAgICAgICAgICAgZHFjID0gdGhpcy5BU1RSTy5tb2QoZGVwb2NoLCAxNDYwOTcpO1xuICAgICAgICAgICAgY2VudCA9IE1hdGguZmxvb3IoZHFjIC8gMzY1MjQpO1xuICAgICAgICAgICAgZGNlbnQgPSB0aGlzLkFTVFJPLm1vZChkcWMsIDM2NTI0KTtcbiAgICAgICAgICAgIHF1YWQgPSBNYXRoLmZsb29yKGRjZW50IC8gMTQ2MSk7XG4gICAgICAgICAgICBkcXVhZCA9IHRoaXMuQVNUUk8ubW9kKGRjZW50LCAxNDYxKTtcbiAgICAgICAgICAgIHlpbmRleCA9IE1hdGguZmxvb3IoZHF1YWQgLyAzNjUpO1xuICAgICAgICAgICAgeWVhciA9IHF1YWRyaWNlbnQgKiA0MDAgKyBjZW50ICogMTAwICsgcXVhZCAqIDQgKyB5aW5kZXg7XG4gICAgICAgICAgICBpZiAoIShjZW50ID09PSA0IHx8IHlpbmRleCA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICB5ZWFyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ZWFyZGF5ID0gd2pkIC0gdGhpcy5ncmVnb3JpYW5fdG9famQoeWVhciwgMSwgMSk7XG4gICAgICAgICAgICBsZWFwYWRqID0gd2pkIDwgdGhpcy5ncmVnb3JpYW5fdG9famQoeWVhciwgMywgMSkgPyAwIDogdGhpcy5sZWFwX2dyZWdvcmlhbih5ZWFyKSA/IDEgOiAyO1xuICAgICAgICAgICAgbW9udGggPSBNYXRoLmZsb29yKCgoeWVhcmRheSArIGxlYXBhZGopICogMTIgKyAzNzMpIC8gMzY3KTtcbiAgICAgICAgICAgIGRheSA9IHdqZCAtIHRoaXMuZ3JlZ29yaWFuX3RvX2pkKHllYXIsIG1vbnRoLCAxKSArIDE7XG5cbiAgICAgICAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsqfSB5ZWFyXG4gICAgICAgICAqL1xuICAgICAgICAvLyAgICBsZWFwX2p1bGlhbiAoeWVhcikge1xuICAgICAgICAvLyAgICAgICAgcmV0dXJuIHRoaXMuQVNUUk8ubW9kKHllYXIsIDQpID09PSAoKHllYXIgPiAwKSA/IDAgOiAzKTtcbiAgICAgICAgLy8gICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZSBKdWxpYW4gY2FsZW5kYXIgZGF0ZSBmcm9tIEp1bGlhbiBkYXlcbiAgICAgICAgICogQHBhcmFtIHsqfSB0ZFxuICAgICAgICAgKi9cbiAgICAgICAgLy8gICAgamRfdG9fanVsaWFuICh0ZCkge1xuICAgICAgICAvLyAgICAgICAgbGV0IHosIGEsIGIsIGMsIGQsIGUsIHllYXIsIG1vbnRoLCBkYXk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICB0ZCArPSAwLjU7XG4gICAgICAgIC8vICAgICAgICB6ID0gTWF0aC5mbG9vcih0ZCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgICBhID0gejtcbiAgICAgICAgLy8gICAgICAgIGIgPSBhICsgMTUyNDtcbiAgICAgICAgLy8gICAgICAgIGMgPSBNYXRoLmZsb29yKChiIC0gMTIyLjEpIC8gMzY1LjI1KTtcbiAgICAgICAgLy8gICAgICAgIGQgPSBNYXRoLmZsb29yKDM2NS4yNSAqIGMpO1xuICAgICAgICAvLyAgICAgICAgZSA9IE1hdGguZmxvb3IoKGIgLSBkKSAvIDMwLjYwMDEpO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgbW9udGggPSBNYXRoLmZsb29yKChlIDwgMTQpID8gKGUgLSAxKSA6IChlIC0gMTMpKTtcbiAgICAgICAgLy8gICAgICAgIHllYXIgPSBNYXRoLmZsb29yKChtb250aCA+IDIpID8gKGMgLSA0NzE2KSA6IChjIC0gNDcxNSkpO1xuICAgICAgICAvLyAgICAgICAgZGF5ID0gYiAtIGQgLSBNYXRoLmZsb29yKDMwLjYwMDEgKiBlKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgICAgIC8qICBJZiB5ZWFyIGlzIGxlc3MgdGhhbiAxLCBzdWJ0cmFjdCBvbmUgdG8gY29udmVydCBmcm9tXG4gICAgICAgIC8vICAgICAgICAgYSB6ZXJvIGJhc2VkIGRhdGUgc3lzdGVtIHRvIHRoZSBjb21tb24gZXJhIHN5c3RlbSBpblxuICAgICAgICAvLyAgICAgICAgIHdoaWNoIHRoZSB5ZWFyIC0xICgxIEIuQy5FKSBpcyBmb2xsb3dlZCBieSB5ZWFyIDEgKDEgQy5FLikuICAqL1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgaWYgKHllYXIgPCAxKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgeWVhci0tO1xuICAgICAgICAvLyAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5XTtcbiAgICAgICAgLy8gICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIFRFSFJBTl9FUVVJTk9YICAtLSAgRGV0ZXJtaW5lIEp1bGlhbiBkYXkgYW5kIGZyYWN0aW9uIG9mIHRoZVxuICAgICAgICAgTWFyY2ggZXF1aW5veCBhdCB0aGUgVGVocmFuIG1lcmlkaWFuIGluXG4gICAgICAgICBhIGdpdmVuIEdyZWdvcmlhbiB5ZWFyLlxuICAgICAgICAgKiBAcGFyYW0geyp9IHllYXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3RlaHJhbl9lcXVpbm94JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRlaHJhbl9lcXVpbm94KHllYXIpIHtcbiAgICAgICAgICAgIHZhciBlcXVKRUQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXF1SkQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXF1QVBQID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVxdVRlaHJhbiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkdFRlaHJhbiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgLy8gIE1hcmNoIGVxdWlub3ggaW4gZHluYW1pY2FsIHRpbWVcbiAgICAgICAgICAgIGVxdUpFRCA9IHRoaXMuQVNUUk8uZXF1aW5veCh5ZWFyLCAwKTtcblxuICAgICAgICAgICAgLy8gIENvcnJlY3QgZm9yIGRlbHRhIFQgdG8gb2J0YWluIFVuaXZlcnNhbCB0aW1lXG4gICAgICAgICAgICBlcXVKRCA9IGVxdUpFRCAtIHRoaXMuQVNUUk8uZGVsdGF0KHllYXIpIC8gKDI0ICogNjAgKiA2MCk7XG5cbiAgICAgICAgICAgIC8vICBBcHBseSB0aGUgZXF1YXRpb24gb2YgdGltZSB0byB5aWVsZCB0aGUgYXBwYXJlbnQgdGltZSBhdCBHcmVlbndpY2hcbiAgICAgICAgICAgIGVxdUFQUCA9IGVxdUpEICsgdGhpcy5BU1RSTy5lcXVhdGlvbk9mVGltZShlcXVKRUQpO1xuXG4gICAgICAgICAgICAvKiAgRmluYWxseSwgd2UgbXVzdCBjb3JyZWN0IGZvciB0aGUgY29uc3RhbnQgZGlmZmVyZW5jZSBiZXR3ZWVuXG4gICAgICAgICAgICAgdGhlIEdyZWVud2ljaCBtZXJpZGlhbiBhbmR0aGUgdGltZSB6b25lIHN0YW5kYXJkIGZvclxuICAgICAgICAgICAgIElyYW4gU3RhbmRhcmQgdGltZSwgNTLCsDMwJyB0byB0aGUgRWFzdC4gICovXG5cbiAgICAgICAgICAgIGR0VGVocmFuID0gKDUyICsgMzAgLyA2MC4wICsgMCAvICg2MC4wICogNjAuMCkpIC8gMzYwO1xuICAgICAgICAgICAgZXF1VGVocmFuID0gZXF1QVBQICsgZHRUZWhyYW47XG5cbiAgICAgICAgICAgIHJldHVybiBlcXVUZWhyYW47XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgVEVIUkFOX0VRVUlOT1hfSkQgIC0tICBDYWxjdWxhdGUgSnVsaWFuIGRheSBkdXJpbmcgd2hpY2ggdGhlXG4gICAgICAgICBNYXJjaCBlcXVpbm94LCByZWNrb25lZCBmcm9tIHRoZSBUZWhyYW5cbiAgICAgICAgIG1lcmlkaWFuLCBvY2N1cnJlZCBmb3IgYSBnaXZlbiBHcmVnb3JpYW5cbiAgICAgICAgIHllYXIuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0geWVhclxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndGVocmFuX2VxdWlub3hfamQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdGVocmFuX2VxdWlub3hfamQoeWVhcikge1xuICAgICAgICAgICAgdmFyIGVwID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVwZyA9IHZvaWQgMDtcblxuICAgICAgICAgICAgZXAgPSB0aGlzLnRlaHJhbl9lcXVpbm94KHllYXIpO1xuICAgICAgICAgICAgZXBnID0gTWF0aC5mbG9vcihlcCk7XG5cbiAgICAgICAgICAgIHJldHVybiBlcGc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgIFBFUlNJQU5BX1lFQVIgIC0tICBEZXRlcm1pbmUgdGhlIHllYXIgaW4gdGhlIFBlcnNpYW5cbiAgICAgICAgIGFzdHJvbm9taWNhbCBjYWxlbmRhciBpbiB3aGljaCBhXG4gICAgICAgICBnaXZlbiBKdWxpYW4gZGF5IGZhbGxzLiAgUmV0dXJucyBhblxuICAgICAgICAgYXJyYXkgb2YgdHdvIGVsZW1lbnRzOlxuICAgICAgICAgIFswXSAgUGVyc2lhbiB5ZWFyXG4gICAgICAgICBbMV0gIEp1bGlhbiBkYXkgbnVtYmVyIGNvbnRhaW5pbmdcbiAgICAgICAgIGVxdWlub3ggZm9yIHRoaXMgeWVhci5cbiAgICAgICAgICogQHBhcmFtIHsqfSBqZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGVyc2lhbmFfeWVhcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwZXJzaWFuYV95ZWFyKGpkKSB7XG4gICAgICAgICAgICB2YXIgZ3Vlc3MgPSB0aGlzLmpkX3RvX2dyZWdvcmlhbihqZClbMF0gLSAyLFxuICAgICAgICAgICAgICAgIGxhc3RlcSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBuZXh0ZXEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgYWRyID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBsYXN0ZXEgPSB0aGlzLnRlaHJhbl9lcXVpbm94X2pkKGd1ZXNzKTtcbiAgICAgICAgICAgIHdoaWxlIChsYXN0ZXEgPiBqZCkge1xuICAgICAgICAgICAgICAgIGd1ZXNzLS07XG4gICAgICAgICAgICAgICAgbGFzdGVxID0gdGhpcy50ZWhyYW5fZXF1aW5veF9qZChndWVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ZXEgPSBsYXN0ZXEgLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCEobGFzdGVxIDw9IGpkICYmIGpkIDwgbmV4dGVxKSkge1xuICAgICAgICAgICAgICAgIGxhc3RlcSA9IG5leHRlcTtcbiAgICAgICAgICAgICAgICBndWVzcysrO1xuICAgICAgICAgICAgICAgIG5leHRlcSA9IHRoaXMudGVocmFuX2VxdWlub3hfamQoZ3Vlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRyID0gTWF0aC5yb3VuZCgobGFzdGVxIC0gdGhpcy5QRVJTSUFOX0VQT0NIKSAvIHRoaXMuQVNUUk8uVHJvcGljYWxZZWFyKSArIDE7XG5cbiAgICAgICAgICAgIHJldHVybiBbYWRyLCBsYXN0ZXFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIENhbGN1bGF0ZSBkYXRlIGluIHRoZSBQZXJzaWFuIGFzdHJvbm9taWNhbFxuICAgICAgICAgY2FsZW5kYXIgZnJvbSBKdWxpYW4gZGF5LlxuICAgICAgICAgKiBAcGFyYW0geyp9IGpkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdqZF90b19wZXJzaWFuYScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBqZF90b19wZXJzaWFuYShqZCkge1xuICAgICAgICAgICAgdmFyIHllYXIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbW9udGggPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGF5ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGFkciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcXVpbm94ID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHlkYXkgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGpkID0gTWF0aC5mbG9vcihqZCkgKyAwLjU7XG4gICAgICAgICAgICBhZHIgPSB0aGlzLnBlcnNpYW5hX3llYXIoamQpO1xuICAgICAgICAgICAgeWVhciA9IGFkclswXTtcbiAgICAgICAgICAgIGVxdWlub3ggPSBhZHJbMV07XG4gICAgICAgICAgICBkYXkgPSBNYXRoLmZsb29yKChqZCAtIGVxdWlub3gpIC8gMzApICsgMTtcblxuICAgICAgICAgICAgeWRheSA9IE1hdGguZmxvb3IoamQpIC0gdGhpcy5wZXJzaWFuYV90b19qZCh5ZWFyLCAxLCAxKSArIDE7XG4gICAgICAgICAgICBtb250aCA9IHlkYXkgPD0gMTg2ID8gTWF0aC5jZWlsKHlkYXkgLyAzMSkgOiBNYXRoLmNlaWwoKHlkYXkgLSA2KSAvIDMwKTtcbiAgICAgICAgICAgIGRheSA9IE1hdGguZmxvb3IoamQpIC0gdGhpcy5wZXJzaWFuYV90b19qZCh5ZWFyLCBtb250aCwgMSkgKyAxO1xuXG4gICAgICAgICAgICByZXR1cm4gW3llYXIsIG1vbnRoLCBkYXldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIE9idGFpbiBKdWxpYW4gZGF5IGZyb20gYSBnaXZlbiBQZXJzaWFuXG4gICAgICAgICBhc3Ryb25vbWljYWwgY2FsZW5kYXIgZGF0ZS5cbiAgICAgICAgICogQHBhcmFtIHsqfSB5ZWFyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbW9udGhcbiAgICAgICAgICogQHBhcmFtIHsqfSBkYXlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BlcnNpYW5hX3RvX2pkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBlcnNpYW5hX3RvX2pkKHllYXIsIG1vbnRoLCBkYXkpIHtcbiAgICAgICAgICAgIHZhciBhZHIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXF1aW5veCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBndWVzcyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBqZCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgZ3Vlc3MgPSB0aGlzLlBFUlNJQU5fRVBPQ0ggLSAxICsgdGhpcy5BU1RSTy5Ucm9waWNhbFllYXIgKiAoeWVhciAtIDEgLSAxKTtcbiAgICAgICAgICAgIGFkciA9IFt5ZWFyIC0gMSwgMF07XG5cbiAgICAgICAgICAgIHdoaWxlIChhZHJbMF0gPCB5ZWFyKSB7XG4gICAgICAgICAgICAgICAgYWRyID0gdGhpcy5wZXJzaWFuYV95ZWFyKGd1ZXNzKTtcbiAgICAgICAgICAgICAgICBndWVzcyA9IGFkclsxXSArICh0aGlzLkFTVFJPLlRyb3BpY2FsWWVhciArIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXF1aW5veCA9IGFkclsxXTtcblxuICAgICAgICAgICAgamQgPSBlcXVpbm94ICsgKG1vbnRoIDw9IDcgPyAobW9udGggLSAxKSAqIDMxIDogKG1vbnRoIC0gMSkgKiAzMCArIDYpICsgKGRheSAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGpkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIElzIGEgZ2l2ZW4geWVhciBhIGxlYXAgeWVhciBpbiB0aGUgUGVyc2lhbiBhc3Ryb25vbWljYWwgY2FsZW5kYXIgP1xuICAgICAgICAgKiBAcGFyYW0geyp9IHllYXJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xlYXBfcGVyc2lhbmEnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVhcF9wZXJzaWFuYSh5ZWFyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJzaWFuYV90b19qZCh5ZWFyICsgMSwgMSwgMSkgLSB0aGlzLnBlcnNpYW5hX3RvX2pkKHllYXIsIDEsIDEpID4gMzY1O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIElzIGEgZ2l2ZW4geWVhciBhIGxlYXAgeWVhciBpbiB0aGUgUGVyc2lhbiBjYWxlbmRhciA/XG4gICAgICAgICAqIGFsc28gbmFzYSB1c2UgdGhpcyBhbGdvcml0aG0gaHR0cHM6Ly9lY2xpcHNlLmdzZmMubmFzYS5nb3YvU0tZQ0FML2FsZ29yaXRobS5qcyBzZWFyY2ggZm9yICdnZXRMYXN0RGF5T2ZQZXJzaWFuTW9udGgnIGFuZCB5b3UgY2FuIGZpbmQgaXRcbiAgICAgICAgICogQHBhcmFtIHsqfSB5ZWFyXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsZWFwX3BlcnNpYW4nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGVhcF9wZXJzaWFuKHllYXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKHllYXIgLSAoeWVhciA+IDAgPyA0NzQgOiA0NzMpKSAlIDI4MjAgKyA0NzQgKyAzOCkgKiA2ODIgJSAyODE2IDwgNjgyO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIERldGVybWluZSBKdWxpYW4gZGF5IGZyb20gUGVyc2lhbiBkYXRlXG4gICAgICAgICAqIEBwYXJhbSB7Kn0geWVhclxuICAgICAgICAgKiBAcGFyYW0geyp9IG1vbnRoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gZGF5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwZXJzaWFuX3RvX2pkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBlcnNpYW5fdG9famQoeWVhciwgbW9udGgsIGRheSkge1xuICAgICAgICAgICAgdmFyIGVwYmFzZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcHllYXIgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGVwYmFzZSA9IHllYXIgLSAoeWVhciA+PSAwID8gNDc0IDogNDczKTtcbiAgICAgICAgICAgIGVweWVhciA9IDQ3NCArIHRoaXMuQVNUUk8ubW9kKGVwYmFzZSwgMjgyMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBkYXkgKyAobW9udGggPD0gNyA/IChtb250aCAtIDEpICogMzEgOiAobW9udGggLSAxKSAqIDMwICsgNikgKyBNYXRoLmZsb29yKChlcHllYXIgKiA2ODIgLSAxMTApIC8gMjgxNikgKyAoZXB5ZWFyIC0gMSkgKiAzNjUgKyBNYXRoLmZsb29yKGVwYmFzZSAvIDI4MjApICogMTAyOTk4MyArICh0aGlzLlBFUlNJQU5fRVBPQ0ggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBDYWxjdWxhdGUgUGVyc2lhbiBkYXRlIGZyb20gSnVsaWFuIGRheVxuICAgICAgICAgKiBAcGFyYW0geyp9IGpkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdqZF90b19wZXJzaWFuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGpkX3RvX3BlcnNpYW4oamQpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIG1vbnRoID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRheSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBkZXBvY2ggPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY3ljbGUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgY3llYXIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgeWN5Y2xlID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGF1eDEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgYXV4MiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB5ZGF5ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBqZCA9IE1hdGguZmxvb3IoamQpICsgMC41O1xuXG4gICAgICAgICAgICBkZXBvY2ggPSBqZCAtIHRoaXMucGVyc2lhbl90b19qZCg0NzUsIDEsIDEpO1xuICAgICAgICAgICAgY3ljbGUgPSBNYXRoLmZsb29yKGRlcG9jaCAvIDEwMjk5ODMpO1xuICAgICAgICAgICAgY3llYXIgPSB0aGlzLkFTVFJPLm1vZChkZXBvY2gsIDEwMjk5ODMpO1xuICAgICAgICAgICAgaWYgKGN5ZWFyID09PSAxMDI5OTgyKSB7XG4gICAgICAgICAgICAgICAgeWN5Y2xlID0gMjgyMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXV4MSA9IE1hdGguZmxvb3IoY3llYXIgLyAzNjYpO1xuICAgICAgICAgICAgICAgIGF1eDIgPSB0aGlzLkFTVFJPLm1vZChjeWVhciwgMzY2KTtcbiAgICAgICAgICAgICAgICB5Y3ljbGUgPSBNYXRoLmZsb29yKCgyMTM0ICogYXV4MSArIDI4MTYgKiBhdXgyICsgMjgxNSkgLyAxMDI4NTIyKSArIGF1eDEgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWVhciA9IHljeWNsZSArIDI4MjAgKiBjeWNsZSArIDQ3NDtcbiAgICAgICAgICAgIGlmICh5ZWFyIDw9IDApIHtcbiAgICAgICAgICAgICAgICB5ZWFyLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5ZGF5ID0gamQgLSB0aGlzLnBlcnNpYW5fdG9famQoeWVhciwgMSwgMSkgKyAxO1xuICAgICAgICAgICAgbW9udGggPSB5ZGF5IDw9IDE4NiA/IE1hdGguY2VpbCh5ZGF5IC8gMzEpIDogTWF0aC5jZWlsKCh5ZGF5IC0gNikgLyAzMCk7XG4gICAgICAgICAgICBkYXkgPSBqZCAtIHRoaXMucGVyc2lhbl90b19qZCh5ZWFyLCBtb250aCwgMSkgKyAxO1xuICAgICAgICAgICAgcmV0dXJuIFt5ZWFyLCBtb250aCwgZGF5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0geyp9IHdlZWtkYXlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dXZWVrRGF5VG9QZXJzaWFuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdXZWVrRGF5VG9QZXJzaWFuKHdlZWtkYXkpIHtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5ICsgMiA9PT0gOCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5ICsgMiA9PT0gNykge1xuICAgICAgICAgICAgICAgIHJldHVybiA3O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2Vla2RheSArIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgdXBkYXRlRnJvbUdyZWdvcmlhbiAgLS0gIFVwZGF0ZSBhbGwgY2FsZW5kYXJzIGZyb20gR3JlZ29yaWFuLlxuICAgICAgICAgXCJXaHkgbm90IEp1bGlhbiBkYXRlP1wiIHlvdSBhc2suICBCZWNhdXNlXG4gICAgICAgICBzdGFydGluZyBmcm9tIEdyZWdvcmlhbiBndWFyYW50ZWVzIHdlJ3JlXG4gICAgICAgICBhbHJlYWR5IHNuYXBwZWQgdG8gYW4gaW50ZWdyYWwgc2Vjb25kLCBzb1xuICAgICAgICAgd2UgZG9uJ3QgZ2V0IHJvdW5kb2ZmIGVycm9ycyBpbiBvdGhlclxuICAgICAgICAgY2FsZW5kYXJzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndXBkYXRlRnJvbUdyZWdvcmlhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVGcm9tR3JlZ29yaWFuKCkge1xuICAgICAgICAgICAgdmFyIGogPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgeWVhciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBtb24gPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgbWRheSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBob3VyID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIG1pbiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBzZWMgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICB1dGltZSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBwZXJzY2FsID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB5ZWFyID0gdGhpcy5TdGF0ZS5ncmVnb3JpYW4ueWVhcjtcbiAgICAgICAgICAgIG1vbiA9IHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1vbnRoO1xuICAgICAgICAgICAgbWRheSA9IHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmRheTtcbiAgICAgICAgICAgIGhvdXIgPSAwOyAvL3RoaXMuU3RhdGUuZ3JlZ29yaWFuLmhvdXI7XG4gICAgICAgICAgICBtaW4gPSAwOyAvL3RoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbnV0ZTtcbiAgICAgICAgICAgIHNlYyA9IDA7IC8vdGhpcy5TdGF0ZS5ncmVnb3JpYW4uc2Vjb25kO1xuXG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdEYXRlID0gbmV3IERhdGUoeWVhciwgbW9uLCBtZGF5LCB0aGlzLlN0YXRlLmdyZWdvcmlhbi5ob3VyLCB0aGlzLlN0YXRlLmdyZWdvcmlhbi5taW51dGUsIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnNlY29uZCwgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWlsbGlzZWNvbmQpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuX3V0Y01vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS56b25lID0gdGhpcy5TdGF0ZS5nRGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGRlZCBmb3IgdGhpcyBhbGdvcml0aG1zIGNhbnQgcGFyc2UgMjAxNiwxMywzMiBzdWNjZXNzZnVsbHlcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnllYXIgPSB0aGlzLlN0YXRlLmdEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5tb250aCA9IHRoaXMuU3RhdGUuZ0RhdGUuZ2V0TW9udGgoKTtcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmRheSA9IHRoaXMuU3RhdGUuZ0RhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICAgICAgICAvLyAgVXBkYXRlIEp1bGlhbiBkYXlcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgaiA9IHRoaXMuZ3JlZ29yaWFuX3RvX2pkKHllYXIsIG1vbiArIDEsIG1kYXkpICsgTWF0aC5mbG9vcihzZWMgKyA2MCAqIChtaW4gKyA2MCAqIGhvdXIpICsgMC41KSAvIDg2NDAwLjA7XG5cbiAgICAgICAgICAgIHRoaXMuU3RhdGUuanVsaWFuZGF5ID0gajtcbiAgICAgICAgICAgIHRoaXMuU3RhdGUubW9kaWZpZWRqdWxpYW5kYXkgPSBqIC0gdGhpcy5KTUpEO1xuXG4gICAgICAgICAgICAvLyAgVXBkYXRlIGRheSBvZiB3ZWVrIGluIEdyZWdvcmlhbiBib3hcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgd2Vla2RheSA9IHRoaXMuQVNUUk8uandkYXkoaik7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIDEgaW5kZXhlZCBudW1iZXJcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLndlZWtkYXkgPSB3ZWVrZGF5ICsgMTtcblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBsZWFwIHllYXIgc3RhdHVzIGluIEdyZWdvcmlhbiBib3hcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubGVhcCA9IHRoaXMuTm9ybUxlYXBbdGhpcy5sZWFwX2dyZWdvcmlhbih5ZWFyKSA/IDEgOiAwXTtcblxuICAgICAgICAgICAgLy8gIFVwZGF0ZSBKdWxpYW4gQ2FsZW5kYXJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy8gICAgICAgIGp1bGNhbCA9IHRoaXMuamRfdG9fanVsaWFuKGopO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vICAgICAgICB0aGlzLlN0YXRlLmp1bGlhbmNhbGVuZGFyLnllYXIgPSBqdWxjYWxbMF07XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5qdWxpYW5jYWxlbmRhci5tb250aCA9IGp1bGNhbFsxXSAtIDE7XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5qdWxpYW5jYWxlbmRhci5kYXkgPSBqdWxjYWxbMl07XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5qdWxpYW5jYWxlbmRhci5sZWFwID0gdGhpcy5Ob3JtTGVhcFt0aGlzLmxlYXBfanVsaWFuKGp1bGNhbFswXSkgPyAxIDogMF07XG4gICAgICAgICAgICB3ZWVrZGF5ID0gdGhpcy5BU1RSTy5qd2RheShqKTtcbiAgICAgICAgICAgIC8vICAgICAgICB0aGlzLlN0YXRlLmp1bGlhbmNhbGVuZGFyLndlZWtkYXkgPSB3ZWVrZGF5O1xuXG4gICAgICAgICAgICAvLyAgVXBkYXRlIFBlcnNpYW4gQ2FsZW5kYXJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmNhbGVuZGFyVHlwZSA9PSAncGVyc2lhbicgJiYgdGhpcy5wYXJlbnQubGVhcFllYXJNb2RlID09ICdhbGdvcml0aG1pYycpIHtcbiAgICAgICAgICAgICAgICBwZXJzY2FsID0gdGhpcy5qZF90b19wZXJzaWFuKGopO1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbi55ZWFyID0gcGVyc2NhbFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW4ubW9udGggPSBwZXJzY2FsWzFdIC0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW4uZGF5ID0gcGVyc2NhbFsyXTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW4ud2Vla2RheSA9IHRoaXMuZ1dlZWtEYXlUb1BlcnNpYW4od2Vla2RheSk7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLmxlYXAgPSB0aGlzLk5vcm1MZWFwW3RoaXMubGVhcF9wZXJzaWFuKHBlcnNjYWxbMF0pID8gMSA6IDBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgVXBkYXRlIFBlcnNpYW4gQXN0cm9ub21pY2FsIENhbGVuZGFyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudC5jYWxlbmRhclR5cGUgPT0gJ3BlcnNpYW4nICYmIHRoaXMucGFyZW50LmxlYXBZZWFyTW9kZSA9PSAnYXN0cm9ub21pY2FsJykge1xuICAgICAgICAgICAgICAgIHBlcnNjYWwgPSB0aGlzLmpkX3RvX3BlcnNpYW5hKGopO1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbkFzdHJvLnllYXIgPSBwZXJzY2FsWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbkFzdHJvLm1vbnRoID0gcGVyc2NhbFsxXSAtIDE7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8uZGF5ID0gcGVyc2NhbFsyXTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby53ZWVrZGF5ID0gdGhpcy5nV2Vla0RheVRvUGVyc2lhbih3ZWVrZGF5KTtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby5sZWFwID0gdGhpcy5Ob3JtTGVhcFt0aGlzLmxlYXBfcGVyc2lhbmEocGVyc2NhbFswXSkgPyAxIDogMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAgVXBkYXRlIEdyZWdvcmlhbiBzZXJpYWwgbnVtYmVyXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIGlmICh0aGlzLlN0YXRlLmdyZWdzZXJpYWwuZGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnc2VyaWFsLmRheSA9IGogLSB0aGlzLkowMDAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAgVXBkYXRlIFVuaXggdGltZSgpXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIHV0aW1lID0gKGogLSB0aGlzLkoxOTcwKSAqICg2MCAqIDYwICogMjQgKiAxMDAwKTtcblxuICAgICAgICAgICAgdGhpcy5TdGF0ZS51bml4dGltZSA9IE1hdGgucm91bmQodXRpbWUgLyAxMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBQZXJmb3JtIGNhbGN1bGF0aW9uIHN0YXJ0aW5nIHdpdGggYSBHcmVnb3JpYW4gZGF0ZVxuICAgICAgICAgKiBAcGFyYW0geyp9IGRhdGVBcnJheVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2FsY0dyZWdvcmlhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjR3JlZ29yaWFuKGRhdGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVswXSB8fCBkYXRlQXJyYXlbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi55ZWFyID0gZGF0ZUFycmF5WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVsxXSB8fCBkYXRlQXJyYXlbMV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5tb250aCA9IGRhdGVBcnJheVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMl0gfHwgZGF0ZUFycmF5WzJdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uZGF5ID0gZGF0ZUFycmF5WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVszXSB8fCBkYXRlQXJyYXlbM10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5ob3VyID0gZGF0ZUFycmF5WzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVs0XSB8fCBkYXRlQXJyYXlbNF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5taW51dGUgPSBkYXRlQXJyYXlbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzVdIHx8IGRhdGVBcnJheVs1XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnNlY29uZCA9IGRhdGVBcnJheVs1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbNl0gfHwgZGF0ZUFycmF5WzZdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWlsbGlzZWNvbmQgPSBkYXRlQXJyYXlbNl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZyb21HcmVnb3JpYW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBQZXJmb3JtIGNhbGN1bGF0aW9uIHN0YXJ0aW5nIHdpdGggYSBKdWxpYW4gZGF0ZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2FsY0p1bGlhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjSnVsaWFuKCkge1xuICAgICAgICAgICAgdmFyIGogPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGF0ZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGogPSB0aGlzLlN0YXRlLmp1bGlhbmRheTtcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmpkX3RvX2dyZWdvcmlhbihqKTtcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnllYXIgPSBkYXRlWzBdO1xuICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubW9udGggPSBkYXRlWzFdIC0gMTtcbiAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLmRheSA9IGRhdGVbMl07XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uaG91ciA9IHRoaXMucGFkKHRpbWVbMF0sIDIsIFwiIFwiKTtcbiAgICAgICAgICAgIC8vICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5taW51dGUgPSB0aGlzLnBhZCh0aW1lWzFdLCAyLCBcIjBcIik7XG4gICAgICAgICAgICAvLyAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uc2Vjb25kID0gdGhpcy5wYWQodGltZVsyXSwgMiwgXCIwXCIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGcm9tR3JlZ29yaWFuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgU2V0IEp1bGlhbiBkYXRlIGFuZCB1cGRhdGUgYWxsIGNhbGVuZGFyc1xuICAgICAgICAgKiBAcGFyYW0geyp9IGpcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEp1bGlhbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRKdWxpYW4oaikge1xuICAgICAgICAgICAgdGhpcy5TdGF0ZS5qdWxpYW5kYXkgPSBqO1xuICAgICAgICAgICAgdGhpcy5jYWxjSnVsaWFuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgIFVwZGF0ZSBmcm9tIFBlcnNpYW4gY2FsZW5kYXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBkYXRlQXJyYXlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NhbGNQZXJzaWFuJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNQZXJzaWFuKGRhdGVBcnJheSkge1xuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVswXSB8fCBkYXRlQXJyYXlbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW4ueWVhciA9IGRhdGVBcnJheVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbMV0gfHwgZGF0ZUFycmF5WzFdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5wZXJzaWFuLm1vbnRoID0gZGF0ZUFycmF5WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVsyXSB8fCBkYXRlQXJyYXlbMl0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW4uZGF5ID0gZGF0ZUFycmF5WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVszXSB8fCBkYXRlQXJyYXlbM10gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5ob3VyID0gZGF0ZUFycmF5WzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVs0XSB8fCBkYXRlQXJyYXlbNF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5taW51dGUgPSBkYXRlQXJyYXlbNF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzVdIHx8IGRhdGVBcnJheVs1XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLnNlY29uZCA9IGRhdGVBcnJheVs1XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbNl0gfHwgZGF0ZUFycmF5WzZdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWlsbGlzZWNvbmQgPSBkYXRlQXJyYXlbNl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0SnVsaWFuKHRoaXMucGVyc2lhbl90b19qZCh0aGlzLlN0YXRlLnBlcnNpYW4ueWVhciwgdGhpcy5TdGF0ZS5wZXJzaWFuLm1vbnRoLCB0aGlzLlN0YXRlLnBlcnNpYW4uZGF5KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgVXBkYXRlIGZyb20gUGVyc2lhbiBhc3Ryb25vbWljYWwgY2FsZW5kYXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBkYXRlQXJyYXlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NhbGNQZXJzaWFuYScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjUGVyc2lhbmEoZGF0ZUFycmF5KSB7XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzBdIHx8IGRhdGVBcnJheVswXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbkFzdHJvLnllYXIgPSBkYXRlQXJyYXlbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzFdIHx8IGRhdGVBcnJheVsxXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUucGVyc2lhbkFzdHJvLm1vbnRoID0gZGF0ZUFycmF5WzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVsyXSB8fCBkYXRlQXJyYXlbMl0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby5kYXkgPSBkYXRlQXJyYXlbMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbM10gfHwgZGF0ZUFycmF5WzNdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4uaG91ciA9IGRhdGVBcnJheVszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlQXJyYXlbNF0gfHwgZGF0ZUFycmF5WzRdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5TdGF0ZS5ncmVnb3JpYW4ubWludXRlID0gZGF0ZUFycmF5WzRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVBcnJheVs1XSB8fCBkYXRlQXJyYXlbNV0gPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLlN0YXRlLmdyZWdvcmlhbi5zZWNvbmQgPSBkYXRlQXJyYXlbNV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUFycmF5WzZdIHx8IGRhdGVBcnJheVs2XSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuU3RhdGUuZ3JlZ29yaWFuLm1pbGxpc2Vjb25kID0gZGF0ZUFycmF5WzZdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRKdWxpYW4odGhpcy5wZXJzaWFuYV90b19qZCh0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby55ZWFyLCB0aGlzLlN0YXRlLnBlcnNpYW5Bc3Ryby5tb250aCwgdGhpcy5TdGF0ZS5wZXJzaWFuQXN0cm8uZGF5ICsgMC41KSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWxnb3JpdGhtcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGdvcml0aG1zO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbiBKYXZhU2NyaXB0IGZ1bmN0aW9ucyBmb3IgcG9zaXRpb25hbCBhc3Ryb25vbXlcbiBieSBKb2huIFdhbGtlciAgLS0gIFNlcHRlbWJlciwgTUlNXG4gaHR0cDovL3d3dy5mb3VybWlsYWIuY2gvXG4gVGhpcyBwcm9ncmFtIGlzIGluIHRoZSBwdWJsaWMgZG9tYWluLlxuICovXG5cbnZhciBBU1RSTyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBU1RSTygpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFTVFJPKTtcblxuICAgICAgICAvLyAgRnJlcXVlbnRseS11c2VkIGNvbnN0YW50c1xuICAgICAgICB0aGlzLkoyMDAwID0gMjQ1MTU0NS4wOyAvLyBKdWxpYW4gZGF5IG9mIEoyMDAwIGVwb2NoXG4gICAgICAgIHRoaXMuSnVsaWFuQ2VudHVyeSA9IDM2NTI1LjA7IC8vIERheXMgaW4gSnVsaWFuIGNlbnR1cnlcbiAgICAgICAgdGhpcy5KdWxpYW5NaWxsZW5uaXVtID0gdGhpcy5KdWxpYW5DZW50dXJ5ICogMTA7IC8vIERheXMgaW4gSnVsaWFuIG1pbGxlbm5pdW1cbiAgICAgICAgLy8gICAgICAgIHRoaXMuQXN0cm9ub21pY2FsVW5pdCA9IDE0OTU5Nzg3MC4wOyAgICAgICAgICAgLy8gQXN0cm9ub21pY2FsIHVuaXQgaW4ga2lsb21ldHJlc1xuICAgICAgICB0aGlzLlRyb3BpY2FsWWVhciA9IDM2NS4yNDIxOTg3ODsgLy8gTWVhbiBzb2xhciB0cm9waWNhbCB5ZWFyXG5cbiAgICAgICAgLyogIE9CTElRRVEgIC0tICBDYWxjdWxhdGUgdGhlIG9ibGlxdWl0eSBvZiB0aGUgZWNsaXB0aWMgZm9yIGEgZ2l2ZW5cbiAgICAgICAgIEp1bGlhbiBkYXRlLiAgVGhpcyB1c2VzIExhc2thcidzIHRlbnRoLWRlZ3JlZVxuICAgICAgICAgcG9seW5vbWlhbCBmaXQgKEouIExhc2thciwgQXN0cm9ub215IGFuZFxuICAgICAgICAgQXN0cm9waHlzaWNzLCBWb2wuIDE1NywgcGFnZSA2OCBbMTk4Nl0pIHdoaWNoIGlzXG4gICAgICAgICBhY2N1cmF0ZSB0byB3aXRoaW4gMC4wMSBhcmMgc2Vjb25kIGJldHdlZW4gQUQgMTAwMFxuICAgICAgICAgYW5kIEFEIDMwMDAsIGFuZCB3aXRoaW4gYSBmZXcgc2Vjb25kcyBvZiBhcmMgZm9yXG4gICAgICAgICArLy0xMDAwMCB5ZWFycyBhcm91bmQgQUQgMjAwMC4gIElmIHdlJ3JlIG91dHNpZGUgdGhlXG4gICAgICAgICByYW5nZSBpbiB3aGljaCB0aGlzIGZpdCBpcyB2YWxpZCAoZGVlcCB0aW1lKSB3ZVxuICAgICAgICAgc2ltcGx5IHJldHVybiB0aGUgSjIwMDAgdmFsdWUgb2YgdGhlIG9ibGlxdWl0eSwgd2hpY2hcbiAgICAgICAgIGhhcHBlbnMgdG8gYmUgYWxtb3N0IHByZWNpc2VseSB0aGUgbWVhbi4gICovXG4gICAgICAgIHRoaXMub3Rlcm1zID0gWy00NjgwLjkzLCAtMS41NSwgMTk5OS4yNSwgLTUxLjM4LCAtMjQ5LjY3LCAtMzkuMDUsIDcuMTIsIDI3Ljg3LCA1Ljc5LCAyLjQ1XTtcbiAgICAgICAgLyogUGVyaW9kaWMgdGVybXMgZm9yIG51dGF0aW9uIGluIGxvbmdpdWRlIChkZWx0YSBcXFBzaSkgYW5kXG4gICAgICAgICBvYmxpcXVpdHkgKGRlbHRhIFxcRXBzaWxvbikgYXMgZ2l2ZW4gaW4gdGFibGUgMjEuQSBvZlxuICAgICAgICAgTWVldXMsIFwiQXN0cm9ub21pY2FsIEFsZ29yaXRobXNcIiwgZmlyc3QgZWRpdGlvbi4gKi9cbiAgICAgICAgdGhpcy5udXRBcmdNdWx0ID0gWzAsIDAsIDAsIDAsIDEsIC0yLCAwLCAwLCAyLCAyLCAwLCAwLCAwLCAyLCAyLCAwLCAwLCAwLCAwLCAyLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAtMiwgMSwgMCwgMiwgMiwgMCwgMCwgMCwgMiwgMSwgMCwgMCwgMSwgMiwgMiwgLTIsIC0xLCAwLCAyLCAyLCAtMiwgMCwgMSwgMCwgMCwgLTIsIDAsIDAsIDIsIDEsIDAsIDAsIC0xLCAyLCAyLCAyLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAxLCAyLCAwLCAtMSwgMiwgMiwgMCwgMCwgLTEsIDAsIDEsIDAsIDAsIDEsIDIsIDEsIC0yLCAwLCAyLCAwLCAwLCAwLCAwLCAtMiwgMiwgMSwgMiwgMCwgMCwgMiwgMiwgMCwgMCwgMiwgMiwgMiwgMCwgMCwgMiwgMCwgMCwgLTIsIDAsIDEsIDIsIDIsIDAsIDAsIDAsIDIsIDAsIC0yLCAwLCAwLCAyLCAwLCAwLCAwLCAtMSwgMiwgMSwgMCwgMiwgMCwgMCwgMCwgMiwgMCwgLTEsIDAsIDEsIC0yLCAyLCAwLCAyLCAyLCAwLCAxLCAwLCAwLCAxLCAtMiwgMCwgMSwgMCwgMSwgMCwgLTEsIDAsIDAsIDEsIDAsIDAsIDIsIC0yLCAwLCAyLCAwLCAtMSwgMiwgMSwgMiwgMCwgMSwgMiwgMiwgMCwgMSwgMCwgMiwgMiwgLTIsIDEsIDEsIDAsIDAsIDAsIC0xLCAwLCAyLCAyLCAyLCAwLCAwLCAyLCAxLCAyLCAwLCAxLCAwLCAwLCAtMiwgMCwgMiwgMiwgMiwgLTIsIDAsIDEsIDIsIDEsIDIsIDAsIC0yLCAwLCAxLCAyLCAwLCAwLCAwLCAxLCAwLCAtMSwgMSwgMCwgMCwgLTIsIC0xLCAwLCAyLCAxLCAtMiwgMCwgMCwgMCwgMSwgMCwgMCwgMiwgMiwgMSwgLTIsIDAsIDIsIDAsIDEsIC0yLCAxLCAwLCAyLCAxLCAwLCAwLCAxLCAtMiwgMCwgLTEsIDAsIDEsIDAsIDAsIC0yLCAxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAyLCAwLCAtMSwgLTEsIDEsIDAsIDAsIDAsIDEsIDEsIDAsIDAsIDAsIC0xLCAxLCAyLCAyLCAyLCAtMSwgLTEsIDIsIDIsIDAsIDAsIC0yLCAyLCAyLCAwLCAwLCAzLCAyLCAyLCAyLCAtMSwgMCwgMiwgMl07XG5cbiAgICAgICAgdGhpcy5udXRBcmdDb2VmZiA9IFstMTcxOTk2LCAtMTc0MiwgOTIwOTUsIDg5LCAvKiAgMCwgIDAsICAwLCAgMCwgIDEgKi9cbiAgICAgICAgLTEzMTg3LCAtMTYsIDU3MzYsIC0zMSwgLyogLTIsICAwLCAgMCwgIDIsICAyICovXG4gICAgICAgIC0yMjc0LCAtMiwgOTc3LCAtNSwgLyogIDAsICAwLCAgMCwgIDIsICAyICovXG4gICAgICAgIDIwNjIsIDIsIC04OTUsIDUsIC8qICAwLCAgMCwgIDAsICAwLCAgMiAqL1xuICAgICAgICAxNDI2LCAtMzQsIDU0LCAtMSwgLyogIDAsICAxLCAgMCwgIDAsICAwICovXG4gICAgICAgIDcxMiwgMSwgLTcsIDAsIC8qICAwLCAgMCwgIDEsICAwLCAgMCAqL1xuICAgICAgICAtNTE3LCAxMiwgMjI0LCAtNiwgLyogLTIsICAxLCAgMCwgIDIsICAyICovXG4gICAgICAgIC0zODYsIC00LCAyMDAsIDAsIC8qICAwLCAgMCwgIDAsICAyLCAgMSAqL1xuICAgICAgICAtMzAxLCAwLCAxMjksIC0xLCAvKiAgMCwgIDAsICAxLCAgMiwgIDIgKi9cbiAgICAgICAgMjE3LCAtNSwgLTk1LCAzLCAvKiAtMiwgLTEsICAwLCAgMiwgIDIgKi9cbiAgICAgICAgLTE1OCwgMCwgMCwgMCwgLyogLTIsICAwLCAgMSwgIDAsICAwICovXG4gICAgICAgIDEyOSwgMSwgLTcwLCAwLCAvKiAtMiwgIDAsICAwLCAgMiwgIDEgKi9cbiAgICAgICAgMTIzLCAwLCAtNTMsIDAsIC8qICAwLCAgMCwgLTEsICAyLCAgMiAqL1xuICAgICAgICA2MywgMCwgMCwgMCwgLyogIDIsICAwLCAgMCwgIDAsICAwICovXG4gICAgICAgIDYzLCAxLCAtMzMsIDAsIC8qICAwLCAgMCwgIDEsICAwLCAgMSAqL1xuICAgICAgICAtNTksIDAsIDI2LCAwLCAvKiAgMiwgIDAsIC0xLCAgMiwgIDIgKi9cbiAgICAgICAgLTU4LCAtMSwgMzIsIDAsIC8qICAwLCAgMCwgLTEsICAwLCAgMSAqL1xuICAgICAgICAtNTEsIDAsIDI3LCAwLCAvKiAgMCwgIDAsICAxLCAgMiwgIDEgKi9cbiAgICAgICAgNDgsIDAsIDAsIDAsIC8qIC0yLCAgMCwgIDIsICAwLCAgMCAqL1xuICAgICAgICA0NiwgMCwgLTI0LCAwLCAvKiAgMCwgIDAsIC0yLCAgMiwgIDEgKi9cbiAgICAgICAgLTM4LCAwLCAxNiwgMCwgLyogIDIsICAwLCAgMCwgIDIsICAyICovXG4gICAgICAgIC0zMSwgMCwgMTMsIDAsIC8qICAwLCAgMCwgIDIsICAyLCAgMiAqL1xuICAgICAgICAyOSwgMCwgMCwgMCwgLyogIDAsICAwLCAgMiwgIDAsICAwICovXG4gICAgICAgIDI5LCAwLCAtMTIsIDAsIC8qIC0yLCAgMCwgIDEsICAyLCAgMiAqL1xuICAgICAgICAyNiwgMCwgMCwgMCwgLyogIDAsICAwLCAgMCwgIDIsICAwICovXG4gICAgICAgIC0yMiwgMCwgMCwgMCwgLyogLTIsICAwLCAgMCwgIDIsICAwICovXG4gICAgICAgIDIxLCAwLCAtMTAsIDAsIC8qICAwLCAgMCwgLTEsICAyLCAgMSAqL1xuICAgICAgICAxNywgLTEsIDAsIDAsIC8qICAwLCAgMiwgIDAsICAwLCAgMCAqL1xuICAgICAgICAxNiwgMCwgLTgsIDAsIC8qICAyLCAgMCwgLTEsICAwLCAgMSAqL1xuICAgICAgICAtMTYsIDEsIDcsIDAsIC8qIC0yLCAgMiwgIDAsICAyLCAgMiAqL1xuICAgICAgICAtMTUsIDAsIDksIDAsIC8qICAwLCAgMSwgIDAsICAwLCAgMSAqL1xuICAgICAgICAtMTMsIDAsIDcsIDAsIC8qIC0yLCAgMCwgIDEsICAwLCAgMSAqL1xuICAgICAgICAtMTIsIDAsIDYsIDAsIC8qICAwLCAtMSwgIDAsICAwLCAgMSAqL1xuICAgICAgICAxMSwgMCwgMCwgMCwgLyogIDAsICAwLCAgMiwgLTIsICAwICovXG4gICAgICAgIC0xMCwgMCwgNSwgMCwgLyogIDIsICAwLCAtMSwgIDIsICAxICovXG4gICAgICAgIC04LCAwLCAzLCAwLCAvKiAgMiwgIDAsICAxLCAgMiwgIDIgKi9cbiAgICAgICAgNywgMCwgLTMsIDAsIC8qICAwLCAgMSwgIDAsICAyLCAgMiAqL1xuICAgICAgICAtNywgMCwgMCwgMCwgLyogLTIsICAxLCAgMSwgIDAsICAwICovXG4gICAgICAgIC03LCAwLCAzLCAwLCAvKiAgMCwgLTEsICAwLCAgMiwgIDIgKi9cbiAgICAgICAgLTcsIDAsIDMsIDAsIC8qICAyLCAgMCwgIDAsICAyLCAgMSAqL1xuICAgICAgICA2LCAwLCAwLCAwLCAvKiAgMiwgIDAsICAxLCAgMCwgIDAgKi9cbiAgICAgICAgNiwgMCwgLTMsIDAsIC8qIC0yLCAgMCwgIDIsICAyLCAgMiAqL1xuICAgICAgICA2LCAwLCAtMywgMCwgLyogLTIsICAwLCAgMSwgIDIsICAxICovXG4gICAgICAgIC02LCAwLCAzLCAwLCAvKiAgMiwgIDAsIC0yLCAgMCwgIDEgKi9cbiAgICAgICAgLTYsIDAsIDMsIDAsIC8qICAyLCAgMCwgIDAsICAwLCAgMSAqL1xuICAgICAgICA1LCAwLCAwLCAwLCAvKiAgMCwgLTEsICAxLCAgMCwgIDAgKi9cbiAgICAgICAgLTUsIDAsIDMsIDAsIC8qIC0yLCAtMSwgIDAsICAyLCAgMSAqL1xuICAgICAgICAtNSwgMCwgMywgMCwgLyogLTIsICAwLCAgMCwgIDAsICAxICovXG4gICAgICAgIC01LCAwLCAzLCAwLCAvKiAgMCwgIDAsICAyLCAgMiwgIDEgKi9cbiAgICAgICAgNCwgMCwgMCwgMCwgLyogLTIsICAwLCAgMiwgIDAsICAxICovXG4gICAgICAgIDQsIDAsIDAsIDAsIC8qIC0yLCAgMSwgIDAsICAyLCAgMSAqL1xuICAgICAgICA0LCAwLCAwLCAwLCAvKiAgMCwgIDAsICAxLCAtMiwgIDAgKi9cbiAgICAgICAgLTQsIDAsIDAsIDAsIC8qIC0xLCAgMCwgIDEsICAwLCAgMCAqL1xuICAgICAgICAtNCwgMCwgMCwgMCwgLyogLTIsICAxLCAgMCwgIDAsICAwICovXG4gICAgICAgIC00LCAwLCAwLCAwLCAvKiAgMSwgIDAsICAwLCAgMCwgIDAgKi9cbiAgICAgICAgMywgMCwgMCwgMCwgLyogIDAsICAwLCAgMSwgIDIsICAwICovXG4gICAgICAgIC0zLCAwLCAwLCAwLCAvKiAtMSwgLTEsICAxLCAgMCwgIDAgKi9cbiAgICAgICAgLTMsIDAsIDAsIDAsIC8qICAwLCAgMSwgIDEsICAwLCAgMCAqL1xuICAgICAgICAtMywgMCwgMCwgMCwgLyogIDAsIC0xLCAgMSwgIDIsICAyICovXG4gICAgICAgIC0zLCAwLCAwLCAwLCAvKiAgMiwgLTEsIC0xLCAgMiwgIDIgKi9cbiAgICAgICAgLTMsIDAsIDAsIDAsIC8qICAwLCAgMCwgLTIsICAyLCAgMiAqL1xuICAgICAgICAtMywgMCwgMCwgMCwgLyogIDAsICAwLCAgMywgIDIsICAyICovXG4gICAgICAgIC0zLCAwLCAwLCAwIC8qICAyLCAtMSwgIDAsICAyLCAgMiAqL1xuICAgICAgICBdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBUYWJsZSBvZiBvYnNlcnZlZCBEZWx0YSBUIHZhbHVlcyBhdCB0aGUgYmVnaW5uaW5nIG9mIGV2ZW4gbnVtYmVyZWQgeWVhcnMgZnJvbSAxNjIwIHRocm91Z2ggMjAwMi5cbiAgICAgICAgICogQHR5cGUgQXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsdGFUdGFiID0gWzEyMSwgMTEyLCAxMDMsIDk1LCA4OCwgODIsIDc3LCA3MiwgNjgsIDYzLCA2MCwgNTYsIDUzLCA1MSwgNDgsIDQ2LCA0NCwgNDIsIDQwLCAzOCwgMzUsIDMzLCAzMSwgMjksIDI2LCAyNCwgMjIsIDIwLCAxOCwgMTYsIDE0LCAxMiwgMTEsIDEwLCA5LCA4LCA3LCA3LCA3LCA3LCA3LCA3LCA4LCA4LCA5LCA5LCA5LCA5LCA5LCAxMCwgMTAsIDEwLCAxMCwgMTAsIDEwLCAxMCwgMTAsIDExLCAxMSwgMTEsIDExLCAxMSwgMTIsIDEyLCAxMiwgMTIsIDEzLCAxMywgMTMsIDE0LCAxNCwgMTQsIDE0LCAxNSwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTUsIDE1LCAxNCwgMTMsIDEzLjEsIDEyLjUsIDEyLjIsIDEyLCAxMiwgMTIsIDEyLCAxMiwgMTIsIDExLjksIDExLjYsIDExLCAxMC4yLCA5LjIsIDguMiwgNy4xLCA2LjIsIDUuNiwgNS40LCA1LjMsIDUuNCwgNS42LCA1LjksIDYuMiwgNi41LCA2LjgsIDcuMSwgNy4zLCA3LjUsIDcuNiwgNy43LCA3LjMsIDYuMiwgNS4yLCAyLjcsIDEuNCwgLTEuMiwgLTIuOCwgLTMuOCwgLTQuOCwgLTUuNSwgLTUuMywgLTUuNiwgLTUuNywgLTUuOSwgLTYsIC02LjMsIC02LjUsIC02LjIsIC00LjcsIC0yLjgsIC0wLjEsIDIuNiwgNS4zLCA3LjcsIDEwLjQsIDEzLjMsIDE2LCAxOC4yLCAyMC4yLCAyMS4xLCAyMi40LCAyMy41LCAyMy44LCAyNC4zLCAyNCwgMjMuOSwgMjMuOSwgMjMuNywgMjQsIDI0LjMsIDI1LjMsIDI2LjIsIDI3LjMsIDI4LjIsIDI5LjEsIDMwLCAzMC43LCAzMS40LCAzMi4yLCAzMy4xLCAzNCwgMzUsIDM2LjUsIDM4LjMsIDQwLjIsIDQyLjIsIDQ0LjUsIDQ2LjUsIDQ4LjUsIDUwLjUsIDUyLjIsIDUzLjgsIDU0LjksIDU1LjgsIDU2LjksIDU4LjMsIDYwLCA2MS42LCA2MywgNjUsIDY2LjZdO1xuXG4gICAgICAgIC8qICBFUVVJTk9YICAtLSAgRGV0ZXJtaW5lIHRoZSBKdWxpYW4gRXBoZW1lcmlzIERheSBvZiBhblxuICAgICAgICAgZXF1aW5veCBvciBzb2xzdGljZS4gIFRoZSBcIndoaWNoXCIgYXJndW1lbnRcbiAgICAgICAgIHNlbGVjdHMgdGhlIGl0ZW0gdG8gYmUgY29tcHV0ZWQ6XG4gICAgICAgICAgMCAgIE1hcmNoIGVxdWlub3hcbiAgICAgICAgIDEgICBKdW5lIHNvbHN0aWNlXG4gICAgICAgICAyICAgU2VwdGVtYmVyIGVxdWlub3hcbiAgICAgICAgIDMgICBEZWNlbWJlciBzb2xzdGljZVxuICAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBQZXJpb2RpYyB0ZXJtcyB0byBvYnRhaW4gdHJ1ZSB0aW1lXG4gICAgICAgICAqIEB0eXBlIEFycmF5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLkVxdWlub3hwVGVybXMgPSBbNDg1LCAzMjQuOTYsIDE5MzQuMTM2LCAyMDMsIDMzNy4yMywgMzI5NjQuNDY3LCAxOTksIDM0Mi4wOCwgMjAuMTg2LCAxODIsIDI3Ljg1LCA0NDUyNjcuMTEyLCAxNTYsIDczLjE0LCA0NTAzNi44ODYsIDEzNiwgMTcxLjUyLCAyMjUxOC40NDMsIDc3LCAyMjIuNTQsIDY1OTI4LjkzNCwgNzQsIDI5Ni43MiwgMzAzNC45MDYsIDcwLCAyNDMuNTgsIDkwMzcuNTEzLCA1OCwgMTE5LjgxLCAzMzcxOC4xNDcsIDUyLCAyOTcuMTcsIDE1MC42NzgsIDUwLCAyMS4wMiwgMjI4MS4yMjYsIDQ1LCAyNDcuNTQsIDI5OTI5LjU2MiwgNDQsIDMyNS4xNSwgMzE1NTUuOTU2LCAyOSwgNjAuOTMsIDQ0NDMuNDE3LCAxOCwgMTU1LjEyLCA2NzU1NS4zMjgsIDE3LCAyODguNzksIDQ1NjIuNDUyLCAxNiwgMTk4LjA0LCA2Mjg5NC4wMjksIDE0LCAxOTkuNzYsIDMxNDM2LjkyMSwgMTIsIDk1LjM5LCAxNDU3Ny44NDgsIDEyLCAyODcuMTEsIDMxOTMxLjc1NiwgMTIsIDMyMC44MSwgMzQ3NzcuMjU5LCA5LCAyMjcuNzMsIDEyMjIuMTE0LCA4LCAxNS40NSwgMTY4NTkuMDc0XTtcblxuICAgICAgICB0aGlzLkpERTB0YWIxMDAwID0gW25ldyBBcnJheSgxNzIxMTM5LjI5MTg5LCAzNjUyNDIuMTM3NDAsIDAuMDYxMzQsIDAuMDAxMTEsIC0wLjAwMDcxKSwgbmV3IEFycmF5KDE3MjEyMzMuMjU0MDEsIDM2NTI0MS43MjU2MiwgLTAuMDUzMjMsIDAuMDA5MDcsIDAuMDAwMjUpLCBuZXcgQXJyYXkoMTcyMTMyNS43MDQ1NSwgMzY1MjQyLjQ5NTU4LCAtMC4xMTY3NywgLTAuMDAyOTcsIDAuMDAwNzQpLCBuZXcgQXJyYXkoMTcyMTQxNC4zOTk4NywgMzY1MjQyLjg4MjU3LCAtMC4wMDc2OSwgLTAuMDA5MzMsIC0wLjAwMDA2KV07XG5cbiAgICAgICAgdGhpcy5KREUwdGFiMjAwMCA9IFtuZXcgQXJyYXkoMjQ1MTYyMy44MDk4NCwgMzY1MjQyLjM3NDA0LCAwLjA1MTY5LCAtMC4wMDQxMSwgLTAuMDAwNTcpLCBuZXcgQXJyYXkoMjQ1MTcxNi41Njc2NywgMzY1MjQxLjYyNjAzLCAwLjAwMzI1LCAwLjAwODg4LCAtMC4wMDAzMCksIG5ldyBBcnJheSgyNDUxODEwLjIxNzE1LCAzNjUyNDIuMDE3NjcsIC0wLjExNTc1LCAwLjAwMzM3LCAwLjAwMDc4KSwgbmV3IEFycmF5KDI0NTE5MDAuMDU5NTIsIDM2NTI0Mi43NDA0OSwgLTAuMDYyMjMsIC0wLjAwODIzLCAwLjAwMDMyKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gRGVncmVlcyB0byByYWRpYW5zLlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEFTVFJPLCBbe1xuICAgICAgICBrZXk6IFwiZHRyXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkdHIoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGQgKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgUmFkaWFucyB0byBkZWdyZWVzLlxuICAgICAgICAgKiBAcGFyYW0gclxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicnRkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBydGQocikge1xuICAgICAgICAgICAgcmV0dXJuIHIgKiAxODAuMCAvIE1hdGguUEk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgUmFuZ2UgcmVkdWNlIGFuZ2xlIGluIGRlZ3JlZXMuXG4gICAgICAgICAqIEBwYXJhbSBhXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJmaXhhbmdsZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZml4YW5nbGUoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSAzNjAuMCAqIE1hdGguZmxvb3IoYSAvIDM2MC4wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBSYW5nZSByZWR1Y2UgYW5nbGUgaW4gcmFkaWFucy5cbiAgICAgICAgICogQHBhcmFtIGFcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImZpeGFuZ3JcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpeGFuZ3IoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSAyICogTWF0aC5QSSAqIE1hdGguZmxvb3IoYSAvICgyICogTWF0aC5QSSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjICBTaW5lIG9mIGFuIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgICAgICogQHBhcmFtIGRcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRzaW5cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRzaW4oZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKHRoaXMuZHRyKGQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyBDb3NpbmUgb2YgYW4gYW5nbGUgaW4gZGVncmVlc1xuICAgICAgICAgKiBAcGFyYW0gZFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGNvc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGNvcyhkKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jb3ModGhpcy5kdHIoZCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjIE1vZHVsdXMgZnVuY3Rpb24gd2hpY2ggd29ya3MgZm9yIG5vbi1pbnRlZ2Vycy5cbiAgICAgICAgICogQHBhcmFtIGFcbiAgICAgICAgICogQHBhcmFtIGJcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIm1vZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYiAqIE1hdGguZmxvb3IoYSAvIGIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBqXG4gICAgICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJqd2RheVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gandkYXkoaikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kKE1hdGguZmxvb3IoaiArIDEuNSksIDcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBqZFxuICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ8Kn1cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJvYmxpcWVxXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvYmxpcWVxKGpkKSB7XG4gICAgICAgICAgICB2YXIgZXBzLCB1LCB2LCBpO1xuICAgICAgICAgICAgdiA9IHUgPSAoamQgLSB0aGlzLkoyMDAwKSAvICh0aGlzLkp1bGlhbkNlbnR1cnkgKiAxMDApO1xuICAgICAgICAgICAgZXBzID0gMjMgKyAyNiAvIDYwLjAgKyAyMS40NDggLyAzNjAwLjA7XG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh1KSA8IDEuMCkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVwcyArPSB0aGlzLm90ZXJtc1tpXSAvIDM2MDAuMCAqIHY7XG4gICAgICAgICAgICAgICAgICAgIHYgKj0gdTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXBzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjICBDYWxjdWxhdGUgdGhlIG51dGF0aW9uIGluIGxvbmdpdHVkZSwgZGVsdGFQc2ksIGFuZFxuICAgICAgICAgb2JsaXF1aXR5LCBkZWx0YUVwc2lsb24gZm9yIGEgZ2l2ZW4gSnVsaWFuIGRhdGVcbiAgICAgICAgIGpkLiAgUmVzdWx0cyBhcmUgcmV0dXJuZWQgYXMgYSB0d28gZWxlbWVudCBBcnJheVxuICAgICAgICAgZ2l2aW5nIChkZWx0YVBzaSwgZGVsdGFFcHNpbG9uKSBpbiBkZWdyZWVzLlxuICAgICAgICAgKiBAcGFyYW0gamRcbiAgICAgICAgICogQHJldHVybiBPYmplY3RcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJudXRhdGlvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbnV0YXRpb24oamQpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVBzaSxcbiAgICAgICAgICAgICAgICBkZWx0YUVwc2lsb24sXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHQgPSAoamQgLSAyNDUxNTQ1LjApIC8gMzY1MjUuMCxcbiAgICAgICAgICAgICAgICB0MixcbiAgICAgICAgICAgICAgICB0MyxcbiAgICAgICAgICAgICAgICB0bzEwLFxuICAgICAgICAgICAgICAgIHRhID0gW10sXG4gICAgICAgICAgICAgICAgZHAgPSAwLFxuICAgICAgICAgICAgICAgIGRlID0gMCxcbiAgICAgICAgICAgICAgICBhbmc7XG5cbiAgICAgICAgICAgIHQzID0gdCAqICh0MiA9IHQgKiB0KTtcblxuICAgICAgICAgICAgLyogQ2FsY3VsYXRlIGFuZ2xlcy4gIFRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHRoZSBlbGVtZW50c1xuICAgICAgICAgICAgIG9mIG91ciBhcnJheSBhbmQgdGhlIHRlcm1zIGNpdGVkIGluIE1lZXVzIGFyZTpcbiAgICAgICAgICAgICAgdGFbMF0gPSBEICB0YVswXSA9IE0gIHRhWzJdID0gTScgIHRhWzNdID0gRiAgdGFbNF0gPSBcXE9tZWdhXG4gICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIHRhWzBdID0gdGhpcy5kdHIoMjk3Ljg1MDM2MyArIDQ0NTI2Ny4xMTE0OCAqIHQgLSAwLjAwMTkxNDIgKiB0MiArIHQzIC8gMTg5NDc0LjApO1xuICAgICAgICAgICAgdGFbMV0gPSB0aGlzLmR0cigzNTcuNTI3NzIgKyAzNTk5OS4wNTAzNCAqIHQgLSAwLjAwMDE2MDMgKiB0MiAtIHQzIC8gMzAwMDAwLjApO1xuICAgICAgICAgICAgdGFbMl0gPSB0aGlzLmR0cigxMzQuOTYyOTggKyA0NzcxOTguODY3Mzk4ICogdCArIDAuMDA4Njk3MiAqIHQyICsgdDMgLyA1NjI1MC4wKTtcbiAgICAgICAgICAgIHRhWzNdID0gdGhpcy5kdHIoOTMuMjcxOTEgKyA0ODMyMDIuMDE3NTM4ICogdCAtIDAuMDAzNjgyNSAqIHQyICsgdDMgLyAzMjcyNzApO1xuICAgICAgICAgICAgdGFbNF0gPSB0aGlzLmR0cigxMjUuMDQ0NTIgLSAxOTM0LjEzNjI2MSAqIHQgKyAwLjAwMjA3MDggKiB0MiArIHQzIC8gNDUwMDAwLjApO1xuXG4gICAgICAgICAgICAvKiBSYW5nZSByZWR1Y2UgdGhlIGFuZ2xlcyBpbiBjYXNlIHRoZSBzaW5lIGFuZCBjb3NpbmUgZnVuY3Rpb25zXG4gICAgICAgICAgICAgZG9uJ3QgZG8gaXQgYXMgYWNjdXJhdGVseSBvciBxdWlja2x5LiAqL1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGFbaV0gPSB0aGlzLmZpeGFuZ3IodGFbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bzEwID0gdCAvIDEwLjA7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjM7IGkrKykge1xuICAgICAgICAgICAgICAgIGFuZyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5udXRBcmdNdWx0W2kgKiA1ICsgal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZyArPSB0aGlzLm51dEFyZ011bHRbaSAqIDUgKyBqXSAqIHRhW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRwICs9ICh0aGlzLm51dEFyZ0NvZWZmW2kgKiA0ICsgMF0gKyB0aGlzLm51dEFyZ0NvZWZmW2kgKiA0ICsgMV0gKiB0bzEwKSAqIE1hdGguc2luKGFuZyk7XG4gICAgICAgICAgICAgICAgZGUgKz0gKHRoaXMubnV0QXJnQ29lZmZbaSAqIDQgKyAyXSArIHRoaXMubnV0QXJnQ29lZmZbaSAqIDQgKyAzXSAqIHRvMTApICogTWF0aC5jb3MoYW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogUmV0dXJuIHRoZSByZXN1bHQsIGNvbnZlcnRpbmcgZnJvbSB0ZW4gdGhvdXNhbmR0aHMgb2YgYXJjXG4gICAgICAgICAgICAgc2Vjb25kcyB0byByYWRpYW5zIGluIHRoZSBwcm9jZXNzLiAqL1xuXG4gICAgICAgICAgICBkZWx0YVBzaSA9IGRwIC8gKDM2MDAuMCAqIDEwMDAwLjApO1xuICAgICAgICAgICAgZGVsdGFFcHNpbG9uID0gZGUgLyAoMzYwMC4wICogMTAwMDAuMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbZGVsdGFQc2ksIGRlbHRhRXBzaWxvbl07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgIERldGVybWluZSB0aGUgZGlmZmVyZW5jZSwgaW4gc2Vjb25kcywgYmV0d2VlblxuICAgICAgICAgRHluYW1pY2FsIHRpbWUgYW5kIFVuaXZlcnNhbCB0aW1lLlxuICAgICAgICAgKiBAcGFyYW0geWVhclxuICAgICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImRlbHRhdFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsdGF0KHllYXIpIHtcbiAgICAgICAgICAgIHZhciBkdCwgZiwgaSwgdDtcblxuICAgICAgICAgICAgaWYgKHllYXIgPj0gMTYyMCAmJiB5ZWFyIDw9IDIwMDApIHtcbiAgICAgICAgICAgICAgICBpID0gTWF0aC5mbG9vcigoeWVhciAtIDE2MjApIC8gMik7XG4gICAgICAgICAgICAgICAgZiA9ICh5ZWFyIC0gMTYyMCkgLyAyIC0gaTtcbiAgICAgICAgICAgICAgICAvKiBGcmFjdGlvbmFsIHBhcnQgb2YgeWVhciAqL1xuICAgICAgICAgICAgICAgIGR0ID0gdGhpcy5kZWx0YVR0YWJbaV0gKyAodGhpcy5kZWx0YVR0YWJbaSArIDFdIC0gdGhpcy5kZWx0YVR0YWJbaV0pICogZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdCA9ICh5ZWFyIC0gMjAwMCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgaWYgKHllYXIgPCA5NDgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHQgPSAyMTc3ICsgNDk3ICogdCArIDQ0LjEgKiB0ICogdDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkdCA9IDEwMiArIDEwMiAqIHQgKyAyNS4zICogdCAqIHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ZWFyID4gMjAwMCAmJiB5ZWFyIDwgMjEwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHQgKz0gMC4zNyAqICh5ZWFyIC0gMjEwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHllYXJcbiAgICAgICAgICogQHBhcmFtIHdoaWNoXG4gICAgICAgICAqIEByZXR1cm4geyp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZXF1aW5veFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXF1aW5veCh5ZWFyLCB3aGljaCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhTCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBpID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGogPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgSkRFMCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBKREUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgSkRFMHRhYiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBTID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIFQgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgVyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBZID0gdm9pZCAwO1xuICAgICAgICAgICAgLyogIEluaXRpYWxpc2UgdGVybXMgZm9yIG1lYW4gZXF1aW5veCBhbmQgc29sc3RpY2VzLiAgV2VcbiAgICAgICAgICAgICBoYXZlIHR3byBzZXRzOiBvbmUgZm9yIHllYXJzIHByaW9yIHRvIDEwMDAgYW5kIGEgc2Vjb25kXG4gICAgICAgICAgICAgZm9yIHN1YnNlcXVlbnQgeWVhcnMuICAqL1xuXG4gICAgICAgICAgICBpZiAoeWVhciA8IDEwMDApIHtcbiAgICAgICAgICAgICAgICBKREUwdGFiID0gdGhpcy5KREUwdGFiMTAwMDtcbiAgICAgICAgICAgICAgICBZID0geWVhciAvIDEwMDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEpERTB0YWIgPSB0aGlzLkpERTB0YWIyMDAwO1xuICAgICAgICAgICAgICAgIFkgPSAoeWVhciAtIDIwMDApIC8gMTAwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSkRFMCA9IEpERTB0YWJbd2hpY2hdWzBdICsgSkRFMHRhYlt3aGljaF1bMV0gKiBZICsgSkRFMHRhYlt3aGljaF1bMl0gKiBZICogWSArIEpERTB0YWJbd2hpY2hdWzNdICogWSAqIFkgKiBZICsgSkRFMHRhYlt3aGljaF1bNF0gKiBZICogWSAqIFkgKiBZO1xuICAgICAgICAgICAgVCA9IChKREUwIC0gMjQ1MTU0NS4wKSAvIDM2NTI1O1xuICAgICAgICAgICAgVyA9IDM1OTk5LjM3MyAqIFQgLSAyLjQ3O1xuICAgICAgICAgICAgZGVsdGFMID0gMSArIDAuMDMzNCAqIHRoaXMuZGNvcyhXKSArIDAuMDAwNyAqIHRoaXMuZGNvcygyICogVyk7XG4gICAgICAgICAgICBTID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IGogPSAwOyBpIDwgMjQ7IGkrKykge1xuICAgICAgICAgICAgICAgIFMgKz0gdGhpcy5FcXVpbm94cFRlcm1zW2pdICogdGhpcy5kY29zKHRoaXMuRXF1aW5veHBUZXJtc1tqICsgMV0gKyB0aGlzLkVxdWlub3hwVGVybXNbaiArIDJdICogVCk7XG4gICAgICAgICAgICAgICAgaiArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgSkRFID0gSkRFMCArIFMgKiAwLjAwMDAxIC8gZGVsdGFMO1xuICAgICAgICAgICAgcmV0dXJuIEpERTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzYyAgUG9zaXRpb24gb2YgdGhlIFN1bi4gIFBsZWFzZSBzZWUgdGhlIGNvbW1lbnRzXG4gICAgICAgICBvbiB0aGUgcmV0dXJuIHN0YXRlbWVudCBhdCB0aGUgZW5kIG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgIHdoaWNoIGRlc2NyaWJlIHRoZSBhcnJheSBpdCByZXR1cm5zLiAgV2UgcmV0dXJuXG4gICAgICAgICBpbnRlcm1lZGlhdGUgdmFsdWVzIGJlY2F1c2UgdGhleSBhcmUgdXNlZnVsIGluIGFcbiAgICAgICAgIHZhcmlldHkgb2Ygb3RoZXIgY29udGV4dHMuXG4gICAgICAgICAqIEBwYXJhbSBqZFxuICAgICAgICAgKiBAcmV0dXJuIE9iamVjdFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInN1bnBvc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3VucG9zKGpkKSB7XG4gICAgICAgICAgICB2YXIgVCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBUMiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBMMCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBNID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGUgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgQyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBzdW5Mb25nID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHN1bkFub21hbHkgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgc3VuUiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBPbWVnYSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBMYW1iZGEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZXBzaWxvbiA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcHNpbG9uMCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBBbHBoYSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBEZWx0YSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBBbHBoYUFwcCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBEZWx0YUFwcCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgVCA9IChqZCAtIHRoaXMuSjIwMDApIC8gdGhpcy5KdWxpYW5DZW50dXJ5O1xuICAgICAgICAgICAgVDIgPSBUICogVDtcbiAgICAgICAgICAgIEwwID0gMjgwLjQ2NjQ2ICsgMzYwMDAuNzY5ODMgKiBUICsgMC4wMDAzMDMyICogVDI7XG4gICAgICAgICAgICBMMCA9IHRoaXMuZml4YW5nbGUoTDApO1xuICAgICAgICAgICAgTSA9IDM1Ny41MjkxMSArIDM1OTk5LjA1MDI5ICogVCArIC0wLjAwMDE1MzcgKiBUMjtcbiAgICAgICAgICAgIE0gPSB0aGlzLmZpeGFuZ2xlKE0pO1xuICAgICAgICAgICAgZSA9IDAuMDE2NzA4NjM0ICsgLTAuMDAwMDQyMDM3ICogVCArIC0wLjAwMDAwMDEyNjcgKiBUMjtcbiAgICAgICAgICAgIEMgPSAoMS45MTQ2MDIgKyAtMC4wMDQ4MTcgKiBUICsgLTAuMDAwMDE0ICogVDIpICogdGhpcy5kc2luKE0pICsgKDAuMDE5OTkzIC0gMC4wMDAxMDEgKiBUKSAqIHRoaXMuZHNpbigyICogTSkgKyAwLjAwMDI4OSAqIHRoaXMuZHNpbigzICogTSk7XG4gICAgICAgICAgICBzdW5Mb25nID0gTDAgKyBDO1xuICAgICAgICAgICAgc3VuQW5vbWFseSA9IE0gKyBDO1xuICAgICAgICAgICAgc3VuUiA9IDEuMDAwMDAxMDE4ICogKDEgLSBlICogZSkgLyAoMSArIGUgKiB0aGlzLmRjb3Moc3VuQW5vbWFseSkpO1xuICAgICAgICAgICAgT21lZ2EgPSAxMjUuMDQgLSAxOTM0LjEzNiAqIFQ7XG4gICAgICAgICAgICBMYW1iZGEgPSBzdW5Mb25nICsgLTAuMDA1NjkgKyAtMC4wMDQ3OCAqIHRoaXMuZHNpbihPbWVnYSk7XG4gICAgICAgICAgICBlcHNpbG9uMCA9IHRoaXMub2JsaXFlcShqZCk7XG4gICAgICAgICAgICBlcHNpbG9uID0gZXBzaWxvbjAgKyAwLjAwMjU2ICogdGhpcy5kY29zKE9tZWdhKTtcbiAgICAgICAgICAgIEFscGhhID0gdGhpcy5ydGQoTWF0aC5hdGFuMih0aGlzLmRjb3MoZXBzaWxvbjApICogdGhpcy5kc2luKHN1bkxvbmcpLCB0aGlzLmRjb3Moc3VuTG9uZykpKTtcbiAgICAgICAgICAgIEFscGhhID0gdGhpcy5maXhhbmdsZShBbHBoYSk7XG4gICAgICAgICAgICBEZWx0YSA9IHRoaXMucnRkKE1hdGguYXNpbih0aGlzLmRzaW4oZXBzaWxvbjApICogdGhpcy5kc2luKHN1bkxvbmcpKSk7XG4gICAgICAgICAgICBBbHBoYUFwcCA9IHRoaXMucnRkKE1hdGguYXRhbjIodGhpcy5kY29zKGVwc2lsb24pICogdGhpcy5kc2luKExhbWJkYSksIHRoaXMuZGNvcyhMYW1iZGEpKSk7XG4gICAgICAgICAgICBBbHBoYUFwcCA9IHRoaXMuZml4YW5nbGUoQWxwaGFBcHApO1xuICAgICAgICAgICAgRGVsdGFBcHAgPSB0aGlzLnJ0ZChNYXRoLmFzaW4odGhpcy5kc2luKGVwc2lsb24pICogdGhpcy5kc2luKExhbWJkYSkpKTtcblxuICAgICAgICAgICAgcmV0dXJuIFsvLyAgQW5ndWxhciBxdWFudGl0aWVzIGFyZSBleHByZXNzZWQgaW4gZGVjaW1hbCBkZWdyZWVzXG4gICAgICAgICAgICBMMCwgLy8gIFswXSBHZW9tZXRyaWMgbWVhbiBsb25naXR1ZGUgb2YgdGhlIFN1blxuICAgICAgICAgICAgTSwgLy8gIFsxXSBNZWFuIGFub21hbHkgb2YgdGhlIFN1blxuICAgICAgICAgICAgZSwgLy8gIFsyXSBFY2NlbnRyaWNpdHkgb2YgdGhlIEVhcnRoJ3Mgb3JiaXRcbiAgICAgICAgICAgIEMsIC8vICBbM10gU3VuJ3MgZXF1YXRpb24gb2YgdGhlIENlbnRyZVxuICAgICAgICAgICAgc3VuTG9uZywgLy8gIFs0XSBTdW4ncyB0cnVlIGxvbmdpdHVkZVxuICAgICAgICAgICAgc3VuQW5vbWFseSwgLy8gIFs1XSBTdW4ncyB0cnVlIGFub21hbHlcbiAgICAgICAgICAgIHN1blIsIC8vICBbNl0gU3VuJ3MgcmFkaXVzIHZlY3RvciBpbiBBVVxuICAgICAgICAgICAgTGFtYmRhLCAvLyAgWzddIFN1bidzIGFwcGFyZW50IGxvbmdpdHVkZSBhdCB0cnVlIGVxdWlub3ggb2YgdGhlIGRhdGVcbiAgICAgICAgICAgIEFscGhhLCAvLyAgWzhdIFN1bidzIHRydWUgcmlnaHQgYXNjZW5zaW9uXG4gICAgICAgICAgICBEZWx0YSwgLy8gIFs5XSBTdW4ncyB0cnVlIGRlY2xpbmF0aW9uXG4gICAgICAgICAgICBBbHBoYUFwcCwgLy8gWzEwXSBTdW4ncyBhcHBhcmVudCByaWdodCBhc2NlbnNpb25cbiAgICAgICAgICAgIERlbHRhQXBwIC8vIFsxMV0gU3VuJ3MgYXBwYXJlbnQgZGVjbGluYXRpb25cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2MgQ29tcHV0ZSBlcXVhdGlvbiBvZiB0aW1lIGZvciBhIGdpdmVuIG1vbWVudC4gUmV0dXJucyB0aGUgZXF1YXRpb24gb2YgdGltZSBhcyBhIGZyYWN0aW9uIG9mIGEgZGF5LlxuICAgICAgICAgKiBAcGFyYW0gamRcbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfCp9XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZXF1YXRpb25PZlRpbWVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWF0aW9uT2ZUaW1lKGpkKSB7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZGVsdGFQc2kgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgRSA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBlcHNpbG9uID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIEwwID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIHRhdSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRhdSA9IChqZCAtIHRoaXMuSjIwMDApIC8gdGhpcy5KdWxpYW5NaWxsZW5uaXVtO1xuICAgICAgICAgICAgTDAgPSAyODAuNDY2NDU2NyArIDM2MDAwNy42OTgyNzc5ICogdGF1ICsgMC4wMzAzMjAyOCAqIHRhdSAqIHRhdSArIHRhdSAqIHRhdSAqIHRhdSAvIDQ5OTMxICsgLSh0YXUgKiB0YXUgKiB0YXUgKiB0YXUgLyAxNTMwMCkgKyAtKHRhdSAqIHRhdSAqIHRhdSAqIHRhdSAqIHRhdSAvIDIwMDAwMDApO1xuICAgICAgICAgICAgTDAgPSB0aGlzLmZpeGFuZ2xlKEwwKTtcbiAgICAgICAgICAgIGFscGhhID0gdGhpcy5zdW5wb3MoamQpWzEwXTtcbiAgICAgICAgICAgIGRlbHRhUHNpID0gdGhpcy5udXRhdGlvbihqZClbMF07XG4gICAgICAgICAgICBlcHNpbG9uID0gdGhpcy5vYmxpcWVxKGpkKSArIHRoaXMubnV0YXRpb24oamQpWzFdO1xuICAgICAgICAgICAgRSA9IEwwICsgLTAuMDA1NzE4MyArIC1hbHBoYSArIGRlbHRhUHNpICogdGhpcy5kY29zKGVwc2lsb24pO1xuICAgICAgICAgICAgRSA9IEUgLSAyMC4wICogTWF0aC5mbG9vcihFIC8gMjAuMCk7XG4gICAgICAgICAgICBFID0gRSAvICgyNCAqIDYwKTtcbiAgICAgICAgICAgIHJldHVybiBFO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFTVFJPO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFTVFJPO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqIEBtb2R1bGUgY29uc3RhbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZHVyYXRpb25Vbml0OiB7XG4gICAgICAgIHllYXI6IFsneScsICd5ZWFycycsICd5ZWFyJ10sXG4gICAgICAgIG1vbnRoOiBbJ00nLCAnbW9udGhzJywgJ21vbnRoJ10sXG4gICAgICAgIGRheTogWydkJywgJ2RheXMnLCAnZGF5J10sXG4gICAgICAgIGhvdXI6IFsnaCcsICdob3VycycsICdob3VyJ10sXG4gICAgICAgIG1pbnV0ZTogWydtJywgJ21pbnV0ZXMnLCAnbWludXRlJ10sXG4gICAgICAgIHNlY29uZDogWydzJywgJ3NlY29uZCcsICdzZWNvbmRzJ10sXG4gICAgICAgIG1pbGxpc2Vjb25kOiBbJ21zJywgJ21pbGxpc2Vjb25kcycsICdtaWxsaXNlY29uZCddLFxuICAgICAgICB3ZWVrOiBbJ1cnLCAndycsICd3ZWVrcycsICd3ZWVrJ11cbiAgICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIG5vcm1hbGl6ZUR1cmF0aW9uID0gbmV3IEhlbHBlcnMoKS5ub3JtYWxpemVEdXJhdGlvbjtcbnZhciBhYnNSb3VuZCA9IG5ldyBIZWxwZXJzKCkuYWJzUm91bmQ7XG52YXIgYWJzRmxvb3IgPSBuZXcgSGVscGVycygpLmFic0Zsb29yO1xuLyoqXG4gKiBEdXJhdGlvbiBvYmplY3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBkdXJhdGlvblxuICogQGNsYXNzIER1cmF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHVyYXRpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHVyYXRpb24pO1xuXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHt9LFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEgPSB7fSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IDAsXG4gICAgICAgICAgICBub3JtYWxpemVkVW5pdCA9IG5vcm1hbGl6ZUR1cmF0aW9uKGtleSwgdmFsdWUpLFxuICAgICAgICAgICAgdW5pdCA9IG5vcm1hbGl6ZWRVbml0LnVuaXQ7XG4gICAgICAgIGR1cmF0aW9uW3VuaXRdID0gbm9ybWFsaXplZFVuaXQudmFsdWU7XG4gICAgICAgIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLm1pbGxpc2Vjb25kcyB8fCBkdXJhdGlvbi5taWxsaXNlY29uZCB8fCBkdXJhdGlvbi5tcyB8fCAwO1xuXG4gICAgICAgIHZhciB5ZWFycyA9IGR1cmF0aW9uLnllYXJzIHx8IGR1cmF0aW9uLnllYXIgfHwgZHVyYXRpb24ueSB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gZHVyYXRpb24ubW9udGhzIHx8IGR1cmF0aW9uLm1vbnRoIHx8IGR1cmF0aW9uLk0gfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gZHVyYXRpb24ud2Vla3MgfHwgZHVyYXRpb24udyB8fCBkdXJhdGlvbi53ZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uZGF5cyB8fCBkdXJhdGlvbi5kIHx8IGR1cmF0aW9uLmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBkdXJhdGlvbi5ob3VycyB8fCBkdXJhdGlvbi5ob3VyIHx8IGR1cmF0aW9uLmggfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBkdXJhdGlvbi5taW51dGVzIHx8IGR1cmF0aW9uLm1pbnV0ZSB8fCBkdXJhdGlvbi5tIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gZHVyYXRpb24uc2Vjb25kcyB8fCBkdXJhdGlvbi5zZWNvbmQgfHwgZHVyYXRpb24ucyB8fCAwO1xuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgKyBzZWNvbmRzICogMWUzICsgbWludXRlcyAqIDZlNCArIGhvdXJzICogMzZlNTtcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9IGRheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9IG1vbnRocyArIHllYXJzICogMTI7XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG4gICAgICAgIHNlY29uZHMgKz0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcbiAgICAgICAgbWludXRlcyArPSBhYnNSb3VuZChzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG4gICAgICAgIGhvdXJzICs9IGFic1JvdW5kKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuICAgICAgICBkYXlzICs9IGFic1JvdW5kKGhvdXJzIC8gMjQpO1xuICAgICAgICBkYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cyAlIDMwO1xuICAgICAgICBtb250aHMgKz0gYWJzUm91bmQoZGF5cyAvIDMwKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHMgJSAxMjtcbiAgICAgICAgeWVhcnMgKz0gYWJzUm91bmQobW9udGhzIC8gMTIpO1xuICAgICAgICBkYXRhLnllYXJzID0geWVhcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhEdXJhdGlvbiwgW3tcbiAgICAgICAga2V5OiAndmFsdWVPZicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbGxpc2Vjb25kcyArIHRoaXMuX2RheXMgKiA4NjRlNSArIHRoaXMuX21vbnRocyAqIDI1OTJlNjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEdXJhdGlvbjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEdXJhdGlvbjtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKiBAbW9kdWxlIGNvbnN0YW50c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdyZWdvcmlhbjoge1xuICAgICAgICBtb250aHM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgICBtb250aHNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddLFxuICAgICAgICB3ZWVrZGF5czogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSddLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICB3ZWVrZGF5c01pbjogWydTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGcicsICdTYSddXG4gICAgfSxcbiAgICBwZXJzaWFuOiB7XG4gICAgICAgIG1vbnRoczogWydGYXJ2YXJkaW4nLCAnT3JkaWJlaGVzaHQnLCAnS2hvcmRhZCcsICdUaXInLCAnTW9yZGFkJywgJ1NoYWhyaXZhcicsICdNZWhyJywgJ0FiYW4nLCAnQXphcicsICdEZXknLCAnQmFobWFuJywgJ0VzZmFuZCddLFxuICAgICAgICBtb250aHNTaG9ydDogWydGYXInLCAnT3JkJywgJ0tobycsICdUaXInLCAnTW9yJywgJ1NoYScsICdNZWgnLCAnQWJhJywgJ0F6YScsICdEZXknLCAnQmFoJywgJ0VzZiddLFxuICAgICAgICB3ZWVrZGF5czogWydTYXR1cmRheScsICdTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheSddLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBbJ1NhdCcsICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaSddLFxuICAgICAgICB3ZWVrZGF5c01pbjogWydTYScsICdTdScsICdNbycsICdUdScsICdXZScsICdUaCcsICdGciddLFxuICAgICAgICBwZXJzaWFuRGF5c05hbWU6IFsnVXJtYXpkJywgJ0JhaG1hbicsICdPcmRpYmVoZXNodCcsICdTaGFocml2YXInLCAnU2VwYW5kYXJtYXonLCAnS2h1cmRhZCcsICdBbW9yZGFkJywgJ0RleS1iZS1hemFyJywgJ0F6YXInLCAnQWJhbicsICdLaG9yc2hpZCcsICdNYWgnLCAnVGlyJywgJ0d1c2gnLCAnRGV5LWJlLW1laHInLCAnTWVocicsICdTb3J1c2gnLCAnUmFzaG4nLCAnRmFydmFyZGluJywgJ0JhaHJhbScsICdSYW0nLCAnQmFkJywgJ0RleS1iZS1kaW4nLCAnRGluJywgJ09yZCcsICdBc2h0YWQnLCAnQXNtYW4nLCAnWmFteWFkJywgJ01hbnRyZS1zZXBhbmQnLCAnQW5hcmFtJywgJ1ppYWRpJ11cbiAgICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBDb25zdGFudHNcbiAqIEBtb2R1bGUgY29uc3RhbnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ3JlZ29yaWFuOiB7XG4gICAgICAgIG1vbnRoczogJ9qY2KfZhtmI24zZh1/ZgdmI2LHbjNmHX9mF2KfYsdizX9ii2YjYsduM2YRf2YXZh1/amNmI2KbZhl/amNmI2KbbjNmHX9in2YjYql/Ys9m+2KrYp9mF2KjYsV/Yp9qp2KrYqNixX9mG2YjYp9mF2KjYsV/Yr9iz2KfZhdio2LEnLnNwbGl0KCdfJyksXG4gICAgICAgIG1vbnRoc1Nob3J0OiAn2pjYp9mG2YjbjNmHX9mB2YjYsduM2Ydf2YXYp9ix2LNf2KLZiNix24zZhF/ZhdmHX9qY2YjYptmGX9qY2YjYptuM2Ydf2KfZiNiqX9iz2b7Yqtin2YXYqNixX9in2qnYqtio2LFf2YbZiNin2YXYqNixX9iv2LPYp9mF2KjYsScuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXM6ICdcXHUwNkNDXFx1MDZBOVxcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2MkZcXHUwNjQ4XFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0N19cXHUwNjMzXFx1MDY0N1xcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2ODZcXHUwNjQ3XFx1MDYyN1xcdTA2MzFcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2N0VcXHUwNjQ2XFx1MDYyQ1xcdTIwMENcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2MkNcXHUwNjQ1XFx1MDYzOVxcdTA2NDdfXFx1MDYzNFxcdTA2NDZcXHUwNjI4XFx1MDY0Nycuc3BsaXQoJ18nKSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogJ1xcdTA2Q0NcXHUwNkE5XFx1MjAwQ1xcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDdfXFx1MDYyRlxcdTA2NDhcXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3X1xcdTA2MzNcXHUwNjQ3XFx1MjAwQ1xcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDdfXFx1MDY4NlxcdTA2NDdcXHUwNjI3XFx1MDYzMVxcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDdfXFx1MDY3RVxcdTA2NDZcXHUwNjJDXFx1MjAwQ1xcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDdfXFx1MDYyQ1xcdTA2NDVcXHUwNjM5XFx1MDY0N19cXHUwNjM0XFx1MDY0NlxcdTA2MjhcXHUwNjQ3Jy5zcGxpdCgnXycpLFxuICAgICAgICB3ZWVrZGF5c01pbjogJ9uMX9ivX9izX9qGX9m+X9isX9i0Jy5zcGxpdCgnXycpXG4gICAgfSxcbiAgICBwZXJzaWFuOiB7XG4gICAgICAgIG1vbnRoczogWyfZgdix2YjYsdiv24zZhicsICfYp9ix2K/bjNio2YfYtNiqJywgJ9iu2LHYr9in2K8nLCAn2KrbjNixJywgJ9mF2LHYr9in2K8nLCAn2LTZh9ix24zZiNixJywgJ9mF2YfYsScsICfYotio2KfZhicsICfYotiw2LEnLCAn2K/bjCcsICfYqNmH2YXZhicsICfYp9iz2YHZhtivJ10sXG4gICAgICAgIG1vbnRoc1Nob3J0OiBbJ9mB2LHZiCcsICfYp9ix2K8nLCAn2K7YsdivJywgJ9iq24zYsScsICfZhdix2K8nLCAn2LTZh9ixJywgJ9mF2YfYsScsICfYotio2KcnLCAn2KLYsNixJywgJ9iv24wnLCAn2KjZh9mFJywgJ9in2LPZgSddLFxuICAgICAgICB3ZWVrZGF5czogWyfYtNmG2KjZhycsICfbjNqp2LTZhtio2YcnLCAn2K/ZiNi02YbYqNmHJywgJ9iz2Ycg2LTZhtio2YcnLCAn2obZh9in2LEg2LTZhtio2YcnLCAnXFx1MDY3RVxcdTA2NDZcXHUwNjJDXFx1MjAwQ1xcdTA2MzRcXHUwNjQ2XFx1MDYyOFxcdTA2NDcnLCAn2KzZhdi52YcnXSxcbiAgICAgICAgd2Vla2RheXNTaG9ydDogWyfYtCcsICfbjCcsICfYrycsICfYsycsICfahicsICfZvicsICfYrCddLFxuICAgICAgICB3ZWVrZGF5c01pbjogWyfYtCcsICfbjCcsICfYrycsICfYsycsICfahicsICfZvicsICfYrCddLFxuICAgICAgICBwZXJzaWFuRGF5c05hbWU6IFsn2KfZiNix2YXYstivJywgJ9io2YfZhdmGJywgJ9in2YjYsdiv24zYqNmH2LTYqicsICfYtNmH2LHbjNmI2LEnLCAn2LPZvtmG2K/Yp9ix2YXYsCcsICfYrtmI2LHYr9in2K8nLCAn2KfZhdix2K/Yp9ivJywgJ9iv24wg2KjZhyDYotiw2LInLCAn2KLYsNiyJywgJ9ii2KjYp9mGJywgJ9iu2YjYsdi024zYrycsICfZhdin2YcnLCAn2KrbjNixJywgJ9qv2YjYtCcsICfYr9uMINio2Ycg2YXZh9ixJywgJ9mF2YfYsScsICfYs9ix2YjYtCcsICfYsdi02YYnLCAn2YHYsdmI2LHYr9uM2YYnLCAn2KjZh9ix2KfZhScsICfYsdin2YUnLCAn2KjYp9ivJywgJ9iv24wg2KjZhyDYr9uM2YYnLCAn2K/bjNmGJywgJ9in2LHYrycsICfYp9i02KrYp9ivJywgJ9ii2LPZhdin2YYnLCAn2LLYp9mF24zYp9ivJywgJ9mF2KfZhtiq2LHZhyDYs9m+2YbYrycsICfYp9mG2KfYsdin2YUnLCAn2LLbjNin2K/bjCddXG4gICAgfVxufTtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQZXJzaWFuRGF0ZUNsYXNzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblBlcnNpYW5EYXRlQ2xhc3MuY2FsZW5kYXJUeXBlID0gJ3BlcnNpYW4nO1xuUGVyc2lhbkRhdGVDbGFzcy5sZWFwWWVhck1vZGUgPSAnYXN0cm9ub21pY2FsJztcblBlcnNpYW5EYXRlQ2xhc3MubG9jYWxUeXBlID0gJ2ZhJztcbm1vZHVsZS5leHBvcnRzID0gUGVyc2lhbkRhdGVDbGFzcztcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBDb250YWluZXIgPSBmdW5jdGlvbiBDb250YWluZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRhaW5lcik7XG5cbiAgICB0aGlzLmlzSW52YWxpZERhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5nRGF0ZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubW9kaWZpZWRqdWxpYW5kYXkgPSAwO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuanVsaWFuZGF5ID0gMDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3tkYXk6IG51bWJlcn19XG4gICAgICovXG4gICAgdGhpcy5ncmVnc2VyaWFsID0ge1xuICAgICAgICBkYXk6IDBcbiAgICB9O1xuXG4gICAgdGhpcy56b25lID0gMDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCBob3VyOiBudW1iZXIsIG1pbnV0ZTogbnVtYmVyLCBzZWNvbmQ6IG51bWJlciwgbWlsbGlzZWNvbmQ6IG51bWJlciwgd2Vla2RheTogbnVtYmVyLCB1bml4OiBudW1iZXIsIGxlYXA6IG51bWJlcn19XG4gICAgICovXG4gICAgdGhpcy5ncmVnb3JpYW4gPSB7XG4gICAgICAgIHllYXI6IDAsXG4gICAgICAgIG1vbnRoOiAwLFxuICAgICAgICBkYXk6IDAsXG4gICAgICAgIGhvdXI6IDAsXG4gICAgICAgIG1pbnV0ZTogMCxcbiAgICAgICAgc2Vjb25kOiAwLFxuICAgICAgICBtaWxsaXNlY29uZDogMCxcbiAgICAgICAgd2Vla2RheTogMCxcbiAgICAgICAgdW5peDogMCxcbiAgICAgICAgbGVhcDogMFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHt7eWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlciwgbGVhcDogbnVtYmVyLCB3ZWVrZGF5OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIHRoaXMuanVsaWFuY2FsZW5kYXIgPSB7XG4gICAgICAgIHllYXI6IDAsXG4gICAgICAgIG1vbnRoOiAwLFxuICAgICAgICBkYXk6IDAsXG4gICAgICAgIGxlYXA6IDAsXG4gICAgICAgIHdlZWtkYXk6IDBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7e3llYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIsIGxlYXA6IG51bWJlciwgd2Vla2RheTogbnVtYmVyfX1cbiAgICAgKi9cbiAgICB0aGlzLmlzbGFtaWMgPSB7XG4gICAgICAgIHllYXI6IDAsXG4gICAgICAgIG1vbnRoOiAwLFxuICAgICAgICBkYXk6IDAsXG4gICAgICAgIGxlYXA6IDAsXG4gICAgICAgIHdlZWtkYXk6IDBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7e3llYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIsIGxlYXA6IG51bWJlciwgd2Vla2RheTogbnVtYmVyfX1cbiAgICAgKi9cbiAgICB0aGlzLnBlcnNpYW5BbGdvID0gdGhpcy5wZXJzaWFuID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICBtb250aDogMCxcbiAgICAgICAgZGF5OiAwLFxuICAgICAgICBsZWFwOiAwLFxuICAgICAgICB3ZWVrZGF5OiAwXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge3t5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyLCBsZWFwOiBudW1iZXIsIHdlZWtkYXk6IG51bWJlcn19XG4gICAgICovXG4gICAgdGhpcy5wZXJzaWFuQXN0cm8gPSB7XG4gICAgICAgIHllYXI6IDAsXG4gICAgICAgIG1vbnRoOiAwLFxuICAgICAgICBkYXk6IDAsXG4gICAgICAgIGxlYXA6IDAsXG4gICAgICAgIHdlZWtkYXk6IDBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7e3llYXI6IG51bWJlciwgd2VlazogbnVtYmVyLCBkYXk6IG51bWJlcn19XG4gICAgICovXG4gICAgdGhpcy5pc293ZWVrID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICB3ZWVrOiAwLFxuICAgICAgICBkYXk6IDBcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7e3llYXI6IG51bWJlciwgZGF5OiBudW1iZXJ9fVxuICAgICAqL1xuICAgIHRoaXMuaXNvZGF5ID0ge1xuICAgICAgICB5ZWFyOiAwLFxuICAgICAgICBkYXk6IDBcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWluZXI7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBcnJheTogZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzTnVtYmVyOiBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRGF0ZTogZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XG4gICAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHZhbGlkYXRlSW5wdXRBcnJheTogZnVuY3Rpb24gdmFsaWRhdGVJbnB1dEFycmF5KGlucHV0KSB7XG4gICAgdmFyIG91dCA9IHRydWU7XG4gICAgLy8gQ2hlY2sgbW9udGhcbiAgICBpZiAoaW5wdXRbMV0gPCAxIHx8IGlucHV0WzFdID4gMTIpIHtcbiAgICAgIG91dCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBkYXRlXG4gICAgaWYgKGlucHV0WzJdIDwgMSB8fCBpbnB1dFsxXSA+IDMxKSB7XG4gICAgICBvdXQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaG91ciBcbiAgICBpZiAoaW5wdXRbM10gPCAwIHx8IGlucHV0WzNdID4gMjQpIHtcbiAgICAgIG91dCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBDaGVjayBtaW51dGUgXG4gICAgaWYgKGlucHV0WzRdIDwgMCB8fCBpbnB1dFs0XSA+IDYwKSB7XG4gICAgICBvdXQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgc2Vjb25kIFxuICAgIGlmIChpbnB1dFs1XSA8IDAgfHwgaW5wdXRbNV0gPiA2MCkge1xuICAgICAgb3V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn07XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/persian-date/dist/persian-date.js\n");

/***/ })

}]);