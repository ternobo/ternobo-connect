(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~bootstrap-vue-dialog"],{

/***/ "./node_modules/bootstrap-vue-dialog/dist/bootstrap-vue-dialog.js":
/*!************************************************************************!*\
  !*** ./node_modules/bootstrap-vue-dialog/dist/bootstrap-vue-dialog.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, factory) {\n\t true ? module.exports = factory(__webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.common.js\")) :\n\tundefined;\n}(this, (function (vue) { 'use strict';\n\n\tvue = vue && vue.hasOwnProperty('default') ? vue['default'] : vue;\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar vuedl = createCommonjsModule(function (module, exports) {\n\t(function (global, factory) {\n\t  module.exports = factory(vue);\n\t}(commonjsGlobal, (function (Vue) {\n\t  Vue = Vue && Vue.hasOwnProperty('default') ? Vue['default'] : Vue;\n\n\t  var Recordable = {\n\t    computed: {\n\t      $parameters: function $parameters() {\n\t        return this.$options.propsData;\n\t      },\n\n\t      isNewRecord: function () {\n\t        return !this.$options.primaryKey || !this.$options.propsData || !this.$options.propsData[this.$options.primaryKey];\n\t      }\n\t    }\n\t  };\n\n\t  var Activable = {\n\t    name: 'Activable',\n\n\t    data: function data() {\n\t      return {\n\t        isActive: false\n\t      };\n\t    },\n\n\t    watch: {\n\t      isActive: function isActive(val) {\n\t        // debugger\n\t        // if (this.isLayout) {\n\t        // this.$children.forEach(vm => {\n\t        //   if (vm.isActive !== undefined) {\n\t        //     vm.isActive = val\n\t        //   }\n\t        // })\n\t        if (this._dialogInstance) {\n\t          if (this._dialogInstance.isActive !== undefined) {\n\t            this._dialogInstance.isActive = val;\n\t          }\n\t        } else {\n\t          if (this.$parent && this.$parent.isActive !== undefined) {\n\t            this.$parent.isActive = val;\n\t          }\n\t        }\n\t      }\n\n\t    },\n\t    methods: {\n\t      close: function close() {\n\t        this.isActive = false;\n\t      }\n\n\t    }\n\t  };\n\n\t  var Layoutable = {\n\t    name: 'Layoutable',\n\t    mixins: [Activable],\n\t    props: {\n\t      width: {\n\t        type: Number,\n\t        default: function () { return 450; }\n\t      },\n\t      persistent: Boolean\n\t    },\n\n\t    data: function data() {\n\t      return {\n\t        loading: false\n\t      };\n\t    },\n\n\t    compouted: {\n\t      isLayout: function isLayout() {\n\t        return true;\n\t      }\n\n\t    },\n\t    watch: {\n\t      isActive: function isActive(val) {\n\t        if (!val) {\n\t          // window.removeEventListener('popstate', this.close)\n\t          this._destroy();\n\t        }\n\t      }\n\n\t    },\n\n\t    mounted: function mounted() {\n\t      // this.$nextTick(() => {\n\t      // window.addEventListener('popstate', this.close)\n\t      // })\n\t      this.isActive = true;\n\t    },\n\n\t    methods: {\n\t      _destroy: function _destroy() {\n\t        this.$destroy();\n\t      },\n\n\t      dismiss: function dismiss() {\n\t        if (!this.persistent && !this.loading) {\n\t          this.isActive = false;\n\t        }\n\t      },\n\n\t      close: function close() {\n\t        this.isActive = false;\n\t      }\n\n\t    },\n\n\t    beforeDestroy: function beforeDestroy() {\n\t      if (typeof this.$el.remove !== 'undefined') {\n\t        this.$el.remove();\n\t      } else {\n\t        this.$el.parentNode.removeChild(this.$el);\n\t      }\n\t    }\n\n\t  };\n\n\t  /**\n\t   * Removes all key-value entries from the list cache.\n\t   *\n\t   * @private\n\t   * @name clear\n\t   * @memberOf ListCache\n\t   */\n\t  function listCacheClear() {\n\t    this.__data__ = [];\n\t    this.size = 0;\n\t  }\n\n\t  var _listCacheClear = listCacheClear;\n\n\t  /**\n\t   * Performs a\n\t   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t   * comparison between two values to determine if they are equivalent.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to compare.\n\t   * @param {*} other The other value to compare.\n\t   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n\t   * @example\n\t   *\n\t   * var object = { 'a': 1 };\n\t   * var other = { 'a': 1 };\n\t   *\n\t   * _.eq(object, object);\n\t   * // => true\n\t   *\n\t   * _.eq(object, other);\n\t   * // => false\n\t   *\n\t   * _.eq('a', 'a');\n\t   * // => true\n\t   *\n\t   * _.eq('a', Object('a'));\n\t   * // => false\n\t   *\n\t   * _.eq(NaN, NaN);\n\t   * // => true\n\t   */\n\t  function eq(value, other) {\n\t    return value === other || (value !== value && other !== other);\n\t  }\n\n\t  var eq_1 = eq;\n\n\t  /**\n\t   * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t   *\n\t   * @private\n\t   * @param {Array} array The array to inspect.\n\t   * @param {*} key The key to search for.\n\t   * @returns {number} Returns the index of the matched value, else `-1`.\n\t   */\n\t  function assocIndexOf(array, key) {\n\t    var length = array.length;\n\t    while (length--) {\n\t      if (eq_1(array[length][0], key)) {\n\t        return length;\n\t      }\n\t    }\n\t    return -1;\n\t  }\n\n\t  var _assocIndexOf = assocIndexOf;\n\n\t  /** Used for built-in method references. */\n\t  var arrayProto = Array.prototype;\n\n\t  /** Built-in value references. */\n\t  var splice = arrayProto.splice;\n\n\t  /**\n\t   * Removes `key` and its value from the list cache.\n\t   *\n\t   * @private\n\t   * @name delete\n\t   * @memberOf ListCache\n\t   * @param {string} key The key of the value to remove.\n\t   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t   */\n\t  function listCacheDelete(key) {\n\t    var data = this.__data__,\n\t        index = _assocIndexOf(data, key);\n\n\t    if (index < 0) {\n\t      return false;\n\t    }\n\t    var lastIndex = data.length - 1;\n\t    if (index == lastIndex) {\n\t      data.pop();\n\t    } else {\n\t      splice.call(data, index, 1);\n\t    }\n\t    --this.size;\n\t    return true;\n\t  }\n\n\t  var _listCacheDelete = listCacheDelete;\n\n\t  /**\n\t   * Gets the list cache value for `key`.\n\t   *\n\t   * @private\n\t   * @name get\n\t   * @memberOf ListCache\n\t   * @param {string} key The key of the value to get.\n\t   * @returns {*} Returns the entry value.\n\t   */\n\t  function listCacheGet(key) {\n\t    var data = this.__data__,\n\t        index = _assocIndexOf(data, key);\n\n\t    return index < 0 ? undefined : data[index][1];\n\t  }\n\n\t  var _listCacheGet = listCacheGet;\n\n\t  /**\n\t   * Checks if a list cache value for `key` exists.\n\t   *\n\t   * @private\n\t   * @name has\n\t   * @memberOf ListCache\n\t   * @param {string} key The key of the entry to check.\n\t   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t   */\n\t  function listCacheHas(key) {\n\t    return _assocIndexOf(this.__data__, key) > -1;\n\t  }\n\n\t  var _listCacheHas = listCacheHas;\n\n\t  /**\n\t   * Sets the list cache `key` to `value`.\n\t   *\n\t   * @private\n\t   * @name set\n\t   * @memberOf ListCache\n\t   * @param {string} key The key of the value to set.\n\t   * @param {*} value The value to set.\n\t   * @returns {Object} Returns the list cache instance.\n\t   */\n\t  function listCacheSet(key, value) {\n\t    var data = this.__data__,\n\t        index = _assocIndexOf(data, key);\n\n\t    if (index < 0) {\n\t      ++this.size;\n\t      data.push([key, value]);\n\t    } else {\n\t      data[index][1] = value;\n\t    }\n\t    return this;\n\t  }\n\n\t  var _listCacheSet = listCacheSet;\n\n\t  /**\n\t   * Creates an list cache object.\n\t   *\n\t   * @private\n\t   * @constructor\n\t   * @param {Array} [entries] The key-value pairs to cache.\n\t   */\n\t  function ListCache(entries) {\n\t    var index = -1,\n\t        length = entries == null ? 0 : entries.length;\n\n\t    this.clear();\n\t    while (++index < length) {\n\t      var entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\n\t  // Add methods to `ListCache`.\n\t  ListCache.prototype.clear = _listCacheClear;\n\t  ListCache.prototype['delete'] = _listCacheDelete;\n\t  ListCache.prototype.get = _listCacheGet;\n\t  ListCache.prototype.has = _listCacheHas;\n\t  ListCache.prototype.set = _listCacheSet;\n\n\t  var _ListCache = ListCache;\n\n\t  /**\n\t   * Removes all key-value entries from the stack.\n\t   *\n\t   * @private\n\t   * @name clear\n\t   * @memberOf Stack\n\t   */\n\t  function stackClear() {\n\t    this.__data__ = new _ListCache;\n\t    this.size = 0;\n\t  }\n\n\t  var _stackClear = stackClear;\n\n\t  /**\n\t   * Removes `key` and its value from the stack.\n\t   *\n\t   * @private\n\t   * @name delete\n\t   * @memberOf Stack\n\t   * @param {string} key The key of the value to remove.\n\t   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t   */\n\t  function stackDelete(key) {\n\t    var data = this.__data__,\n\t        result = data['delete'](key);\n\n\t    this.size = data.size;\n\t    return result;\n\t  }\n\n\t  var _stackDelete = stackDelete;\n\n\t  /**\n\t   * Gets the stack value for `key`.\n\t   *\n\t   * @private\n\t   * @name get\n\t   * @memberOf Stack\n\t   * @param {string} key The key of the value to get.\n\t   * @returns {*} Returns the entry value.\n\t   */\n\t  function stackGet(key) {\n\t    return this.__data__.get(key);\n\t  }\n\n\t  var _stackGet = stackGet;\n\n\t  /**\n\t   * Checks if a stack value for `key` exists.\n\t   *\n\t   * @private\n\t   * @name has\n\t   * @memberOf Stack\n\t   * @param {string} key The key of the entry to check.\n\t   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t   */\n\t  function stackHas(key) {\n\t    return this.__data__.has(key);\n\t  }\n\n\t  var _stackHas = stackHas;\n\n\t  var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};\n\n\t  function createCommonjsModule$$1(fn, module) {\n\t  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t  }\n\n\t  /** Detect free variable `global` from Node.js. */\n\t  var freeGlobal = typeof commonjsGlobal$$1 == 'object' && commonjsGlobal$$1 && commonjsGlobal$$1.Object === Object && commonjsGlobal$$1;\n\n\t  var _freeGlobal = freeGlobal;\n\n\t  /** Detect free variable `self`. */\n\t  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n\t  /** Used as a reference to the global object. */\n\t  var root = _freeGlobal || freeSelf || Function('return this')();\n\n\t  var _root = root;\n\n\t  /** Built-in value references. */\n\t  var Symbol = _root.Symbol;\n\n\t  var _Symbol = Symbol;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty = objectProto.hasOwnProperty;\n\n\t  /**\n\t   * Used to resolve the\n\t   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t   * of values.\n\t   */\n\t  var nativeObjectToString = objectProto.toString;\n\n\t  /** Built-in value references. */\n\t  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;\n\n\t  /**\n\t   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to query.\n\t   * @returns {string} Returns the raw `toStringTag`.\n\t   */\n\t  function getRawTag(value) {\n\t    var isOwn = hasOwnProperty.call(value, symToStringTag),\n\t        tag = value[symToStringTag];\n\n\t    try {\n\t      value[symToStringTag] = undefined;\n\t      var unmasked = true;\n\t    } catch (e) {}\n\n\t    var result = nativeObjectToString.call(value);\n\t    if (unmasked) {\n\t      if (isOwn) {\n\t        value[symToStringTag] = tag;\n\t      } else {\n\t        delete value[symToStringTag];\n\t      }\n\t    }\n\t    return result;\n\t  }\n\n\t  var _getRawTag = getRawTag;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$1 = Object.prototype;\n\n\t  /**\n\t   * Used to resolve the\n\t   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t   * of values.\n\t   */\n\t  var nativeObjectToString$1 = objectProto$1.toString;\n\n\t  /**\n\t   * Converts `value` to a string using `Object.prototype.toString`.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to convert.\n\t   * @returns {string} Returns the converted string.\n\t   */\n\t  function objectToString(value) {\n\t    return nativeObjectToString$1.call(value);\n\t  }\n\n\t  var _objectToString = objectToString;\n\n\t  /** `Object#toString` result references. */\n\t  var nullTag = '[object Null]',\n\t      undefinedTag = '[object Undefined]';\n\n\t  /** Built-in value references. */\n\t  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;\n\n\t  /**\n\t   * The base implementation of `getTag` without fallbacks for buggy environments.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to query.\n\t   * @returns {string} Returns the `toStringTag`.\n\t   */\n\t  function baseGetTag(value) {\n\t    if (value == null) {\n\t      return value === undefined ? undefinedTag : nullTag;\n\t    }\n\t    return (symToStringTag$1 && symToStringTag$1 in Object(value))\n\t      ? _getRawTag(value)\n\t      : _objectToString(value);\n\t  }\n\n\t  var _baseGetTag = baseGetTag;\n\n\t  /**\n\t   * Checks if `value` is the\n\t   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n\t   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 0.1.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n\t   * @example\n\t   *\n\t   * _.isObject({});\n\t   * // => true\n\t   *\n\t   * _.isObject([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isObject(_.noop);\n\t   * // => true\n\t   *\n\t   * _.isObject(null);\n\t   * // => false\n\t   */\n\t  function isObject(value) {\n\t    var type = typeof value;\n\t    return value != null && (type == 'object' || type == 'function');\n\t  }\n\n\t  var isObject_1 = isObject;\n\n\t  /** `Object#toString` result references. */\n\t  var asyncTag = '[object AsyncFunction]',\n\t      funcTag = '[object Function]',\n\t      genTag = '[object GeneratorFunction]',\n\t      proxyTag = '[object Proxy]';\n\n\t  /**\n\t   * Checks if `value` is classified as a `Function` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 0.1.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t   * @example\n\t   *\n\t   * _.isFunction(_);\n\t   * // => true\n\t   *\n\t   * _.isFunction(/abc/);\n\t   * // => false\n\t   */\n\t  function isFunction(value) {\n\t    if (!isObject_1(value)) {\n\t      return false;\n\t    }\n\t    // The use of `Object#toString` avoids issues with the `typeof` operator\n\t    // in Safari 9 which returns 'object' for typed arrays and other constructors.\n\t    var tag = _baseGetTag(value);\n\t    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n\t  }\n\n\t  var isFunction_1 = isFunction;\n\n\t  /** Used to detect overreaching core-js shims. */\n\t  var coreJsData = _root['__core-js_shared__'];\n\n\t  var _coreJsData = coreJsData;\n\n\t  /** Used to detect methods masquerading as native. */\n\t  var maskSrcKey = (function() {\n\t    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');\n\t    return uid ? ('Symbol(src)_1.' + uid) : '';\n\t  }());\n\n\t  /**\n\t   * Checks if `func` has its source masked.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to check.\n\t   * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t   */\n\t  function isMasked(func) {\n\t    return !!maskSrcKey && (maskSrcKey in func);\n\t  }\n\n\t  var _isMasked = isMasked;\n\n\t  /** Used for built-in method references. */\n\t  var funcProto = Function.prototype;\n\n\t  /** Used to resolve the decompiled source of functions. */\n\t  var funcToString = funcProto.toString;\n\n\t  /**\n\t   * Converts `func` to its source code.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to convert.\n\t   * @returns {string} Returns the source code.\n\t   */\n\t  function toSource(func) {\n\t    if (func != null) {\n\t      try {\n\t        return funcToString.call(func);\n\t      } catch (e) {}\n\t      try {\n\t        return (func + '');\n\t      } catch (e) {}\n\t    }\n\t    return '';\n\t  }\n\n\t  var _toSource = toSource;\n\n\t  /**\n\t   * Used to match `RegExp`\n\t   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t   */\n\t  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n\t  /** Used to detect host constructors (Safari). */\n\t  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n\t  /** Used for built-in method references. */\n\t  var funcProto$1 = Function.prototype,\n\t      objectProto$2 = Object.prototype;\n\n\t  /** Used to resolve the decompiled source of functions. */\n\t  var funcToString$1 = funcProto$1.toString;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n\t  /** Used to detect if a method is native. */\n\t  var reIsNative = RegExp('^' +\n\t    funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\\\$&')\n\t    .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n\t  );\n\n\t  /**\n\t   * The base implementation of `_.isNative` without bad shim checks.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a native function,\n\t   *  else `false`.\n\t   */\n\t  function baseIsNative(value) {\n\t    if (!isObject_1(value) || _isMasked(value)) {\n\t      return false;\n\t    }\n\t    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;\n\t    return pattern.test(_toSource(value));\n\t  }\n\n\t  var _baseIsNative = baseIsNative;\n\n\t  /**\n\t   * Gets the value at `key` of `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} [object] The object to query.\n\t   * @param {string} key The key of the property to get.\n\t   * @returns {*} Returns the property value.\n\t   */\n\t  function getValue(object, key) {\n\t    return object == null ? undefined : object[key];\n\t  }\n\n\t  var _getValue = getValue;\n\n\t  /**\n\t   * Gets the native function at `key` of `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {string} key The key of the method to get.\n\t   * @returns {*} Returns the function if it's native, else `undefined`.\n\t   */\n\t  function getNative(object, key) {\n\t    var value = _getValue(object, key);\n\t    return _baseIsNative(value) ? value : undefined;\n\t  }\n\n\t  var _getNative = getNative;\n\n\t  /* Built-in method references that are verified to be native. */\n\t  var Map = _getNative(_root, 'Map');\n\n\t  var _Map = Map;\n\n\t  /* Built-in method references that are verified to be native. */\n\t  var nativeCreate = _getNative(Object, 'create');\n\n\t  var _nativeCreate = nativeCreate;\n\n\t  /**\n\t   * Removes all key-value entries from the hash.\n\t   *\n\t   * @private\n\t   * @name clear\n\t   * @memberOf Hash\n\t   */\n\t  function hashClear() {\n\t    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};\n\t    this.size = 0;\n\t  }\n\n\t  var _hashClear = hashClear;\n\n\t  /**\n\t   * Removes `key` and its value from the hash.\n\t   *\n\t   * @private\n\t   * @name delete\n\t   * @memberOf Hash\n\t   * @param {Object} hash The hash to modify.\n\t   * @param {string} key The key of the value to remove.\n\t   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t   */\n\t  function hashDelete(key) {\n\t    var result = this.has(key) && delete this.__data__[key];\n\t    this.size -= result ? 1 : 0;\n\t    return result;\n\t  }\n\n\t  var _hashDelete = hashDelete;\n\n\t  /** Used to stand-in for `undefined` hash values. */\n\t  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$3 = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n\t  /**\n\t   * Gets the hash value for `key`.\n\t   *\n\t   * @private\n\t   * @name get\n\t   * @memberOf Hash\n\t   * @param {string} key The key of the value to get.\n\t   * @returns {*} Returns the entry value.\n\t   */\n\t  function hashGet(key) {\n\t    var data = this.__data__;\n\t    if (_nativeCreate) {\n\t      var result = data[key];\n\t      return result === HASH_UNDEFINED ? undefined : result;\n\t    }\n\t    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;\n\t  }\n\n\t  var _hashGet = hashGet;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$4 = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n\t  /**\n\t   * Checks if a hash value for `key` exists.\n\t   *\n\t   * @private\n\t   * @name has\n\t   * @memberOf Hash\n\t   * @param {string} key The key of the entry to check.\n\t   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t   */\n\t  function hashHas(key) {\n\t    var data = this.__data__;\n\t    return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);\n\t  }\n\n\t  var _hashHas = hashHas;\n\n\t  /** Used to stand-in for `undefined` hash values. */\n\t  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';\n\n\t  /**\n\t   * Sets the hash `key` to `value`.\n\t   *\n\t   * @private\n\t   * @name set\n\t   * @memberOf Hash\n\t   * @param {string} key The key of the value to set.\n\t   * @param {*} value The value to set.\n\t   * @returns {Object} Returns the hash instance.\n\t   */\n\t  function hashSet(key, value) {\n\t    var data = this.__data__;\n\t    this.size += this.has(key) ? 0 : 1;\n\t    data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;\n\t    return this;\n\t  }\n\n\t  var _hashSet = hashSet;\n\n\t  /**\n\t   * Creates a hash object.\n\t   *\n\t   * @private\n\t   * @constructor\n\t   * @param {Array} [entries] The key-value pairs to cache.\n\t   */\n\t  function Hash(entries) {\n\t    var index = -1,\n\t        length = entries == null ? 0 : entries.length;\n\n\t    this.clear();\n\t    while (++index < length) {\n\t      var entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\n\t  // Add methods to `Hash`.\n\t  Hash.prototype.clear = _hashClear;\n\t  Hash.prototype['delete'] = _hashDelete;\n\t  Hash.prototype.get = _hashGet;\n\t  Hash.prototype.has = _hashHas;\n\t  Hash.prototype.set = _hashSet;\n\n\t  var _Hash = Hash;\n\n\t  /**\n\t   * Removes all key-value entries from the map.\n\t   *\n\t   * @private\n\t   * @name clear\n\t   * @memberOf MapCache\n\t   */\n\t  function mapCacheClear() {\n\t    this.size = 0;\n\t    this.__data__ = {\n\t      'hash': new _Hash,\n\t      'map': new (_Map || _ListCache),\n\t      'string': new _Hash\n\t    };\n\t  }\n\n\t  var _mapCacheClear = mapCacheClear;\n\n\t  /**\n\t   * Checks if `value` is suitable for use as unique object key.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n\t   */\n\t  function isKeyable(value) {\n\t    var type = typeof value;\n\t    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n\t      ? (value !== '__proto__')\n\t      : (value === null);\n\t  }\n\n\t  var _isKeyable = isKeyable;\n\n\t  /**\n\t   * Gets the data for `map`.\n\t   *\n\t   * @private\n\t   * @param {Object} map The map to query.\n\t   * @param {string} key The reference key.\n\t   * @returns {*} Returns the map data.\n\t   */\n\t  function getMapData(map, key) {\n\t    var data = map.__data__;\n\t    return _isKeyable(key)\n\t      ? data[typeof key == 'string' ? 'string' : 'hash']\n\t      : data.map;\n\t  }\n\n\t  var _getMapData = getMapData;\n\n\t  /**\n\t   * Removes `key` and its value from the map.\n\t   *\n\t   * @private\n\t   * @name delete\n\t   * @memberOf MapCache\n\t   * @param {string} key The key of the value to remove.\n\t   * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t   */\n\t  function mapCacheDelete(key) {\n\t    var result = _getMapData(this, key)['delete'](key);\n\t    this.size -= result ? 1 : 0;\n\t    return result;\n\t  }\n\n\t  var _mapCacheDelete = mapCacheDelete;\n\n\t  /**\n\t   * Gets the map value for `key`.\n\t   *\n\t   * @private\n\t   * @name get\n\t   * @memberOf MapCache\n\t   * @param {string} key The key of the value to get.\n\t   * @returns {*} Returns the entry value.\n\t   */\n\t  function mapCacheGet(key) {\n\t    return _getMapData(this, key).get(key);\n\t  }\n\n\t  var _mapCacheGet = mapCacheGet;\n\n\t  /**\n\t   * Checks if a map value for `key` exists.\n\t   *\n\t   * @private\n\t   * @name has\n\t   * @memberOf MapCache\n\t   * @param {string} key The key of the entry to check.\n\t   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t   */\n\t  function mapCacheHas(key) {\n\t    return _getMapData(this, key).has(key);\n\t  }\n\n\t  var _mapCacheHas = mapCacheHas;\n\n\t  /**\n\t   * Sets the map `key` to `value`.\n\t   *\n\t   * @private\n\t   * @name set\n\t   * @memberOf MapCache\n\t   * @param {string} key The key of the value to set.\n\t   * @param {*} value The value to set.\n\t   * @returns {Object} Returns the map cache instance.\n\t   */\n\t  function mapCacheSet(key, value) {\n\t    var data = _getMapData(this, key),\n\t        size = data.size;\n\n\t    data.set(key, value);\n\t    this.size += data.size == size ? 0 : 1;\n\t    return this;\n\t  }\n\n\t  var _mapCacheSet = mapCacheSet;\n\n\t  /**\n\t   * Creates a map cache object to store key-value pairs.\n\t   *\n\t   * @private\n\t   * @constructor\n\t   * @param {Array} [entries] The key-value pairs to cache.\n\t   */\n\t  function MapCache(entries) {\n\t    var index = -1,\n\t        length = entries == null ? 0 : entries.length;\n\n\t    this.clear();\n\t    while (++index < length) {\n\t      var entry = entries[index];\n\t      this.set(entry[0], entry[1]);\n\t    }\n\t  }\n\n\t  // Add methods to `MapCache`.\n\t  MapCache.prototype.clear = _mapCacheClear;\n\t  MapCache.prototype['delete'] = _mapCacheDelete;\n\t  MapCache.prototype.get = _mapCacheGet;\n\t  MapCache.prototype.has = _mapCacheHas;\n\t  MapCache.prototype.set = _mapCacheSet;\n\n\t  var _MapCache = MapCache;\n\n\t  /** Used as the size to enable large array optimizations. */\n\t  var LARGE_ARRAY_SIZE = 200;\n\n\t  /**\n\t   * Sets the stack `key` to `value`.\n\t   *\n\t   * @private\n\t   * @name set\n\t   * @memberOf Stack\n\t   * @param {string} key The key of the value to set.\n\t   * @param {*} value The value to set.\n\t   * @returns {Object} Returns the stack cache instance.\n\t   */\n\t  function stackSet(key, value) {\n\t    var data = this.__data__;\n\t    if (data instanceof _ListCache) {\n\t      var pairs = data.__data__;\n\t      if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n\t        pairs.push([key, value]);\n\t        this.size = ++data.size;\n\t        return this;\n\t      }\n\t      data = this.__data__ = new _MapCache(pairs);\n\t    }\n\t    data.set(key, value);\n\t    this.size = data.size;\n\t    return this;\n\t  }\n\n\t  var _stackSet = stackSet;\n\n\t  /**\n\t   * Creates a stack cache object to store key-value pairs.\n\t   *\n\t   * @private\n\t   * @constructor\n\t   * @param {Array} [entries] The key-value pairs to cache.\n\t   */\n\t  function Stack(entries) {\n\t    var data = this.__data__ = new _ListCache(entries);\n\t    this.size = data.size;\n\t  }\n\n\t  // Add methods to `Stack`.\n\t  Stack.prototype.clear = _stackClear;\n\t  Stack.prototype['delete'] = _stackDelete;\n\t  Stack.prototype.get = _stackGet;\n\t  Stack.prototype.has = _stackHas;\n\t  Stack.prototype.set = _stackSet;\n\n\t  var _Stack = Stack;\n\n\t  var defineProperty = (function() {\n\t    try {\n\t      var func = _getNative(Object, 'defineProperty');\n\t      func({}, '', {});\n\t      return func;\n\t    } catch (e) {}\n\t  }());\n\n\t  var _defineProperty = defineProperty;\n\n\t  /**\n\t   * The base implementation of `assignValue` and `assignMergeValue` without\n\t   * value checks.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to modify.\n\t   * @param {string} key The key of the property to assign.\n\t   * @param {*} value The value to assign.\n\t   */\n\t  function baseAssignValue(object, key, value) {\n\t    if (key == '__proto__' && _defineProperty) {\n\t      _defineProperty(object, key, {\n\t        'configurable': true,\n\t        'enumerable': true,\n\t        'value': value,\n\t        'writable': true\n\t      });\n\t    } else {\n\t      object[key] = value;\n\t    }\n\t  }\n\n\t  var _baseAssignValue = baseAssignValue;\n\n\t  /**\n\t   * This function is like `assignValue` except that it doesn't assign\n\t   * `undefined` values.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to modify.\n\t   * @param {string} key The key of the property to assign.\n\t   * @param {*} value The value to assign.\n\t   */\n\t  function assignMergeValue(object, key, value) {\n\t    if ((value !== undefined && !eq_1(object[key], value)) ||\n\t        (value === undefined && !(key in object))) {\n\t      _baseAssignValue(object, key, value);\n\t    }\n\t  }\n\n\t  var _assignMergeValue = assignMergeValue;\n\n\t  /**\n\t   * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n\t   *\n\t   * @private\n\t   * @param {boolean} [fromRight] Specify iterating from right to left.\n\t   * @returns {Function} Returns the new base function.\n\t   */\n\t  function createBaseFor(fromRight) {\n\t    return function(object, iteratee, keysFunc) {\n\t      var index = -1,\n\t          iterable = Object(object),\n\t          props = keysFunc(object),\n\t          length = props.length;\n\n\t      while (length--) {\n\t        var key = props[fromRight ? length : ++index];\n\t        if (iteratee(iterable[key], key, iterable) === false) {\n\t          break;\n\t        }\n\t      }\n\t      return object;\n\t    };\n\t  }\n\n\t  var _createBaseFor = createBaseFor;\n\n\t  /**\n\t   * The base implementation of `baseForOwn` which iterates over `object`\n\t   * properties returned by `keysFunc` and invokes `iteratee` for each property.\n\t   * Iteratee functions may exit iteration early by explicitly returning `false`.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to iterate over.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @param {Function} keysFunc The function to get the keys of `object`.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  var baseFor = _createBaseFor();\n\n\t  var _baseFor = baseFor;\n\n\t  var _cloneBuffer = createCommonjsModule$$1(function (module, exports) {\n\t  /** Detect free variable `exports`. */\n\t  var freeExports =  true && exports && !exports.nodeType && exports;\n\n\t  /** Detect free variable `module`. */\n\t  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n\t  /** Built-in value references. */\n\t  var Buffer = moduleExports ? _root.Buffer : undefined,\n\t      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\n\n\t  /**\n\t   * Creates a clone of  `buffer`.\n\t   *\n\t   * @private\n\t   * @param {Buffer} buffer The buffer to clone.\n\t   * @param {boolean} [isDeep] Specify a deep clone.\n\t   * @returns {Buffer} Returns the cloned buffer.\n\t   */\n\t  function cloneBuffer(buffer, isDeep) {\n\t    if (isDeep) {\n\t      return buffer.slice();\n\t    }\n\t    var length = buffer.length,\n\t        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n\t    buffer.copy(result);\n\t    return result;\n\t  }\n\n\t  module.exports = cloneBuffer;\n\t  });\n\n\t  /** Built-in value references. */\n\t  var Uint8Array = _root.Uint8Array;\n\n\t  var _Uint8Array = Uint8Array;\n\n\t  /**\n\t   * Creates a clone of `arrayBuffer`.\n\t   *\n\t   * @private\n\t   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n\t   * @returns {ArrayBuffer} Returns the cloned array buffer.\n\t   */\n\t  function cloneArrayBuffer(arrayBuffer) {\n\t    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n\t    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));\n\t    return result;\n\t  }\n\n\t  var _cloneArrayBuffer = cloneArrayBuffer;\n\n\t  /**\n\t   * Creates a clone of `typedArray`.\n\t   *\n\t   * @private\n\t   * @param {Object} typedArray The typed array to clone.\n\t   * @param {boolean} [isDeep] Specify a deep clone.\n\t   * @returns {Object} Returns the cloned typed array.\n\t   */\n\t  function cloneTypedArray(typedArray, isDeep) {\n\t    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n\t    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n\t  }\n\n\t  var _cloneTypedArray = cloneTypedArray;\n\n\t  /**\n\t   * Copies the values of `source` to `array`.\n\t   *\n\t   * @private\n\t   * @param {Array} source The array to copy values from.\n\t   * @param {Array} [array=[]] The array to copy values to.\n\t   * @returns {Array} Returns `array`.\n\t   */\n\t  function copyArray(source, array) {\n\t    var index = -1,\n\t        length = source.length;\n\n\t    array || (array = Array(length));\n\t    while (++index < length) {\n\t      array[index] = source[index];\n\t    }\n\t    return array;\n\t  }\n\n\t  var _copyArray = copyArray;\n\n\t  /** Built-in value references. */\n\t  var objectCreate = Object.create;\n\n\t  /**\n\t   * The base implementation of `_.create` without support for assigning\n\t   * properties to the created object.\n\t   *\n\t   * @private\n\t   * @param {Object} proto The object to inherit from.\n\t   * @returns {Object} Returns the new object.\n\t   */\n\t  var baseCreate = (function() {\n\t    function object() {}\n\t    return function(proto) {\n\t      if (!isObject_1(proto)) {\n\t        return {};\n\t      }\n\t      if (objectCreate) {\n\t        return objectCreate(proto);\n\t      }\n\t      object.prototype = proto;\n\t      var result = new object;\n\t      object.prototype = undefined;\n\t      return result;\n\t    };\n\t  }());\n\n\t  var _baseCreate = baseCreate;\n\n\t  /**\n\t   * Creates a unary function that invokes `func` with its argument transformed.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to wrap.\n\t   * @param {Function} transform The argument transform.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function overArg(func, transform) {\n\t    return function(arg) {\n\t      return func(transform(arg));\n\t    };\n\t  }\n\n\t  var _overArg = overArg;\n\n\t  /** Built-in value references. */\n\t  var getPrototype = _overArg(Object.getPrototypeOf, Object);\n\n\t  var _getPrototype = getPrototype;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$5 = Object.prototype;\n\n\t  /**\n\t   * Checks if `value` is likely a prototype object.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n\t   */\n\t  function isPrototype(value) {\n\t    var Ctor = value && value.constructor,\n\t        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n\t    return value === proto;\n\t  }\n\n\t  var _isPrototype = isPrototype;\n\n\t  /**\n\t   * Initializes an object clone.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to clone.\n\t   * @returns {Object} Returns the initialized clone.\n\t   */\n\t  function initCloneObject(object) {\n\t    return (typeof object.constructor == 'function' && !_isPrototype(object))\n\t      ? _baseCreate(_getPrototype(object))\n\t      : {};\n\t  }\n\n\t  var _initCloneObject = initCloneObject;\n\n\t  /**\n\t   * Checks if `value` is object-like. A value is object-like if it's not `null`\n\t   * and has a `typeof` result of \"object\".\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n\t   * @example\n\t   *\n\t   * _.isObjectLike({});\n\t   * // => true\n\t   *\n\t   * _.isObjectLike([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isObjectLike(_.noop);\n\t   * // => false\n\t   *\n\t   * _.isObjectLike(null);\n\t   * // => false\n\t   */\n\t  function isObjectLike(value) {\n\t    return value != null && typeof value == 'object';\n\t  }\n\n\t  var isObjectLike_1 = isObjectLike;\n\n\t  /** `Object#toString` result references. */\n\t  var argsTag = '[object Arguments]';\n\n\t  /**\n\t   * The base implementation of `_.isArguments`.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t   */\n\t  function baseIsArguments(value) {\n\t    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;\n\t  }\n\n\t  var _baseIsArguments = baseIsArguments;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$6 = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$4 = objectProto$6.hasOwnProperty;\n\n\t  /** Built-in value references. */\n\t  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;\n\n\t  /**\n\t   * Checks if `value` is likely an `arguments` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 0.1.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n\t   *  else `false`.\n\t   * @example\n\t   *\n\t   * _.isArguments(function() { return arguments; }());\n\t   * // => true\n\t   *\n\t   * _.isArguments([1, 2, 3]);\n\t   * // => false\n\t   */\n\t  var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {\n\t    return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') &&\n\t      !propertyIsEnumerable.call(value, 'callee');\n\t  };\n\n\t  var isArguments_1 = isArguments;\n\n\t  /**\n\t   * Checks if `value` is classified as an `Array` object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 0.1.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n\t   * @example\n\t   *\n\t   * _.isArray([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isArray(document.body.children);\n\t   * // => false\n\t   *\n\t   * _.isArray('abc');\n\t   * // => false\n\t   *\n\t   * _.isArray(_.noop);\n\t   * // => false\n\t   */\n\t  var isArray = Array.isArray;\n\n\t  var isArray_1 = isArray;\n\n\t  /** Used as references for various `Number` constants. */\n\t  var MAX_SAFE_INTEGER = 9007199254740991;\n\n\t  /**\n\t   * Checks if `value` is a valid array-like length.\n\t   *\n\t   * **Note:** This method is loosely based on\n\t   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n\t   * @example\n\t   *\n\t   * _.isLength(3);\n\t   * // => true\n\t   *\n\t   * _.isLength(Number.MIN_VALUE);\n\t   * // => false\n\t   *\n\t   * _.isLength(Infinity);\n\t   * // => false\n\t   *\n\t   * _.isLength('3');\n\t   * // => false\n\t   */\n\t  function isLength(value) {\n\t    return typeof value == 'number' &&\n\t      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n\t  }\n\n\t  var isLength_1 = isLength;\n\n\t  /**\n\t   * Checks if `value` is array-like. A value is considered array-like if it's\n\t   * not a function and has a `value.length` that's an integer greater than or\n\t   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n\t   * @example\n\t   *\n\t   * _.isArrayLike([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isArrayLike(document.body.children);\n\t   * // => true\n\t   *\n\t   * _.isArrayLike('abc');\n\t   * // => true\n\t   *\n\t   * _.isArrayLike(_.noop);\n\t   * // => false\n\t   */\n\t  function isArrayLike(value) {\n\t    return value != null && isLength_1(value.length) && !isFunction_1(value);\n\t  }\n\n\t  var isArrayLike_1 = isArrayLike;\n\n\t  /**\n\t   * This method is like `_.isArrayLike` except that it also checks if `value`\n\t   * is an object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is an array-like object,\n\t   *  else `false`.\n\t   * @example\n\t   *\n\t   * _.isArrayLikeObject([1, 2, 3]);\n\t   * // => true\n\t   *\n\t   * _.isArrayLikeObject(document.body.children);\n\t   * // => true\n\t   *\n\t   * _.isArrayLikeObject('abc');\n\t   * // => false\n\t   *\n\t   * _.isArrayLikeObject(_.noop);\n\t   * // => false\n\t   */\n\t  function isArrayLikeObject(value) {\n\t    return isObjectLike_1(value) && isArrayLike_1(value);\n\t  }\n\n\t  var isArrayLikeObject_1 = isArrayLikeObject;\n\n\t  /**\n\t   * This method returns `false`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.13.0\n\t   * @category Util\n\t   * @returns {boolean} Returns `false`.\n\t   * @example\n\t   *\n\t   * _.times(2, _.stubFalse);\n\t   * // => [false, false]\n\t   */\n\t  function stubFalse() {\n\t    return false;\n\t  }\n\n\t  var stubFalse_1 = stubFalse;\n\n\t  var isBuffer_1 = createCommonjsModule$$1(function (module, exports) {\n\t  /** Detect free variable `exports`. */\n\t  var freeExports =  true && exports && !exports.nodeType && exports;\n\n\t  /** Detect free variable `module`. */\n\t  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n\t  /** Built-in value references. */\n\t  var Buffer = moduleExports ? _root.Buffer : undefined;\n\n\t  /* Built-in method references for those with the same name as other `lodash` methods. */\n\t  var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n\t  /**\n\t   * Checks if `value` is a buffer.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 4.3.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n\t   * @example\n\t   *\n\t   * _.isBuffer(new Buffer(2));\n\t   * // => true\n\t   *\n\t   * _.isBuffer(new Uint8Array(2));\n\t   * // => false\n\t   */\n\t  var isBuffer = nativeIsBuffer || stubFalse_1;\n\n\t  module.exports = isBuffer;\n\t  });\n\n\t  /** `Object#toString` result references. */\n\t  var objectTag = '[object Object]';\n\n\t  /** Used for built-in method references. */\n\t  var funcProto$2 = Function.prototype,\n\t      objectProto$7 = Object.prototype;\n\n\t  /** Used to resolve the decompiled source of functions. */\n\t  var funcToString$2 = funcProto$2.toString;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;\n\n\t  /** Used to infer the `Object` constructor. */\n\t  var objectCtorString = funcToString$2.call(Object);\n\n\t  /**\n\t   * Checks if `value` is a plain object, that is, an object created by the\n\t   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 0.8.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   * }\n\t   *\n\t   * _.isPlainObject(new Foo);\n\t   * // => false\n\t   *\n\t   * _.isPlainObject([1, 2, 3]);\n\t   * // => false\n\t   *\n\t   * _.isPlainObject({ 'x': 0, 'y': 0 });\n\t   * // => true\n\t   *\n\t   * _.isPlainObject(Object.create(null));\n\t   * // => true\n\t   */\n\t  function isPlainObject(value) {\n\t    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag) {\n\t      return false;\n\t    }\n\t    var proto = _getPrototype(value);\n\t    if (proto === null) {\n\t      return true;\n\t    }\n\t    var Ctor = hasOwnProperty$5.call(proto, 'constructor') && proto.constructor;\n\t    return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n\t      funcToString$2.call(Ctor) == objectCtorString;\n\t  }\n\n\t  var isPlainObject_1 = isPlainObject;\n\n\t  /** `Object#toString` result references. */\n\t  var argsTag$1 = '[object Arguments]',\n\t      arrayTag = '[object Array]',\n\t      boolTag = '[object Boolean]',\n\t      dateTag = '[object Date]',\n\t      errorTag = '[object Error]',\n\t      funcTag$1 = '[object Function]',\n\t      mapTag = '[object Map]',\n\t      numberTag = '[object Number]',\n\t      objectTag$1 = '[object Object]',\n\t      regexpTag = '[object RegExp]',\n\t      setTag = '[object Set]',\n\t      stringTag = '[object String]',\n\t      weakMapTag = '[object WeakMap]';\n\n\t  var arrayBufferTag = '[object ArrayBuffer]',\n\t      dataViewTag = '[object DataView]',\n\t      float32Tag = '[object Float32Array]',\n\t      float64Tag = '[object Float64Array]',\n\t      int8Tag = '[object Int8Array]',\n\t      int16Tag = '[object Int16Array]',\n\t      int32Tag = '[object Int32Array]',\n\t      uint8Tag = '[object Uint8Array]',\n\t      uint8ClampedTag = '[object Uint8ClampedArray]',\n\t      uint16Tag = '[object Uint16Array]',\n\t      uint32Tag = '[object Uint32Array]';\n\n\t  /** Used to identify `toStringTag` values of typed arrays. */\n\t  var typedArrayTags = {};\n\t  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n\t  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n\t  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n\t  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n\t  typedArrayTags[uint32Tag] = true;\n\t  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\n\t  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n\t  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n\t  typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\n\t  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n\t  typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =\n\t  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n\t  typedArrayTags[weakMapTag] = false;\n\n\t  /**\n\t   * The base implementation of `_.isTypedArray` without Node.js optimizations.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t   */\n\t  function baseIsTypedArray(value) {\n\t    return isObjectLike_1(value) &&\n\t      isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];\n\t  }\n\n\t  var _baseIsTypedArray = baseIsTypedArray;\n\n\t  /**\n\t   * The base implementation of `_.unary` without support for storing metadata.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to cap arguments for.\n\t   * @returns {Function} Returns the new capped function.\n\t   */\n\t  function baseUnary(func) {\n\t    return function(value) {\n\t      return func(value);\n\t    };\n\t  }\n\n\t  var _baseUnary = baseUnary;\n\n\t  var _nodeUtil = createCommonjsModule$$1(function (module, exports) {\n\t  /** Detect free variable `exports`. */\n\t  var freeExports =  true && exports && !exports.nodeType && exports;\n\n\t  /** Detect free variable `module`. */\n\t  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n\n\t  /** Detect the popular CommonJS extension `module.exports`. */\n\t  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n\t  /** Detect free variable `process` from Node.js. */\n\t  var freeProcess = moduleExports && _freeGlobal.process;\n\n\t  /** Used to access faster Node.js helpers. */\n\t  var nodeUtil = (function() {\n\t    try {\n\t      // Use `util.types` for Node.js 10+.\n\t      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n\t      if (types) {\n\t        return types;\n\t      }\n\n\t      // Legacy `process.binding('util')` for Node.js < 10.\n\t      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n\t    } catch (e) {}\n\t  }());\n\n\t  module.exports = nodeUtil;\n\t  });\n\n\t  /* Node.js helper references. */\n\t  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;\n\n\t  /**\n\t   * Checks if `value` is classified as a typed array.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 3.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to check.\n\t   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n\t   * @example\n\t   *\n\t   * _.isTypedArray(new Uint8Array);\n\t   * // => true\n\t   *\n\t   * _.isTypedArray([]);\n\t   * // => false\n\t   */\n\t  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;\n\n\t  var isTypedArray_1 = isTypedArray;\n\n\t  /**\n\t   * Gets the value at `key`, unless `key` is \"__proto__\".\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @param {string} key The key of the property to get.\n\t   * @returns {*} Returns the property value.\n\t   */\n\t  function safeGet(object, key) {\n\t    return key == '__proto__'\n\t      ? undefined\n\t      : object[key];\n\t  }\n\n\t  var _safeGet = safeGet;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$8 = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;\n\n\t  /**\n\t   * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t   * for equality comparisons.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to modify.\n\t   * @param {string} key The key of the property to assign.\n\t   * @param {*} value The value to assign.\n\t   */\n\t  function assignValue(object, key, value) {\n\t    var objValue = object[key];\n\t    if (!(hasOwnProperty$6.call(object, key) && eq_1(objValue, value)) ||\n\t        (value === undefined && !(key in object))) {\n\t      _baseAssignValue(object, key, value);\n\t    }\n\t  }\n\n\t  var _assignValue = assignValue;\n\n\t  /**\n\t   * Copies properties of `source` to `object`.\n\t   *\n\t   * @private\n\t   * @param {Object} source The object to copy properties from.\n\t   * @param {Array} props The property identifiers to copy.\n\t   * @param {Object} [object={}] The object to copy properties to.\n\t   * @param {Function} [customizer] The function to customize copied values.\n\t   * @returns {Object} Returns `object`.\n\t   */\n\t  function copyObject(source, props, object, customizer) {\n\t    var isNew = !object;\n\t    object || (object = {});\n\n\t    var index = -1,\n\t        length = props.length;\n\n\t    while (++index < length) {\n\t      var key = props[index];\n\n\t      var newValue = customizer\n\t        ? customizer(object[key], source[key], key, object, source)\n\t        : undefined;\n\n\t      if (newValue === undefined) {\n\t        newValue = source[key];\n\t      }\n\t      if (isNew) {\n\t        _baseAssignValue(object, key, newValue);\n\t      } else {\n\t        _assignValue(object, key, newValue);\n\t      }\n\t    }\n\t    return object;\n\t  }\n\n\t  var _copyObject = copyObject;\n\n\t  /**\n\t   * The base implementation of `_.times` without support for iteratee shorthands\n\t   * or max array length checks.\n\t   *\n\t   * @private\n\t   * @param {number} n The number of times to invoke `iteratee`.\n\t   * @param {Function} iteratee The function invoked per iteration.\n\t   * @returns {Array} Returns the array of results.\n\t   */\n\t  function baseTimes(n, iteratee) {\n\t    var index = -1,\n\t        result = Array(n);\n\n\t    while (++index < n) {\n\t      result[index] = iteratee(index);\n\t    }\n\t    return result;\n\t  }\n\n\t  var _baseTimes = baseTimes;\n\n\t  /** Used as references for various `Number` constants. */\n\t  var MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n\t  /** Used to detect unsigned integer values. */\n\t  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n\t  /**\n\t   * Checks if `value` is a valid array-like index.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to check.\n\t   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t   */\n\t  function isIndex(value, length) {\n\t    var type = typeof value;\n\t    length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n\t    return !!length &&\n\t      (type == 'number' ||\n\t        (type != 'symbol' && reIsUint.test(value))) &&\n\t          (value > -1 && value % 1 == 0 && value < length);\n\t  }\n\n\t  var _isIndex = isIndex;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$9 = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;\n\n\t  /**\n\t   * Creates an array of the enumerable property names of the array-like `value`.\n\t   *\n\t   * @private\n\t   * @param {*} value The value to query.\n\t   * @param {boolean} inherited Specify returning inherited property names.\n\t   * @returns {Array} Returns the array of property names.\n\t   */\n\t  function arrayLikeKeys(value, inherited) {\n\t    var isArr = isArray_1(value),\n\t        isArg = !isArr && isArguments_1(value),\n\t        isBuff = !isArr && !isArg && isBuffer_1(value),\n\t        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),\n\t        skipIndexes = isArr || isArg || isBuff || isType,\n\t        result = skipIndexes ? _baseTimes(value.length, String) : [],\n\t        length = result.length;\n\n\t    for (var key in value) {\n\t      if ((inherited || hasOwnProperty$7.call(value, key)) &&\n\t          !(skipIndexes && (\n\t             // Safari 9 has enumerable `arguments.length` in strict mode.\n\t             key == 'length' ||\n\t             // Node.js 0.10 has enumerable non-index properties on buffers.\n\t             (isBuff && (key == 'offset' || key == 'parent')) ||\n\t             // PhantomJS 2 has enumerable non-index properties on typed arrays.\n\t             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n\t             // Skip index properties.\n\t             _isIndex(key, length)\n\t          ))) {\n\t        result.push(key);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\n\t  var _arrayLikeKeys = arrayLikeKeys;\n\n\t  /**\n\t   * This function is like\n\t   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n\t   * except that it includes inherited enumerable properties.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property names.\n\t   */\n\t  function nativeKeysIn(object) {\n\t    var result = [];\n\t    if (object != null) {\n\t      for (var key in Object(object)) {\n\t        result.push(key);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\n\t  var _nativeKeysIn = nativeKeysIn;\n\n\t  /** Used for built-in method references. */\n\t  var objectProto$10 = Object.prototype;\n\n\t  /** Used to check objects for own properties. */\n\t  var hasOwnProperty$8 = objectProto$10.hasOwnProperty;\n\n\t  /**\n\t   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n\t   *\n\t   * @private\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property names.\n\t   */\n\t  function baseKeysIn(object) {\n\t    if (!isObject_1(object)) {\n\t      return _nativeKeysIn(object);\n\t    }\n\t    var isProto = _isPrototype(object),\n\t        result = [];\n\n\t    for (var key in object) {\n\t      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {\n\t        result.push(key);\n\t      }\n\t    }\n\t    return result;\n\t  }\n\n\t  var _baseKeysIn = baseKeysIn;\n\n\t  /**\n\t   * Creates an array of the own and inherited enumerable property names of `object`.\n\t   *\n\t   * **Note:** Non-object values are coerced to objects.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 3.0.0\n\t   * @category Object\n\t   * @param {Object} object The object to query.\n\t   * @returns {Array} Returns the array of property names.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.a = 1;\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.keysIn(new Foo);\n\t   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n\t   */\n\t  function keysIn(object) {\n\t    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);\n\t  }\n\n\t  var keysIn_1 = keysIn;\n\n\t  /**\n\t   * Converts `value` to a plain object flattening inherited enumerable string\n\t   * keyed properties of `value` to own properties of the plain object.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 3.0.0\n\t   * @category Lang\n\t   * @param {*} value The value to convert.\n\t   * @returns {Object} Returns the converted plain object.\n\t   * @example\n\t   *\n\t   * function Foo() {\n\t   *   this.b = 2;\n\t   * }\n\t   *\n\t   * Foo.prototype.c = 3;\n\t   *\n\t   * _.assign({ 'a': 1 }, new Foo);\n\t   * // => { 'a': 1, 'b': 2 }\n\t   *\n\t   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n\t   * // => { 'a': 1, 'b': 2, 'c': 3 }\n\t   */\n\t  function toPlainObject(value) {\n\t    return _copyObject(value, keysIn_1(value));\n\t  }\n\n\t  var toPlainObject_1 = toPlainObject;\n\n\t  /**\n\t   * A specialized version of `baseMerge` for arrays and objects which performs\n\t   * deep merges and tracks traversed objects enabling objects with circular\n\t   * references to be merged.\n\t   *\n\t   * @private\n\t   * @param {Object} object The destination object.\n\t   * @param {Object} source The source object.\n\t   * @param {string} key The key of the value to merge.\n\t   * @param {number} srcIndex The index of `source`.\n\t   * @param {Function} mergeFunc The function to merge values.\n\t   * @param {Function} [customizer] The function to customize assigned values.\n\t   * @param {Object} [stack] Tracks traversed source values and their merged\n\t   *  counterparts.\n\t   */\n\t  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n\t    var objValue = _safeGet(object, key),\n\t        srcValue = _safeGet(source, key),\n\t        stacked = stack.get(srcValue);\n\n\t    if (stacked) {\n\t      _assignMergeValue(object, key, stacked);\n\t      return;\n\t    }\n\t    var newValue = customizer\n\t      ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n\t      : undefined;\n\n\t    var isCommon = newValue === undefined;\n\n\t    if (isCommon) {\n\t      var isArr = isArray_1(srcValue),\n\t          isBuff = !isArr && isBuffer_1(srcValue),\n\t          isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);\n\n\t      newValue = srcValue;\n\t      if (isArr || isBuff || isTyped) {\n\t        if (isArray_1(objValue)) {\n\t          newValue = objValue;\n\t        }\n\t        else if (isArrayLikeObject_1(objValue)) {\n\t          newValue = _copyArray(objValue);\n\t        }\n\t        else if (isBuff) {\n\t          isCommon = false;\n\t          newValue = _cloneBuffer(srcValue, true);\n\t        }\n\t        else if (isTyped) {\n\t          isCommon = false;\n\t          newValue = _cloneTypedArray(srcValue, true);\n\t        }\n\t        else {\n\t          newValue = [];\n\t        }\n\t      }\n\t      else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {\n\t        newValue = objValue;\n\t        if (isArguments_1(objValue)) {\n\t          newValue = toPlainObject_1(objValue);\n\t        }\n\t        else if (!isObject_1(objValue) || (srcIndex && isFunction_1(objValue))) {\n\t          newValue = _initCloneObject(srcValue);\n\t        }\n\t      }\n\t      else {\n\t        isCommon = false;\n\t      }\n\t    }\n\t    if (isCommon) {\n\t      // Recursively merge objects and arrays (susceptible to call stack limits).\n\t      stack.set(srcValue, newValue);\n\t      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n\t      stack['delete'](srcValue);\n\t    }\n\t    _assignMergeValue(object, key, newValue);\n\t  }\n\n\t  var _baseMergeDeep = baseMergeDeep;\n\n\t  /**\n\t   * The base implementation of `_.merge` without support for multiple sources.\n\t   *\n\t   * @private\n\t   * @param {Object} object The destination object.\n\t   * @param {Object} source The source object.\n\t   * @param {number} srcIndex The index of `source`.\n\t   * @param {Function} [customizer] The function to customize merged values.\n\t   * @param {Object} [stack] Tracks traversed source values and their merged\n\t   *  counterparts.\n\t   */\n\t  function baseMerge(object, source, srcIndex, customizer, stack) {\n\t    if (object === source) {\n\t      return;\n\t    }\n\t    _baseFor(source, function(srcValue, key) {\n\t      if (isObject_1(srcValue)) {\n\t        stack || (stack = new _Stack);\n\t        _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n\t      }\n\t      else {\n\t        var newValue = customizer\n\t          ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)\n\t          : undefined;\n\n\t        if (newValue === undefined) {\n\t          newValue = srcValue;\n\t        }\n\t        _assignMergeValue(object, key, newValue);\n\t      }\n\t    }, keysIn_1);\n\t  }\n\n\t  var _baseMerge = baseMerge;\n\n\t  /**\n\t   * This method returns the first argument it receives.\n\t   *\n\t   * @static\n\t   * @since 0.1.0\n\t   * @memberOf _\n\t   * @category Util\n\t   * @param {*} value Any value.\n\t   * @returns {*} Returns `value`.\n\t   * @example\n\t   *\n\t   * var object = { 'a': 1 };\n\t   *\n\t   * console.log(_.identity(object) === object);\n\t   * // => true\n\t   */\n\t  function identity(value) {\n\t    return value;\n\t  }\n\n\t  var identity_1 = identity;\n\n\t  /**\n\t   * A faster alternative to `Function#apply`, this function invokes `func`\n\t   * with the `this` binding of `thisArg` and the arguments of `args`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to invoke.\n\t   * @param {*} thisArg The `this` binding of `func`.\n\t   * @param {Array} args The arguments to invoke `func` with.\n\t   * @returns {*} Returns the result of `func`.\n\t   */\n\t  function apply(func, thisArg, args) {\n\t    switch (args.length) {\n\t      case 0: return func.call(thisArg);\n\t      case 1: return func.call(thisArg, args[0]);\n\t      case 2: return func.call(thisArg, args[0], args[1]);\n\t      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n\t    }\n\t    return func.apply(thisArg, args);\n\t  }\n\n\t  var _apply = apply;\n\n\t  /* Built-in method references for those with the same name as other `lodash` methods. */\n\t  var nativeMax = Math.max;\n\n\t  /**\n\t   * A specialized version of `baseRest` which transforms the rest array.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to apply a rest parameter to.\n\t   * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t   * @param {Function} transform The rest array transform.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function overRest(func, start, transform) {\n\t    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n\t    return function() {\n\t      var args = arguments,\n\t          index = -1,\n\t          length = nativeMax(args.length - start, 0),\n\t          array = Array(length);\n\n\t      while (++index < length) {\n\t        array[index] = args[start + index];\n\t      }\n\t      index = -1;\n\t      var otherArgs = Array(start + 1);\n\t      while (++index < start) {\n\t        otherArgs[index] = args[index];\n\t      }\n\t      otherArgs[start] = transform(array);\n\t      return _apply(func, this, otherArgs);\n\t    };\n\t  }\n\n\t  var _overRest = overRest;\n\n\t  /**\n\t   * Creates a function that returns `value`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 2.4.0\n\t   * @category Util\n\t   * @param {*} value The value to return from the new function.\n\t   * @returns {Function} Returns the new constant function.\n\t   * @example\n\t   *\n\t   * var objects = _.times(2, _.constant({ 'a': 1 }));\n\t   *\n\t   * console.log(objects);\n\t   * // => [{ 'a': 1 }, { 'a': 1 }]\n\t   *\n\t   * console.log(objects[0] === objects[1]);\n\t   * // => true\n\t   */\n\t  function constant(value) {\n\t    return function() {\n\t      return value;\n\t    };\n\t  }\n\n\t  var constant_1 = constant;\n\n\t  /**\n\t   * The base implementation of `setToString` without support for hot loop shorting.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to modify.\n\t   * @param {Function} string The `toString` result.\n\t   * @returns {Function} Returns `func`.\n\t   */\n\t  var baseSetToString = !_defineProperty ? identity_1 : function(func, string) {\n\t    return _defineProperty(func, 'toString', {\n\t      'configurable': true,\n\t      'enumerable': false,\n\t      'value': constant_1(string),\n\t      'writable': true\n\t    });\n\t  };\n\n\t  var _baseSetToString = baseSetToString;\n\n\t  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n\t  var HOT_COUNT = 800,\n\t      HOT_SPAN = 16;\n\n\t  /* Built-in method references for those with the same name as other `lodash` methods. */\n\t  var nativeNow = Date.now;\n\n\t  /**\n\t   * Creates a function that'll short out and invoke `identity` instead\n\t   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n\t   * milliseconds.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to restrict.\n\t   * @returns {Function} Returns the new shortable function.\n\t   */\n\t  function shortOut(func) {\n\t    var count = 0,\n\t        lastCalled = 0;\n\n\t    return function() {\n\t      var stamp = nativeNow(),\n\t          remaining = HOT_SPAN - (stamp - lastCalled);\n\n\t      lastCalled = stamp;\n\t      if (remaining > 0) {\n\t        if (++count >= HOT_COUNT) {\n\t          return arguments[0];\n\t        }\n\t      } else {\n\t        count = 0;\n\t      }\n\t      return func.apply(undefined, arguments);\n\t    };\n\t  }\n\n\t  var _shortOut = shortOut;\n\n\t  /**\n\t   * Sets the `toString` method of `func` to return `string`.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to modify.\n\t   * @param {Function} string The `toString` result.\n\t   * @returns {Function} Returns `func`.\n\t   */\n\t  var setToString = _shortOut(_baseSetToString);\n\n\t  var _setToString = setToString;\n\n\t  /**\n\t   * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n\t   *\n\t   * @private\n\t   * @param {Function} func The function to apply a rest parameter to.\n\t   * @param {number} [start=func.length-1] The start position of the rest parameter.\n\t   * @returns {Function} Returns the new function.\n\t   */\n\t  function baseRest(func, start) {\n\t    return _setToString(_overRest(func, start, identity_1), func + '');\n\t  }\n\n\t  var _baseRest = baseRest;\n\n\t  /**\n\t   * Checks if the given arguments are from an iteratee call.\n\t   *\n\t   * @private\n\t   * @param {*} value The potential iteratee value argument.\n\t   * @param {*} index The potential iteratee index or key argument.\n\t   * @param {*} object The potential iteratee object argument.\n\t   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n\t   *  else `false`.\n\t   */\n\t  function isIterateeCall(value, index, object) {\n\t    if (!isObject_1(object)) {\n\t      return false;\n\t    }\n\t    var type = typeof index;\n\t    if (type == 'number'\n\t          ? (isArrayLike_1(object) && _isIndex(index, object.length))\n\t          : (type == 'string' && index in object)\n\t        ) {\n\t      return eq_1(object[index], value);\n\t    }\n\t    return false;\n\t  }\n\n\t  var _isIterateeCall = isIterateeCall;\n\n\t  /**\n\t   * Creates a function like `_.assign`.\n\t   *\n\t   * @private\n\t   * @param {Function} assigner The function to assign values.\n\t   * @returns {Function} Returns the new assigner function.\n\t   */\n\t  function createAssigner(assigner) {\n\t    return _baseRest(function(object, sources) {\n\t      var index = -1,\n\t          length = sources.length,\n\t          customizer = length > 1 ? sources[length - 1] : undefined,\n\t          guard = length > 2 ? sources[2] : undefined;\n\n\t      customizer = (assigner.length > 3 && typeof customizer == 'function')\n\t        ? (length--, customizer)\n\t        : undefined;\n\n\t      if (guard && _isIterateeCall(sources[0], sources[1], guard)) {\n\t        customizer = length < 3 ? undefined : customizer;\n\t        length = 1;\n\t      }\n\t      object = Object(object);\n\t      while (++index < length) {\n\t        var source = sources[index];\n\t        if (source) {\n\t          assigner(object, source, index, customizer);\n\t        }\n\t      }\n\t      return object;\n\t    });\n\t  }\n\n\t  var _createAssigner = createAssigner;\n\n\t  /**\n\t   * This method is like `_.assign` except that it recursively merges own and\n\t   * inherited enumerable string keyed properties of source objects into the\n\t   * destination object. Source properties that resolve to `undefined` are\n\t   * skipped if a destination value exists. Array and plain object properties\n\t   * are merged recursively. Other objects and value types are overridden by\n\t   * assignment. Source objects are applied from left to right. Subsequent\n\t   * sources overwrite property assignments of previous sources.\n\t   *\n\t   * **Note:** This method mutates `object`.\n\t   *\n\t   * @static\n\t   * @memberOf _\n\t   * @since 0.5.0\n\t   * @category Object\n\t   * @param {Object} object The destination object.\n\t   * @param {...Object} [sources] The source objects.\n\t   * @returns {Object} Returns `object`.\n\t   * @example\n\t   *\n\t   * var object = {\n\t   *   'a': [{ 'b': 2 }, { 'd': 4 }]\n\t   * };\n\t   *\n\t   * var other = {\n\t   *   'a': [{ 'c': 3 }, { 'e': 5 }]\n\t   * };\n\t   *\n\t   * _.merge(object, other);\n\t   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n\t   */\n\t  var merge = _createAssigner(function(object, source, srcIndex) {\n\t    _baseMerge(object, source, srcIndex);\n\t  });\n\n\t  var merge_1 = merge;\n\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  var script = {};\n\n\t  /* script */\n\t              var __vue_script__ = script;\n\t              \n\t  /* template */\n\t  var __vue_render__ = function() {\n\t    var _vm = this;\n\t    var _h = _vm.$createElement;\n\t    var _c = _vm._self._c || _h;\n\t    return _c(\"div\", { staticClass: \"dialog-layout\" }, [_vm._t(\"default\")], 2)\n\t  };\n\t  var __vue_staticRenderFns__ = [];\n\t  __vue_render__._withStripped = true;\n\n\t    /* style */\n\t    var __vue_inject_styles__ = undefined;\n\t    /* scoped */\n\t    var __vue_scope_id__ = undefined;\n\t    /* module identifier */\n\t    var __vue_module_identifier__ = undefined;\n\t    /* functional template */\n\t    var __vue_is_functional_template__ = false;\n\t    /* component normalizer */\n\t    function __vue_normalize__(\n\t      template, style, script$$1,\n\t      scope, functional, moduleIdentifier,\n\t      createInjector, createInjectorSSR\n\t    ) {\n\t      var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};\n\n\t      // For security concerns, we use only base name in production mode.\n\t      component.__file = \"/Users/yarik/Projects/clones/vuedl/src/components/DefaultLayout.vue\";\n\n\t      if (!component.render) {\n\t        component.render = template.render;\n\t        component.staticRenderFns = template.staticRenderFns;\n\t        component._compiled = true;\n\n\t        if (functional) { component.functional = true; }\n\t      }\n\n\t      component._scopeId = scope;\n\n\t      \n\n\t      return component\n\t    }\n\t    /* style inject */\n\t    function __vue_create_injector__() {\n\t      var head = document.head || document.getElementsByTagName('head')[0];\n\t      var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});\n\t      var isOldIE =\n\t        typeof navigator !== 'undefined' &&\n\t        /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t      return function addStyle(id, css) {\n\t        if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t        var group = isOldIE ? css.media || 'default' : id;\n\t        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t        if (!style.ids.includes(id)) {\n\t          var code = css.source;\n\t          var index = style.ids.length;\n\n\t          style.ids.push(id);\n\n\t          if (isOldIE) {\n\t            style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t          }\n\n\t          if (!style.element) {\n\t            var el = style.element = document.createElement('style');\n\t            el.type = 'text/css';\n\n\t            if (css.media) { el.setAttribute('media', css.media); }\n\t            if (isOldIE) {\n\t              el.setAttribute('data-group', group);\n\t              el.setAttribute('data-next-index', '0');\n\t            }\n\n\t            head.appendChild(el);\n\t          }\n\n\t          if (isOldIE) {\n\t            index = parseInt(style.element.getAttribute('data-next-index'));\n\t            style.element.setAttribute('data-next-index', index + 1);\n\t          }\n\n\t          if (style.element.styleSheet) {\n\t            style.parts.push(code);\n\t            style.element.styleSheet.cssText = style.parts\n\t              .filter(Boolean)\n\t              .join('\\n');\n\t          } else {\n\t            var textNode = document.createTextNode(code);\n\t            var nodes = style.element.childNodes;\n\t            if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t            else { style.element.appendChild(textNode); }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    /* style inject SSR */\n\t    \n\n\t    \n\t    var DefaultLayout = __vue_normalize__(\n\t      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },\n\t      __vue_inject_styles__,\n\t      __vue_script__,\n\t      __vue_scope_id__,\n\t      __vue_is_functional_template__,\n\t      __vue_module_identifier__,\n\t      __vue_create_injector__,\n\t      undefined\n\t    );\n\n\t  /*\n\t   * vuedl\n\t   *\n\t   * (c) Savaryn Yaroslav <yariksav@gmail.com>\n\t   *\n\t   * Some functions was imported from nuxt.js/lib/app/utils.js\n\t   * For the full copyright and license information, please view the LICENSE\n\t   * file that was distributed with this source code.\n\t  */\n\n\t  var noopData = function () { return ({}); };\n\n\t  function promisify(fn, context) {\n\t    var promise;\n\n\t    if (fn.length === 2) {\n\t      // fn(context, callback)\n\t      promise = new Promise(function (resolve) {\n\t        fn(context, function (err, data) {\n\t          if (err) {\n\t            context.error(err);\n\t          }\n\n\t          data = data || {};\n\t          resolve(data);\n\t        });\n\t      });\n\t    } else {\n\t      promise = fn(context);\n\t    }\n\n\t    if (!promise || !(promise instanceof Promise) && typeof promise.then !== 'function') {\n\t      promise = Promise.resolve(promise);\n\t    }\n\n\t    return promise;\n\t  }\n\t  function destroyVueElement(vm) {\n\t    if (vm && !vm._isDestroyed && typeof vm.$destroy === 'function') {\n\t      vm.$destroy();\n\t    }\n\t  }\n\t  function findContainer(container) {\n\t    var found;\n\n\t    if (typeof container === 'string') {\n\t      found = document.querySelector(container);\n\t    } else {\n\t      found = container;\n\t    }\n\n\t    if (!found) {\n\t      found = document.body;\n\t    }\n\n\t    return found;\n\t  }\n\t  function applyAsyncData(Component, asyncData) {\n\t    var ComponentData = Component.options.data || noopData; // Prevent calling this method for each request on SSR context\n\n\t    if (!asyncData && Component.options.hasAsyncData) {\n\t      return;\n\t    }\n\n\t    Component.options.hasAsyncData = true;\n\n\t    Component.options.data = function () {\n\t      var data = ComponentData.call(this);\n\n\t      if (this.$ssrContext) {\n\t        asyncData = this.$ssrContext.asyncData[Component.cid];\n\t      }\n\n\t      return Object.assign({}, data, asyncData);\n\t    };\n\n\t    if (Component._Ctor && Component._Ctor.options) {\n\t      Component._Ctor.options.data = Component.options.data;\n\t    }\n\t  }\n\t  function ensureAsyncDatas(components, context) {\n\t    return new Promise(function ($return, $error) {\n\t      if (!Array.isArray(components)) {\n\t        if (!components) {\n\t          return $return(null);\n\t        } else {\n\t          components = [components];\n\t        }\n\t      }\n\n\t      return $return(Promise.all(components.map(function (Component) {\n\t        var promises = []; // Call asyncData(context)\n\n\t        if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {\n\t          var promise = promisify(Component.options.asyncData, context);\n\t          promise.then(function (asyncDataResult) {\n\t            // ssrContext.asyncData[Component.cid] = asyncDataResult\n\t            applyAsyncData(Component, asyncDataResult);\n\t            return asyncDataResult;\n\t          });\n\t          promises.push(promise);\n\t        } else {\n\t          promises.push(null);\n\t        } // Call fetch(context)\n\n\n\t        if (Component.options.fetch) {\n\t          promises.push(Component.options.fetch(context));\n\t        } else {\n\t          promises.push(null);\n\t        }\n\n\t        return Promise.all(promises);\n\t      })));\n\t    });\n\t  }\n\n\t  /**\n\t   * Helpers.\n\t   */\n\n\t  var s = 1000;\n\t  var m = s * 60;\n\t  var h = m * 60;\n\t  var d = h * 24;\n\t  var y = d * 365.25;\n\n\t  /**\n\t   * Parse or format the given `val`.\n\t   *\n\t   * Options:\n\t   *\n\t   *  - `long` verbose formatting [false]\n\t   *\n\t   * @param {String|Number} val\n\t   * @param {Object} [options]\n\t   * @throws {Error} throw an error if val is not a non-empty string or a number\n\t   * @return {String|Number}\n\t   * @api public\n\t   */\n\n\t  var ms = function(val, options) {\n\t    options = options || {};\n\t    var type = typeof val;\n\t    if (type === 'string' && val.length > 0) {\n\t      return parse(val);\n\t    } else if (type === 'number' && isNaN(val) === false) {\n\t      return options.long ? fmtLong(val) : fmtShort(val);\n\t    }\n\t    throw new Error(\n\t      'val is not a non-empty string or a valid number. val=' +\n\t        JSON.stringify(val)\n\t    );\n\t  };\n\n\t  /**\n\t   * Parse the given `str` and return milliseconds.\n\t   *\n\t   * @param {String} str\n\t   * @return {Number}\n\t   * @api private\n\t   */\n\n\t  function parse(str) {\n\t    str = String(str);\n\t    if (str.length > 100) {\n\t      return;\n\t    }\n\t    var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n\t      str\n\t    );\n\t    if (!match) {\n\t      return;\n\t    }\n\t    var n = parseFloat(match[1]);\n\t    var type = (match[2] || 'ms').toLowerCase();\n\t    switch (type) {\n\t      case 'years':\n\t      case 'year':\n\t      case 'yrs':\n\t      case 'yr':\n\t      case 'y':\n\t        return n * y;\n\t      case 'days':\n\t      case 'day':\n\t      case 'd':\n\t        return n * d;\n\t      case 'hours':\n\t      case 'hour':\n\t      case 'hrs':\n\t      case 'hr':\n\t      case 'h':\n\t        return n * h;\n\t      case 'minutes':\n\t      case 'minute':\n\t      case 'mins':\n\t      case 'min':\n\t      case 'm':\n\t        return n * m;\n\t      case 'seconds':\n\t      case 'second':\n\t      case 'secs':\n\t      case 'sec':\n\t      case 's':\n\t        return n * s;\n\t      case 'milliseconds':\n\t      case 'millisecond':\n\t      case 'msecs':\n\t      case 'msec':\n\t      case 'ms':\n\t        return n;\n\t      default:\n\t        return undefined;\n\t    }\n\t  }\n\n\t  /**\n\t   * Short format for `ms`.\n\t   *\n\t   * @param {Number} ms\n\t   * @return {String}\n\t   * @api private\n\t   */\n\n\t  function fmtShort(ms) {\n\t    if (ms >= d) {\n\t      return Math.round(ms / d) + 'd';\n\t    }\n\t    if (ms >= h) {\n\t      return Math.round(ms / h) + 'h';\n\t    }\n\t    if (ms >= m) {\n\t      return Math.round(ms / m) + 'm';\n\t    }\n\t    if (ms >= s) {\n\t      return Math.round(ms / s) + 's';\n\t    }\n\t    return ms + 'ms';\n\t  }\n\n\t  /**\n\t   * Long format for `ms`.\n\t   *\n\t   * @param {Number} ms\n\t   * @return {String}\n\t   * @api private\n\t   */\n\n\t  function fmtLong(ms) {\n\t    return plural(ms, d, 'day') ||\n\t      plural(ms, h, 'hour') ||\n\t      plural(ms, m, 'minute') ||\n\t      plural(ms, s, 'second') ||\n\t      ms + ' ms';\n\t  }\n\n\t  /**\n\t   * Pluralization helper.\n\t   */\n\n\t  function plural(ms, n, name) {\n\t    if (ms < n) {\n\t      return;\n\t    }\n\t    if (ms < n * 1.5) {\n\t      return Math.floor(ms / n) + ' ' + name;\n\t    }\n\t    return Math.ceil(ms / n) + ' ' + name + 's';\n\t  }\n\n\t  var debug = createCommonjsModule$$1(function (module, exports) {\n\t  /**\n\t   * This is the common logic for both the Node.js and web browser\n\t   * implementations of `debug()`.\n\t   *\n\t   * Expose `debug()` as the module.\n\t   */\n\n\t  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\n\t  exports.coerce = coerce;\n\t  exports.disable = disable;\n\t  exports.enable = enable;\n\t  exports.enabled = enabled;\n\t  exports.humanize = ms;\n\n\t  /**\n\t   * Active `debug` instances.\n\t   */\n\t  exports.instances = [];\n\n\t  /**\n\t   * The currently active debug mode names, and names to skip.\n\t   */\n\n\t  exports.names = [];\n\t  exports.skips = [];\n\n\t  /**\n\t   * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t   *\n\t   * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t   */\n\n\t  exports.formatters = {};\n\n\t  /**\n\t   * Select a color.\n\t   * @param {String} namespace\n\t   * @return {Number}\n\t   * @api private\n\t   */\n\n\t  function selectColor(namespace) {\n\t    var hash = 0, i;\n\n\t    for (i in namespace) {\n\t      hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t      hash |= 0; // Convert to 32bit integer\n\t    }\n\n\t    return exports.colors[Math.abs(hash) % exports.colors.length];\n\t  }\n\n\t  /**\n\t   * Create a debugger with the given `namespace`.\n\t   *\n\t   * @param {String} namespace\n\t   * @return {Function}\n\t   * @api public\n\t   */\n\n\t  function createDebug(namespace) {\n\n\t    var prevTime;\n\n\t    function debug() {\n\t      // disabled?\n\t      if (!debug.enabled) return;\n\n\t      var self = debug;\n\n\t      // set `diff` timestamp\n\t      var curr = +new Date();\n\t      var ms$$1 = curr - (prevTime || curr);\n\t      self.diff = ms$$1;\n\t      self.prev = prevTime;\n\t      self.curr = curr;\n\t      prevTime = curr;\n\n\t      // turn the `arguments` into a proper Array\n\t      var args = new Array(arguments.length);\n\t      for (var i = 0; i < args.length; i++) {\n\t        args[i] = arguments[i];\n\t      }\n\n\t      args[0] = exports.coerce(args[0]);\n\n\t      if ('string' !== typeof args[0]) {\n\t        // anything else let's inspect with %O\n\t        args.unshift('%O');\n\t      }\n\n\t      // apply any `formatters` transformations\n\t      var index = 0;\n\t      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n\t        // if we encounter an escaped % then don't increase the array index\n\t        if (match === '%%') return match;\n\t        index++;\n\t        var formatter = exports.formatters[format];\n\t        if ('function' === typeof formatter) {\n\t          var val = args[index];\n\t          match = formatter.call(self, val);\n\n\t          // now we need to remove `args[index]` since it's inlined in the `format`\n\t          args.splice(index, 1);\n\t          index--;\n\t        }\n\t        return match;\n\t      });\n\n\t      // apply env-specific formatting (colors, etc.)\n\t      exports.formatArgs.call(self, args);\n\n\t      var logFn = debug.log || exports.log || console.log.bind(console);\n\t      logFn.apply(self, args);\n\t    }\n\n\t    debug.namespace = namespace;\n\t    debug.enabled = exports.enabled(namespace);\n\t    debug.useColors = exports.useColors();\n\t    debug.color = selectColor(namespace);\n\t    debug.destroy = destroy;\n\n\t    // env-specific initialization logic for debug instances\n\t    if ('function' === typeof exports.init) {\n\t      exports.init(debug);\n\t    }\n\n\t    exports.instances.push(debug);\n\n\t    return debug;\n\t  }\n\n\t  function destroy () {\n\t    var index = exports.instances.indexOf(this);\n\t    if (index !== -1) {\n\t      exports.instances.splice(index, 1);\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\n\t  /**\n\t   * Enables a debug mode by namespaces. This can include modes\n\t   * separated by a colon and wildcards.\n\t   *\n\t   * @param {String} namespaces\n\t   * @api public\n\t   */\n\n\t  function enable(namespaces) {\n\t    exports.save(namespaces);\n\n\t    exports.names = [];\n\t    exports.skips = [];\n\n\t    var i;\n\t    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t    var len = split.length;\n\n\t    for (i = 0; i < len; i++) {\n\t      if (!split[i]) continue; // ignore empty strings\n\t      namespaces = split[i].replace(/\\*/g, '.*?');\n\t      if (namespaces[0] === '-') {\n\t        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t      } else {\n\t        exports.names.push(new RegExp('^' + namespaces + '$'));\n\t      }\n\t    }\n\n\t    for (i = 0; i < exports.instances.length; i++) {\n\t      var instance = exports.instances[i];\n\t      instance.enabled = exports.enabled(instance.namespace);\n\t    }\n\t  }\n\n\t  /**\n\t   * Disable debug output.\n\t   *\n\t   * @api public\n\t   */\n\n\t  function disable() {\n\t    exports.enable('');\n\t  }\n\n\t  /**\n\t   * Returns true if the given mode name is enabled, false otherwise.\n\t   *\n\t   * @param {String} name\n\t   * @return {Boolean}\n\t   * @api public\n\t   */\n\n\t  function enabled(name) {\n\t    if (name[name.length - 1] === '*') {\n\t      return true;\n\t    }\n\t    var i, len;\n\t    for (i = 0, len = exports.skips.length; i < len; i++) {\n\t      if (exports.skips[i].test(name)) {\n\t        return false;\n\t      }\n\t    }\n\t    for (i = 0, len = exports.names.length; i < len; i++) {\n\t      if (exports.names[i].test(name)) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  }\n\n\t  /**\n\t   * Coerce `val`.\n\t   *\n\t   * @param {Mixed} val\n\t   * @return {Mixed}\n\t   * @api private\n\t   */\n\n\t  function coerce(val) {\n\t    if (val instanceof Error) return val.stack || val.message;\n\t    return val;\n\t  }\n\t  });\n\t  var debug_1 = debug.coerce;\n\t  var debug_2 = debug.disable;\n\t  var debug_3 = debug.enable;\n\t  var debug_4 = debug.enabled;\n\t  var debug_5 = debug.humanize;\n\t  var debug_6 = debug.instances;\n\t  var debug_7 = debug.names;\n\t  var debug_8 = debug.skips;\n\t  var debug_9 = debug.formatters;\n\n\t  var browser = createCommonjsModule$$1(function (module, exports) {\n\t  /**\n\t   * This is the web browser implementation of `debug()`.\n\t   *\n\t   * Expose `debug()` as the module.\n\t   */\n\n\t  exports = module.exports = debug;\n\t  exports.log = log;\n\t  exports.formatArgs = formatArgs;\n\t  exports.save = save;\n\t  exports.load = load;\n\t  exports.useColors = useColors;\n\t  exports.storage = 'undefined' != typeof chrome\n\t                 && 'undefined' != typeof chrome.storage\n\t                    ? chrome.storage.local\n\t                    : localstorage();\n\n\t  /**\n\t   * Colors.\n\t   */\n\n\t  exports.colors = [\n\t    '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n\t    '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n\t    '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n\t    '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n\t    '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n\t    '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n\t    '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n\t    '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n\t    '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n\t    '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n\t    '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n\t  ];\n\n\t  /**\n\t   * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t   * and the Firebug extension (any Firefox version) are known\n\t   * to support \"%c\" CSS customizations.\n\t   *\n\t   * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t   */\n\n\t  function useColors() {\n\t    // NB: In an Electron preload script, document will be defined but not fully\n\t    // initialized. Since we know we're in Chrome, we'll just detect this case\n\t    // explicitly\n\t    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n\t      return true;\n\t    }\n\n\t    // Internet Explorer and Edge do not support colors.\n\t    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t      return false;\n\t    }\n\n\t    // is webkit? http://stackoverflow.com/a/16459606/376773\n\t    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t    return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t      // is firebug? http://stackoverflow.com/a/398120/376773\n\t      (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t      // is firefox >= v31?\n\t      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t      // double check webkit in userAgent just in case we are in a worker\n\t      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n\t  }\n\n\t  /**\n\t   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t   */\n\n\t  exports.formatters.j = function(v) {\n\t    try {\n\t      return JSON.stringify(v);\n\t    } catch (err) {\n\t      return '[UnexpectedJSONParseError]: ' + err.message;\n\t    }\n\t  };\n\n\n\t  /**\n\t   * Colorize log arguments if enabled.\n\t   *\n\t   * @api public\n\t   */\n\n\t  function formatArgs(args) {\n\t    var useColors = this.useColors;\n\n\t    args[0] = (useColors ? '%c' : '')\n\t      + this.namespace\n\t      + (useColors ? ' %c' : ' ')\n\t      + args[0]\n\t      + (useColors ? '%c ' : ' ')\n\t      + '+' + exports.humanize(this.diff);\n\n\t    if (!useColors) return;\n\n\t    var c = 'color: ' + this.color;\n\t    args.splice(1, 0, c, 'color: inherit');\n\n\t    // the final \"%c\" is somewhat tricky, because there could be other\n\t    // arguments passed either before or after the %c, so we need to\n\t    // figure out the correct index to insert the CSS into\n\t    var index = 0;\n\t    var lastC = 0;\n\t    args[0].replace(/%[a-zA-Z%]/g, function(match) {\n\t      if ('%%' === match) return;\n\t      index++;\n\t      if ('%c' === match) {\n\t        // we only are interested in the *last* %c\n\t        // (the user may have provided their own)\n\t        lastC = index;\n\t      }\n\t    });\n\n\t    args.splice(lastC, 0, c);\n\t  }\n\n\t  /**\n\t   * Invokes `console.log()` when available.\n\t   * No-op when `console.log` is not a \"function\".\n\t   *\n\t   * @api public\n\t   */\n\n\t  function log() {\n\t    // this hackery is required for IE8/9, where\n\t    // the `console.log` function doesn't have 'apply'\n\t    return 'object' === typeof console\n\t      && console.log\n\t      && Function.prototype.apply.call(console.log, console, arguments);\n\t  }\n\n\t  /**\n\t   * Save `namespaces`.\n\t   *\n\t   * @param {String} namespaces\n\t   * @api private\n\t   */\n\n\t  function save(namespaces) {\n\t    try {\n\t      if (null == namespaces) {\n\t        exports.storage.removeItem('debug');\n\t      } else {\n\t        exports.storage.debug = namespaces;\n\t      }\n\t    } catch(e) {}\n\t  }\n\n\t  /**\n\t   * Load `namespaces`.\n\t   *\n\t   * @return {String} returns the previously persisted debug modes\n\t   * @api private\n\t   */\n\n\t  function load() {\n\t    var r;\n\t    try {\n\t      r = exports.storage.debug;\n\t    } catch(e) {}\n\n\t    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\t    if (!r && typeof process !== 'undefined' && 'env' in process) {\n\t      r = process.env.DEBUG;\n\t    }\n\n\t    return r;\n\t  }\n\n\t  /**\n\t   * Enable namespaces listed in `localStorage.debug` initially.\n\t   */\n\n\t  exports.enable(load());\n\n\t  /**\n\t   * Localstorage attempts to return the localstorage.\n\t   *\n\t   * This is necessary because safari throws\n\t   * when a user disables cookies/localstorage\n\t   * and you attempt to access it.\n\t   *\n\t   * @return {LocalStorage}\n\t   * @api private\n\t   */\n\n\t  function localstorage() {\n\t    try {\n\t      return window.localStorage;\n\t    } catch (e) {}\n\t  }\n\t  });\n\t  var browser_1 = browser.log;\n\t  var browser_2 = browser.formatArgs;\n\t  var browser_3 = browser.save;\n\t  var browser_4 = browser.load;\n\t  var browser_5 = browser.useColors;\n\t  var browser_6 = browser.storage;\n\t  var browser_7 = browser.colors;\n\n\t  /*\n\t   * vuedl\n\t   *\n\t   * (c) Savaryn Yaroslav <yariksav@gmail.com>\n\t   *\n\t   * For the full copyright and license information, please view the LICENSE\n\t   * file that was distributed with this source code.\n\t  */\n\t  var debug$1 = browser('vuedl:dialog');\n\t  var seed = 1;\n\t  var Dialog = function Dialog(component, ref) {\n\t    if ( ref === void 0 ) ref = {};\n\t    var layout = ref.layout;\n\t    var container = ref.container;\n\n\t    if (!component) {\n\t      throw Error('Component was not setted');\n\t    }\n\n\t    this._layout = layout || {\n\t      component: DefaultLayout,\n\t      options: {}\n\t    };\n\t    this._component = component;\n\t    this._vm = null;\n\t    this._vmDialog = null;\n\t    this._options = {};\n\t    this.id = ++seed;\n\t    this._resolvers = [];\n\t    this.container = findContainer(container);\n\t    debug$1('created');\n\t  };\n\n\t  var prototypeAccessors = { showed: { configurable: true },element: { configurable: true },hasAsyncPreload: { configurable: true },vm: { configurable: true },vmd: { configurable: true } };\n\n\t  Dialog.prototype.show = function show (params, options) {\n\t      if ( params === void 0 ) params = {};\n\t      if ( options === void 0 ) options = {};\n\n\t    return new Promise(function ($return, $error) {\n\t      var LayoutCtor, layout, DialogCtor, dialog;\n\t      if (Vue.prototype.$isServer) { return $return(); }\n\t      debug$1('before show', {\n\t        params: params,\n\t        options: options\n\t      }); // create layout\n\n\t      LayoutCtor = Vue.extend(this._layout.component);\n\t      LayoutCtor = LayoutCtor.extend({\n\t        mixins: [Layoutable],\n\t        destroyed: this._onDestroyed.bind(this)\n\t      });\n\t      layout = new LayoutCtor(merge_1({\n\t        propsData: Object.assign({}, this._layout.options, params)\n\t      }, this.context, options));\n\t      DialogCtor = Vue.extend(Object.assign({}, this._component, {\n\t        parent: layout\n\t      }));\n\n\t      if (this._component.primaryKey) {\n\t        DialogCtor = DialogCtor.extend({\n\t          mixins: [Recordable]\n\t        });\n\t      }\n\n\t      if (this.hasAsyncPreload) {\n\t        var res;\n\t        return Promise.resolve(ensureAsyncDatas(DialogCtor, Object.assign({}, this.context, {\n\t          params: params\n\t        }))).then(function ($await_2) {\n\t          try {\n\t            res = $await_2;\n\t            debug$1('async datas', res);\n\t            return $If_1.call(this);\n\t          } catch ($boundEx) {\n\t            return $error($boundEx);\n\t          }\n\t        }.bind(this), $error);\n\t      }\n\n\t      function $If_1() {\n\t        dialog = new DialogCtor(merge_1({\n\t          propsData: params\n\t        }, this.context, options));\n\t        // mounting\n\t        dialog.$mount();\n\t        layout.$slots.default = dialog._vnode;\n\t        layout.$mount();\n\t        layout.$on('submit', this.onReturn.bind(this));\n\t        dialog.$on('submit', this.onReturn.bind(this));\n\t        this._vm = layout;\n\t        this._vm._dialogInstance = dialog;\n\t        this._vmDialog = dialog;\n\t        this.container = options.container ? findContainer(options.container) : this.container;\n\t        this.container.appendChild(this.element);\n\t        return $return(this);\n\t      }\n\n\t      return $If_1.call(this);\n\t    }.bind(this));\n\t  };\n\n\t  Dialog.prototype.wait = function wait () {\n\t      var this$1 = this;\n\n\t    // if (!this.showed) {\n\t    // return Promise.reject(new Error('Dialog was closed or not showed'))\n\t    // }\n\t    return new Promise(function (resolve) {\n\t      this$1._resolvers.push(resolve);\n\t    });\n\t  };\n\n\t  Dialog.prototype._onDestroyed = function _onDestroyed () {\n\t    this.remove();\n\t  };\n\n\t  Dialog.prototype.remove = function remove () {\n\t    debug$1('remove');\n\t    this.onDestroyed && this.onDestroyed(this); // this.element.parentNode.removeChild(this.element)\n\n\t    this._processResultPromises();\n\n\t    destroyVueElement(this._vm);\n\t    destroyVueElement(this._vmDialog);\n\t    this._vm = null;\n\t    this._vmDialog = null;\n\t  };\n\n\t  Dialog.prototype._processResultPromises = function _processResultPromises (result) {\n\t    if (!this._resolvers.length) {\n\t      return;\n\t    }\n\n\t    debug$1('processResultPromises', result);\n\n\t    this._resolvers.forEach(function (resolver) { return resolver(result); });\n\n\t    this._resolvers = [];\n\t  };\n\n\t  Dialog.prototype.onReturn = function onReturn (result) {\n\t    debug$1('onReturn', result);\n\n\t    this._processResultPromises(result);\n\n\t    this.close();\n\t  };\n\n\t  prototypeAccessors.showed.get = function () {\n\t    return !!this._vm && !this._vm._isDestroyed;\n\t  };\n\n\t  prototypeAccessors.element.get = function () {\n\t    return this._vm && this._vm.$el;\n\t  };\n\n\t  prototypeAccessors.hasAsyncPreload.get = function () {\n\t    return this._component && (this._component.asyncData || this._component.fetch);\n\t  };\n\n\t  prototypeAccessors.vm.get = function () {\n\t    return this._vm;\n\t  };\n\n\t  prototypeAccessors.vmd.get = function () {\n\t    return this._vmDialog;\n\t  };\n\n\t  Dialog.prototype.close = function close () {\n\t    this._vm.close();\n\t  };\n\n\t  Object.defineProperties( Dialog.prototype, prototypeAccessors );\n\n\t  /*\n\t   * vuedl\n\t   *\n\t   * (c) Savaryn Yaroslav <yariksav@gmail.com>\n\t   *\n\t   * For the full copyright and license information, please view the LICENSE\n\t   * file that was distributed with this source code.\n\t  */\n\t  var Overlay = function Overlay(component) {\n\t    this._component = component;\n\t    this._vm = null;\n\t  };\n\n\t  Overlay.prototype.show = function show () {\n\t    if (!this._vm) {\n\t      var Ctor = Vue.extend(this._component);\n\t      this._vm = new Ctor(); // {propsData: { visible: true }}\n\n\t      this._vm.$mount();\n\n\t      document.body.appendChild(this._vm.$el);\n\t    }\n\n\t    this._vm.visible = true;\n\t  };\n\n\t  Overlay.prototype.hide = function hide () {\n\t    this._vm.visible = false;\n\t  };\n\n\t  /*\n\t   * vuedl\n\t   *\n\t   * (c) Savaryn Yaroslav <yariksav@gmail.com>\n\t   *\n\t   * For the full copyright and license information, please view the LICENSE\n\t   * file that was distributed with this source code.\n\t  */\n\n\t  var proxyHandler = {\n\t    get: function get(target, name) {\n\t      /**\n\t       * if node is inspecting then stick to target properties\n\t       */\n\t      if (typeof name === 'symbol' || name === 'inspect') {\n\t        return target[name];\n\t      }\n\n\t      if (target[name]) {\n\t        return target[name];\n\t      }\n\n\t      if (target._components[name]) {\n\t        return target.createFunctionWrapper(name);\n\t      }\n\n\t      return target[name];\n\t    }\n\n\t  };\n\t  var DialogManager = function DialogManager(ref) {\n\t    if ( ref === void 0 ) ref = {};\n\t    var context = ref.context;\n\t    var container = ref.container;\n\n\t    this._context = context || {};\n\t    Dialog.prototype.context = context || {};\n\t    this._components = {};\n\t    this._layouts = {};\n\t    this._overlays = {};\n\t    this._container = container;\n\t    this._emitter = new Vue({});\n\t    this._instances = []; // this.initEmitter()\n\n\t    return new Proxy(this, proxyHandler);\n\t  };\n\n\t  var prototypeAccessors$1 = { context: { configurable: true } }; // initEmitter () {\n\t  // this._emitter.$on('shown', ({ dialog }) => {\n\t  //   const position = dialog.vm.position\n\t  //   let verticalOffset = notificationGap\n\t  //   this._instances.filter(item => item.vm.position === position).forEach(item => {\n\t  //     verticalOffset += item.element.offsetHeight + notificationGap\n\t  //   })\n\t  //   this._instances.push(dialog)\n\t  //   dialog.vm.verticalOffset = verticalOffset\n\t  // })\n\t  // this._emitter.$on('destroyed', ({ dialog }) => {\n\t  //   let index = this._instances.findIndex(instance => instance.id === dialog.id)\n\t  //   if (index < 0) {\n\t  //     return\n\t  //   }\n\t  //   this._instances.splice(index, 1)\n\t  //   // console.log('instances', this._instances)\n\t  //   const len = this._instances.length\n\t  //   const position = dialog.vm.position\n\t  //   if (!len) return\n\t  //   let verticalOffset = notificationGap\n\t  //   this._instances.filter(item => item.vm.position === position).forEach(item => {\n\t  //     item.vm.verticalOffset = verticalOffset\n\t  //     verticalOffset += item.element.offsetHeight + notificationGap\n\t  //   })\n\t  // })\n\t  // }\n\n\n\t  prototypeAccessors$1.context.get = function () {\n\t    return this._context;\n\t  };\n\n\t  DialogManager.prototype.layout = function layout (name, component, options) {\n\t      if ( options === void 0 ) options = {};\n\n\t    this._layouts[name] = {\n\t      component: component,\n\t      options: options\n\t    };\n\t  };\n\n\t  DialogManager.prototype.getLayout = function getLayout (layout) {\n\t    if (typeof layout === 'function') {\n\t      var options = layout.call(this);\n\t      layout = this._layouts[options.name || 'default'];\n\t      return Object.assign({}, layout, {\n\t        options: options\n\t      });\n\t    }\n\n\t    if (typeof layout === 'object' && typeof layout.render === 'function') {\n\t      return {\n\t        component: layout\n\t      };\n\t    }\n\n\t    if (Array.isArray(layout)) {\n\t      var nameTmp = layout[0];\n\t      var optionsTmp = layout[1] || {};\n\t      var instance = typeof nameTmp === 'object' && typeof nameTmp.render === 'function' ? {\n\t        component: nameTmp\n\t      } : this._layouts[nameTmp];\n\t      return instance && {\n\t        component: instance.component,\n\t        options: Object.assign({}, instance.options, optionsTmp)\n\t      };\n\t    }\n\n\t    return this._layouts[layout];\n\t  };\n\n\t  DialogManager.prototype.overlay = function overlay (name, component) {\n\t    if (component === undefined) {\n\t      if (this._overlays[name]) {\n\t        return this._overlays[name];\n\t      } else {\n\t        throw new Error((\"Overlay \\\"\" + name + \" not found\\n          Please register it by calling dialog.overlay('\" + name + \"', component)\"));\n\t      }\n\t    }\n\n\t    this._overlays[name] = new Overlay(component);\n\t  };\n\n\t  DialogManager.prototype.getComponent = function getComponent (name) {\n\t    if (!this._components[name]) {\n\t      throw new Error((\"Component \\\"\" + name + \"\\\" was not found.\\n        Please register it by calling dialog.register('\" + name + \"', component)\"));\n\t    }\n\n\t    return this._components[name];\n\t  };\n\n\t  DialogManager.prototype.component = function component (name, component$1, options) {\n\t      if ( options === void 0 ) options = {};\n\n\t    if (component$1 === undefined) {\n\t      return this._components[name];\n\t    }\n\n\t    this._components[name] = {\n\t      component: component$1,\n\t      options: options\n\t    };\n\t  };\n\n\t  DialogManager.prototype.create = function create (component) {\n\t    if (!component) {\n\t      throw new Error('Component is incorrect');\n\t    }\n\n\t    var layout = this.getLayout(component.layout || 'default');\n\t    var dlg = new Dialog(component, {\n\t      layout: layout,\n\t      context: this._context,\n\t      container: this._container\n\t    });\n\n\t    this._emitter.$emit('created', {\n\t      dialog: dlg\n\t    });\n\n\t    return dlg;\n\t  };\n\n\t  DialogManager.prototype.show = function show (component, options) {\n\t      if ( options === void 0 ) options = {};\n\n\t    return new Promise(function ($return, $error) {\n\t      var dlg, overlayName, overlay;\n\t      dlg = this.create(component);\n\t      overlayName = dlg.hasAsyncPreload ? component.overlay || 'default' : false;\n\t      overlay = overlayName && this._overlays[overlayName] && this.overlay(overlayName);\n\t      overlay && overlay.show();\n\n\t      var $Try_1_Catch = function (e) {\n\t        try {\n\t          this._emitter.$emit('error', {\n\t            error: e,\n\t            dialog: dlg\n\t          });\n\n\t          overlay && overlay.hide();\n\t          throw e;\n\t        } catch ($boundEx) {\n\t          return $error($boundEx);\n\t        }\n\t      }.bind(this);\n\n\t      try {\n\t        return Promise.resolve(dlg.show(options)).then(function ($await_2) {\n\t          try {\n\t            this._emitter.$emit('shown', {\n\t              dialog: dlg\n\t            });\n\n\t            overlay && overlay.hide();\n\t            dlg.onDestroyed = this.onDialogDestroyed.bind(this);\n\t            return $return(options.waitForResult ? dlg.wait() : dlg);\n\t          } catch ($boundEx) {\n\t            return $Try_1_Catch($boundEx);\n\t          }\n\t        }.bind(this), $Try_1_Catch);\n\t      } catch (e) {\n\t        $Try_1_Catch(e);\n\t      }\n\t    }.bind(this));\n\t  };\n\n\t  DialogManager.prototype.createFunctionWrapper = function createFunctionWrapper (name) {\n\t      var this$1 = this;\n\n\t    var cmp = this.getComponent(name);\n\t    return function (options) { return this$1.show(cmp.component, Object.assign({}, cmp.options, options)); };\n\t  };\n\n\t  DialogManager.prototype.showAndWait = function showAndWait (component, props) {\n\t    return new Promise(function ($return, $error) {\n\t      var dlg;\n\t      return Promise.resolve(this.show(component, props)).then(function ($await_3) {\n\t        try {\n\t          dlg = $await_3;\n\t          return $return(dlg.wait());\n\t        } catch ($boundEx) {\n\t          return $error($boundEx);\n\t        }\n\t      }, $error);\n\t    }.bind(this));\n\t  };\n\n\t  DialogManager.prototype.on = function on (event, callback) {\n\t    this._emitter.$on(event, callback);\n\t  };\n\n\t  DialogManager.prototype.off = function off (event, callback) {\n\t    this._emitter.$off(event, callback);\n\t  };\n\n\t  DialogManager.prototype.once = function once (event, callback) {\n\t    this._emitter.$once(event, callback);\n\t  };\n\n\t  DialogManager.prototype.onDialogDestroyed = function onDialogDestroyed (dialog) {\n\t    this._emitter.$emit('destroyed', {\n\t      dialog: dialog\n\t    });\n\t  };\n\n\t  Object.defineProperties( DialogManager.prototype, prototypeAccessors$1 );\n\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  var script$1 = {\n\t    props: {\n\t      width: Number,\n\t      persistent: Boolean\n\t    }\n\t  };\n\n\t  /* script */\n\t              var __vue_script__$1 = script$1;\n\t              \n\t  /* template */\n\t  var __vue_render__$1 = function() {\n\t    var _vm = this;\n\t    var _h = _vm.$createElement;\n\t    var _c = _vm._self._c || _h;\n\t    return _c(\"transition\", { attrs: { name: \"vdialog-modal\" } }, [\n\t      _c(\n\t        \"div\",\n\t        {\n\t          staticClass: \"vdialog-modal-mask\",\n\t          on: {\n\t            click: function($event) {\n\t              if ($event.target !== $event.currentTarget) {\n\t                return null\n\t              }\n\t              $event.preventDefault();\n\t              $event.stopPropagation();\n\t              return _vm.dismiss($event)\n\t            }\n\t          }\n\t        },\n\t        [\n\t          _c(\n\t            \"div\",\n\t            {\n\t              staticClass: \"vdialog-modal-container\",\n\t              style: { \"max-width\": (_vm.width || 500) + \"px\" }\n\t            },\n\t            [\n\t              _c(\n\t                \"dialog-child\",\n\t                _vm._b({}, \"dialog-child\", _vm.$options.propsData, false)\n\t              )\n\t            ],\n\t            1\n\t          )\n\t        ]\n\t      )\n\t    ])\n\t  };\n\t  var __vue_staticRenderFns__$1 = [];\n\t  __vue_render__$1._withStripped = true;\n\n\t    /* style */\n\t    var __vue_inject_styles__$1 = function (inject) {\n\t      if (!inject) { return }\n\t      inject(\"data-v-5c224c04_0\", { source: \"\\n.vdialog-modal-mask {\\n  align-items: center;\\n  display: flex;\\n  height: 100%;\\n  justify-content: center;\\n  left: 0;\\n  position: fixed;\\n  top: 0;\\n  transition: 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\\n  width: 100%;\\n  z-index: 6;\\n  outline: none;\\n  background-color: rgba(0, 0, 0, .5);\\n}\\n.vdialog-modal-container {\\n  overflow-y: auto;\\n  max-height: 95%;\\n  background-color: #fff;\\n  box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2), 0px 24px 38px 3px rgba(0,0,0,0.14), 0px 9px 46px 8px rgba(0,0,0,0.12);\\n  border-radius: 2px;\\n  margin: 12px;\\n  overflow-y: auto;\\n  pointer-events: auto;\\n  transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\\n  width: 100%;\\n  z-index: inherit;\\n}\\n\\n/*\\n* The following styles are auto-applied to elements with\\n* transition=\\\"modal\\\" when their visibility is toggled\\n* by Vue.js.\\n*\\n* You can easily play with the modal transition by editing\\n* these styles.\\n*/\\n.vdialog-modal-enter {\\n  opacity: 0;\\n}\\n.vdialog-modal-leave-active {\\n  opacity: 0;\\n}\\n.vdialog-modal-enter .modal-container,\\n.vdialog-modal-leave-active .modal-container {\\n  -webkit-transform: scale(1.1);\\n  transform: scale(1.1);\\n}\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/vuedl/src/components/DialogLayout.vue\"],\"names\":[],\"mappings\":\";AAqBA;EACA,oBAAA;EACA,cAAA;EACA,aAAA;EACA,wBAAA;EACA,QAAA;EACA,gBAAA;EACA,OAAA;EACA,kDAAA;EACA,YAAA;EACA,WAAA;EACA,cAAA;EACA,oCAAA;CACA;AAEA;EACA,iBAAA;EACA,gBAAA;EACA,uBAAA;EACA,sHAAA;EACA,mBAAA;EACA,aAAA;EACA,iBAAA;EACA,qBAAA;EACA,kDAAA;EACA,YAAA;EACA,iBAAA;CACA;;AAEA;;;;;;;EAOA;AAEA;EACA,WAAA;CACA;AAEA;EACA,WAAA;CACA;AAEA;;EAEA,8BAAA;EACA,sBAAA;CACA\",\"file\":\"DialogLayout.vue\",\"sourcesContent\":[\"<template>\\n  <transition name=\\\"vdialog-modal\\\">\\n    <div class=\\\"vdialog-modal-mask\\\" @click.self.prevent.stop=\\\"dismiss\\\">\\n        <div class=\\\"vdialog-modal-container\\\" :style=\\\"{ 'max-width': (width || 500) +'px' }\\\">\\n          <dialog-child v-bind=\\\"$options.propsData\\\"/>\\n        </div>\\n    </div>\\n  </transition>\\n</template>\\n\\n<script>\\n\\nexport default {\\n  props: {\\n    width: Number,\\n    persistent: Boolean\\n  }\\n}\\n</script>\\n\\n<style>\\n  .vdialog-modal-mask {\\n    align-items: center;\\n    display: flex;\\n    height: 100%;\\n    justify-content: center;\\n    left: 0;\\n    position: fixed;\\n    top: 0;\\n    transition: 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\\n    width: 100%;\\n    z-index: 6;\\n    outline: none;\\n    background-color: rgba(0, 0, 0, .5);\\n  }\\n\\n  .vdialog-modal-container {\\n    overflow-y: auto;\\n    max-height: 95%;\\n    background-color: #fff;\\n    box-shadow: 0px 11px 15px -7px rgba(0,0,0,0.2), 0px 24px 38px 3px rgba(0,0,0,0.14), 0px 9px 46px 8px rgba(0,0,0,0.12);\\n    border-radius: 2px;\\n    margin: 12px;\\n    overflow-y: auto;\\n    pointer-events: auto;\\n    transition: 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);\\n    width: 100%;\\n    z-index: inherit;\\n  }\\n\\n  /*\\n  * The following styles are auto-applied to elements with\\n  * transition=\\\"modal\\\" when their visibility is toggled\\n  * by Vue.js.\\n  *\\n  * You can easily play with the modal transition by editing\\n  * these styles.\\n  */\\n\\n  .vdialog-modal-enter {\\n    opacity: 0;\\n  }\\n\\n  .vdialog-modal-leave-active {\\n    opacity: 0;\\n  }\\n\\n  .vdialog-modal-enter .modal-container,\\n  .vdialog-modal-leave-active .modal-container {\\n    -webkit-transform: scale(1.1);\\n    transform: scale(1.1);\\n  }\\n</style>\\n\"]}, media: undefined });\n\n\t    };\n\t    /* scoped */\n\t    var __vue_scope_id__$1 = undefined;\n\t    /* module identifier */\n\t    var __vue_module_identifier__$1 = undefined;\n\t    /* functional template */\n\t    var __vue_is_functional_template__$1 = false;\n\t    /* component normalizer */\n\t    function __vue_normalize__$1(\n\t      template, style, script,\n\t      scope, functional, moduleIdentifier,\n\t      createInjector, createInjectorSSR\n\t    ) {\n\t      var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t      // For security concerns, we use only base name in production mode.\n\t      component.__file = \"/Users/yarik/Projects/clones/vuedl/src/components/DialogLayout.vue\";\n\n\t      if (!component.render) {\n\t        component.render = template.render;\n\t        component.staticRenderFns = template.staticRenderFns;\n\t        component._compiled = true;\n\n\t        if (functional) { component.functional = true; }\n\t      }\n\n\t      component._scopeId = scope;\n\n\t      {\n\t        var hook;\n\t        if (style) {\n\t          hook = function(context) {\n\t            style.call(this, createInjector(context));\n\t          };\n\t        }\n\n\t        if (hook !== undefined) {\n\t          if (component.functional) {\n\t            // register for functional component in vue file\n\t            var originalRender = component.render;\n\t            component.render = function renderWithStyleInjection(h, context) {\n\t              hook.call(context);\n\t              return originalRender(h, context)\n\t            };\n\t          } else {\n\t            // inject component registration as beforeCreate hook\n\t            var existing = component.beforeCreate;\n\t            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t          }\n\t        }\n\t      }\n\n\t      return component\n\t    }\n\t    /* style inject */\n\t    function __vue_create_injector__$1() {\n\t      var head = document.head || document.getElementsByTagName('head')[0];\n\t      var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});\n\t      var isOldIE =\n\t        typeof navigator !== 'undefined' &&\n\t        /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t      return function addStyle(id, css) {\n\t        if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t        var group = isOldIE ? css.media || 'default' : id;\n\t        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t        if (!style.ids.includes(id)) {\n\t          var code = css.source;\n\t          var index = style.ids.length;\n\n\t          style.ids.push(id);\n\n\t          if (isOldIE) {\n\t            style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t          }\n\n\t          if (!style.element) {\n\t            var el = style.element = document.createElement('style');\n\t            el.type = 'text/css';\n\n\t            if (css.media) { el.setAttribute('media', css.media); }\n\t            if (isOldIE) {\n\t              el.setAttribute('data-group', group);\n\t              el.setAttribute('data-next-index', '0');\n\t            }\n\n\t            head.appendChild(el);\n\t          }\n\n\t          if (isOldIE) {\n\t            index = parseInt(style.element.getAttribute('data-next-index'));\n\t            style.element.setAttribute('data-next-index', index + 1);\n\t          }\n\n\t          if (style.element.styleSheet) {\n\t            style.parts.push(code);\n\t            style.element.styleSheet.cssText = style.parts\n\t              .filter(Boolean)\n\t              .join('\\n');\n\t          } else {\n\t            var textNode = document.createTextNode(code);\n\t            var nodes = style.element.childNodes;\n\t            if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t            else { style.element.appendChild(textNode); }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    /* style inject SSR */\n\t    \n\n\t    \n\t    var DialogLayout = __vue_normalize__$1(\n\t      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },\n\t      __vue_inject_styles__$1,\n\t      __vue_script__$1,\n\t      __vue_scope_id__$1,\n\t      __vue_is_functional_template__$1,\n\t      __vue_module_identifier__$1,\n\t      __vue_create_injector__$1,\n\t      undefined\n\t    );\n\n\t  var notifications = [];\n\t  var gap = 10;\n\n\t  var insertNotification = function (vm) {\n\t    var position = vm.position;\n\t    var verticalOffset = gap;\n\t    notifications.filter(function (item) { return item.position === position; }).forEach(function (item) {\n\t      verticalOffset += item.$el.offsetHeight + gap;\n\t    });\n\t    notifications.push(vm);\n\t    vm.verticalOffset = verticalOffset;\n\t  };\n\n\t  var deleteNotification = function (vm) {\n\t    var index = notifications.findIndex(function (instance) { return instance === vm; });\n\n\t    if (index < 0) {\n\t      return;\n\t    }\n\n\t    notifications.splice(index, 1);\n\t    var len = notifications.length;\n\t    var position = vm.position;\n\t    if (!len) { return; }\n\t    var verticalOffset = gap;\n\t    notifications.filter(function (item) { return item.position === position; }).forEach(function (item) {\n\t      item.verticalOffset = verticalOffset;\n\t      verticalOffset += item.$el.offsetHeight + gap;\n\t    });\n\t  };\n\n\t  var Notifiable = {\n\t    props: {\n\t      verticalOffset: Number,\n\t      showClose: {\n\t        type: Boolean,\n\t        default: function () { return true; }\n\t      },\n\t      position: {\n\t        type: String,\n\t        default: function () { return 'top-right'; }\n\t      },\n\t      timeout: {\n\t        type: Number,\n\t        default: function () { return 4500; }\n\t      },\n\t      width: {\n\t        type: Number,\n\t        default: function () { return 330; }\n\t      },\n\t      zIndex: {\n\t        type: Number,\n\t        default: function () { return 2000; }\n\t      }\n\t    },\n\t    computed: {\n\t      horizontalClass: function horizontalClass() {\n\t        return this.position.indexOf('right') > -1 ? 'right' : 'left';\n\t      },\n\n\t      verticalProperty: function verticalProperty() {\n\t        return /^top-/.test(this.position) ? 'top' : 'bottom';\n\t      },\n\n\t      getStyle: function getStyle() {\n\t        var obj;\n\n\t        return ( obj = {}, obj[this.verticalProperty] = ((this.verticalOffset) + \"px\"), obj['max-width'] =  ((this.width) + \"px\"), obj['z-index'] =  this.zIndex, obj);\n\t      }\n\n\t    },\n\t    methods: {\n\t      _destroy: function _destroy() {\n\t        this.$el.addEventListener('transitionend', this.onTransitionEnd);\n\t      },\n\n\t      onTransitionEnd: function onTransitionEnd() {\n\t        this.$el.removeEventListener('transitionend', this.onTransitionEnd);\n\t        this.$destroy();\n\t      },\n\n\t      clearTimer: function clearTimer() {\n\t        clearTimeout(this.timer);\n\t      },\n\n\t      startTimer: function startTimer() {\n\t        if (this.timeout > 0) {\n\t          this.timer = setTimeout(this.close, this.timeout);\n\t        }\n\t      },\n\n\t      keydown: function keydown(e) {\n\t        if (e.keyCode === 46 || e.keyCode === 8) {\n\t          this.clearTimer(); // detele key\n\t        } else if (e.keyCode === 27) {\n\t          // esc key\n\t          this.close();\n\t        } else {\n\t          this.startTimer(); // any key\n\t        }\n\t      },\n\n\t      close: function close() {\n\t        this.isActive = false;\n\t      }\n\n\t    },\n\t    watch: {\n\t      isActive: function isActive(val) {\n\t        if (val) {\n\t          insertNotification(this);\n\t        } else {\n\t          deleteNotification(this);\n\t        }\n\t      }\n\n\t    },\n\n\t    mounted: function mounted() {\n\t      this.startTimer();\n\t      document.addEventListener('keydown', this.keydown);\n\t    },\n\n\t    beforeDestroy: function beforeDestroy() {\n\t      document.removeEventListener('keydown', this.keydown);\n\t    }\n\n\t  };\n\n\t  //\n\t  var script$2 = {\n\t    mixins: [Notifiable],\n\t    props: {\n\t      //   showClose: {\n\t      //     type: Boolean,\n\t      //     default: () => true\n\t      //   },\n\t      width: {\n\t        type: Number,\n\t        default: function () { return 330; }\n\t      }\n\t    },\n\t    computed: {\n\t      getStyle: function getStyle() {\n\t        var obj;\n\n\t        return ( obj = {}, obj[this.verticalProperty] = ((this.verticalOffset) + \"px\"), obj['max-width'] =  ((this.width) + \"px\"), obj['z-index'] =  this.zIndex, obj);\n\t      }\n\n\t    } // methods: {\n\t    //   _destroy () {\n\t    //     this.$el.addEventListener('transitionend', this.onTransitionEnd)\n\t    //   },\n\t    //   onTransitionEnd () {\n\t    //     this.$el.removeEventListener('transitionend', this.onTransitionEnd)\n\t    //     this.$destroy()\n\t    //   }\n\t    // }\n\n\t  };\n\n\t  /* script */\n\t              var __vue_script__$2 = script$2;\n\t              \n\t  /* template */\n\t  var __vue_render__$2 = function() {\n\t    var _vm = this;\n\t    var _h = _vm.$createElement;\n\t    var _c = _vm._self._c || _h;\n\t    return _c(\"transition\", { attrs: { name: \"vuedl-notification-fade\" } }, [\n\t      _c(\n\t        \"div\",\n\t        {\n\t          directives: [\n\t            {\n\t              name: \"show\",\n\t              rawName: \"v-show\",\n\t              value: _vm.isActive,\n\t              expression: \"isActive\"\n\t            }\n\t          ],\n\t          class: [\"vuedl-notification\", _vm.horizontalClass],\n\t          style: _vm.getStyle,\n\t          attrs: { role: \"alert\" },\n\t          on: { mouseenter: _vm.clearTimer, mouseleave: _vm.startTimer }\n\t        },\n\t        [\n\t          _vm._t(\"default\"),\n\t          _vm._v(\" \"),\n\t          _vm.showClose\n\t            ? _c(\n\t                \"div\",\n\t                {\n\t                  staticClass: \"vuedl-notification__closeBtn\",\n\t                  on: {\n\t                    click: function($event) {\n\t                      $event.stopPropagation();\n\t                      return _vm.close($event)\n\t                    }\n\t                  }\n\t                },\n\t                [_vm._v(\"×\")]\n\t              )\n\t            : _vm._e()\n\t        ],\n\t        2\n\t      )\n\t    ])\n\t  };\n\t  var __vue_staticRenderFns__$2 = [];\n\t  __vue_render__$2._withStripped = true;\n\n\t    /* style */\n\t    var __vue_inject_styles__$2 = function (inject) {\n\t      if (!inject) { return }\n\t      inject(\"data-v-f0792652_0\", { source: \"\\n.vuedl-notification {\\n   display:-webkit-box;\\n   display:-ms-flexbox;\\n   display:flex;\\n   -webkit-box-sizing:border-box;\\n   box-sizing:border-box;\\n   position:fixed;\\n   -webkit-box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\\n   box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\\n   -webkit-transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\\n   transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\\n   transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;\\n   transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\\n   overflow:hidden\\n}\\n.vuedl-notification>div:first-child {\\n   width: 100%\\n}\\n.vuedl-notification.right {\\n   right:16px\\n}\\n.vuedl-notification.left {\\n   left:16px\\n}\\n.vuedl-notification__closeBtn {\\n   position:absolute;\\n   top: 9px;\\n   right: 15px;\\n   cursor: pointer;\\n   color: #909399;\\n   font-size: 22px;\\n}\\n.vuedl-notification__closeBtn:hover {\\n   color:#606266\\n}\\n.vuedl-notification-fade-enter.right{\\n   right:0;\\n   -webkit-transform:translateX(100%);\\n   transform:translateX(100%)\\n}\\n.vuedl-notification-fade-enter.left{\\n   left:0;\\n   -webkit-transform:translateX(-100%);\\n   transform:translateX(-100%)\\n}\\n.vuedl-notification-fade-leave-active {\\n   opacity:0\\n}\\n@media screen and (max-width: 450px) {\\n.vuedl-notification {\\n     left:8px!important;\\n     right:8px!important;\\n     max-width: inherit!important;\\n}\\n}\\n\\n/* .el-notification-fade-enter {\\n   &.right {\\n     right: 0;\\n     transform: translateX(100%);\\n   }\\n\\n   &.left {\\n     left: 0;\\n     transform: translateX(-100%);\\n   }\\n }\\n\\n .el-notification-fade-leave-active {\\n   opacity: 0;\\n }*/\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/vuedl/src/components/NotificationLayout.vue\"],\"names\":[],\"mappings\":\";AAwDA;GACA,oBAAA;GACA,oBAAA;GACA,aAAA;GACA,8BAAA;GACA,sBAAA;GACA,eAAA;GACA,+CAAA;GACA,uCAAA;GACA,2FAAA;GACA,mFAAA;GACA,2EAAA;GACA,iGAAA;GACA,eAAA;CACA;AACA;GACA,WAAA;CACA;AACA;GACA,UAAA;CACA;AACA;GACA,SAAA;CACA;AACA;GACA,kBAAA;GACA,SAAA;GACA,YAAA;GACA,gBAAA;GACA,eAAA;GACA,gBAAA;CACA;AACA;GACA,aAAA;CACA;AACA;GACA,QAAA;GACA,mCAAA;GACA,0BAAA;CACA;AACA;GACA,OAAA;GACA,oCAAA;GACA,2BAAA;CACA;AACA;GACA,SAAA;CACA;AACA;AACA;KACA,mBAAA;KACA,oBAAA;KACA,6BAAA;CACA;CACA;;AAEA;;;;;;;;;;;;;;IAcA\",\"file\":\"NotificationLayout.vue\",\"sourcesContent\":[\"<template>\\n  <transition name=\\\"vuedl-notification-fade\\\">\\n    <div\\n      :class=\\\"['vuedl-notification', horizontalClass]\\\"\\n      v-show=\\\"isActive\\\"\\n      :style=\\\"getStyle\\\"\\n      @mouseenter=\\\"clearTimer\\\"\\n      @mouseleave=\\\"startTimer\\\"\\n      role=\\\"alert\\\"\\n    >\\n      <slot/>\\n      <div\\n        class=\\\"vuedl-notification__closeBtn\\\"\\n        v-if=\\\"showClose\\\"\\n        @click.stop=\\\"close\\\">×</div>\\n    </div>\\n  </transition>\\n</template>\\n\\n<script>\\n\\nimport Notifiable from '../mixins/notifiable'\\n\\nexport default {\\n  mixins: [ Notifiable ],\\n  props: {\\n  //   showClose: {\\n  //     type: Boolean,\\n  //     default: () => true\\n  //   },\\n    width: {\\n      type: Number,\\n      default: () => 330\\n    }\\n  },\\n  computed: {\\n    getStyle () {\\n      return {\\n        [this.verticalProperty]: `${this.verticalOffset}px`,\\n        'max-width': `${this.width}px`,\\n        'z-index': this.zIndex\\n      }\\n    }\\n  }\\n  // methods: {\\n  //   _destroy () {\\n  //     this.$el.addEventListener('transitionend', this.onTransitionEnd)\\n  //   },\\n  //   onTransitionEnd () {\\n  //     this.$el.removeEventListener('transitionend', this.onTransitionEnd)\\n  //     this.$destroy()\\n  //   }\\n  // }\\n}\\n</script>\\n<style>\\n  .vuedl-notification {\\n    display:-webkit-box;\\n    display:-ms-flexbox;\\n    display:flex;\\n    -webkit-box-sizing:border-box;\\n    box-sizing:border-box;\\n    position:fixed;\\n    -webkit-box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\\n    box-shadow:0 2px 12px 0 rgba(0,0,0,.1);\\n    -webkit-transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\\n    transition:opacity .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\\n    transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s;\\n    transition:opacity .3s,transform .3s,left .3s,right .3s,top .4s,bottom .3s,-webkit-transform .3s;\\n    overflow:hidden\\n  }\\n  .vuedl-notification>div:first-child {\\n    width: 100%\\n  }\\n  .vuedl-notification.right {\\n    right:16px\\n  }\\n  .vuedl-notification.left {\\n    left:16px\\n  }\\n  .vuedl-notification__closeBtn {\\n    position:absolute;\\n    top: 9px;\\n    right: 15px;\\n    cursor: pointer;\\n    color: #909399;\\n    font-size: 22px;\\n  }\\n  .vuedl-notification__closeBtn:hover {\\n    color:#606266\\n  }\\n  .vuedl-notification-fade-enter.right{\\n    right:0;\\n    -webkit-transform:translateX(100%);\\n    transform:translateX(100%)\\n  }\\n  .vuedl-notification-fade-enter.left{\\n    left:0;\\n    -webkit-transform:translateX(-100%);\\n    transform:translateX(-100%)\\n  }\\n  .vuedl-notification-fade-leave-active {\\n    opacity:0\\n  }\\n  @media screen and (max-width: 450px) {\\n    .vuedl-notification {\\n      left:8px!important;\\n      right:8px!important;\\n      max-width: inherit!important;\\n    }\\n  }\\n\\n /* .el-notification-fade-enter {\\n    &.right {\\n      right: 0;\\n      transform: translateX(100%);\\n    }\\n\\n    &.left {\\n      left: 0;\\n      transform: translateX(-100%);\\n    }\\n  }\\n\\n  .el-notification-fade-leave-active {\\n    opacity: 0;\\n  }*/\\n</style>\\n\"]}, media: undefined });\n\n\t    };\n\t    /* scoped */\n\t    var __vue_scope_id__$2 = undefined;\n\t    /* module identifier */\n\t    var __vue_module_identifier__$2 = undefined;\n\t    /* functional template */\n\t    var __vue_is_functional_template__$2 = false;\n\t    /* component normalizer */\n\t    function __vue_normalize__$2(\n\t      template, style, script,\n\t      scope, functional, moduleIdentifier,\n\t      createInjector, createInjectorSSR\n\t    ) {\n\t      var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t      // For security concerns, we use only base name in production mode.\n\t      component.__file = \"/Users/yarik/Projects/clones/vuedl/src/components/NotificationLayout.vue\";\n\n\t      if (!component.render) {\n\t        component.render = template.render;\n\t        component.staticRenderFns = template.staticRenderFns;\n\t        component._compiled = true;\n\n\t        if (functional) { component.functional = true; }\n\t      }\n\n\t      component._scopeId = scope;\n\n\t      {\n\t        var hook;\n\t        if (style) {\n\t          hook = function(context) {\n\t            style.call(this, createInjector(context));\n\t          };\n\t        }\n\n\t        if (hook !== undefined) {\n\t          if (component.functional) {\n\t            // register for functional component in vue file\n\t            var originalRender = component.render;\n\t            component.render = function renderWithStyleInjection(h, context) {\n\t              hook.call(context);\n\t              return originalRender(h, context)\n\t            };\n\t          } else {\n\t            // inject component registration as beforeCreate hook\n\t            var existing = component.beforeCreate;\n\t            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t          }\n\t        }\n\t      }\n\n\t      return component\n\t    }\n\t    /* style inject */\n\t    function __vue_create_injector__$2() {\n\t      var head = document.head || document.getElementsByTagName('head')[0];\n\t      var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});\n\t      var isOldIE =\n\t        typeof navigator !== 'undefined' &&\n\t        /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t      return function addStyle(id, css) {\n\t        if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t        var group = isOldIE ? css.media || 'default' : id;\n\t        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t        if (!style.ids.includes(id)) {\n\t          var code = css.source;\n\t          var index = style.ids.length;\n\n\t          style.ids.push(id);\n\n\t          if (isOldIE) {\n\t            style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t          }\n\n\t          if (!style.element) {\n\t            var el = style.element = document.createElement('style');\n\t            el.type = 'text/css';\n\n\t            if (css.media) { el.setAttribute('media', css.media); }\n\t            if (isOldIE) {\n\t              el.setAttribute('data-group', group);\n\t              el.setAttribute('data-next-index', '0');\n\t            }\n\n\t            head.appendChild(el);\n\t          }\n\n\t          if (isOldIE) {\n\t            index = parseInt(style.element.getAttribute('data-next-index'));\n\t            style.element.setAttribute('data-next-index', index + 1);\n\t          }\n\n\t          if (style.element.styleSheet) {\n\t            style.parts.push(code);\n\t            style.element.styleSheet.cssText = style.parts\n\t              .filter(Boolean)\n\t              .join('\\n');\n\t          } else {\n\t            var textNode = document.createTextNode(code);\n\t            var nodes = style.element.childNodes;\n\t            if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t            else { style.element.appendChild(textNode); }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    /* style inject SSR */\n\t    \n\n\t    \n\t    var NotificationLayout = __vue_normalize__$2(\n\t      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },\n\t      __vue_inject_styles__$2,\n\t      __vue_script__$2,\n\t      __vue_scope_id__$2,\n\t      __vue_is_functional_template__$2,\n\t      __vue_module_identifier__$2,\n\t      __vue_create_injector__$2,\n\t      undefined\n\t    );\n\n\t  //\n\t  //\n\t  //\n\t  //\n\t  //\n\t  var script$3 = {\n\t    name: 'VDialogOverlay',\n\t    props: {\n\t      zIndex: {\n\t        type: Number,\n\t        default: function () { return 1250; }\n\t      },\n\t      visible: {\n\t        type: Boolean,\n\t        default: function () { return false; }\n\t      }\n\t    }\n\t  };\n\n\t  /* script */\n\t              var __vue_script__$3 = script$3;\n\t              \n\t  /* template */\n\t  var __vue_render__$3 = function() {\n\t    var _vm = this;\n\t    var _h = _vm.$createElement;\n\t    var _c = _vm._self._c || _h;\n\t    return _c(\"transition\", { attrs: { name: \"opacity\" } }, [\n\t      _vm.visible\n\t        ? _c(\n\t            \"div\",\n\t            {\n\t              staticClass: \"dialog-overlay-loading\",\n\t              style: { zIndex: _vm.zIndex }\n\t            },\n\t            [_vm._v(\"Loading…\")]\n\t          )\n\t        : _vm._e()\n\t    ])\n\t  };\n\t  var __vue_staticRenderFns__$3 = [];\n\t  __vue_render__$3._withStripped = true;\n\n\t    /* style */\n\t    var __vue_inject_styles__$3 = function (inject) {\n\t      if (!inject) { return }\n\t      inject(\"data-v-05d353e2_0\", { source: \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n/* Absolute Center Spinner */\\n.dialog-overlay-loading {\\n  position: fixed;\\n  z-index: 999;\\n  height: 2em;\\n  width: 2em;\\n  overflow: show;\\n  margin: auto;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  right: 0;\\n  /* background: rgba(112, 112, 112, 0.4); */\\n  cursor: wait;\\n}\\n\\n/* Transparent Overlay */\\n.dialog-overlay-loading:before {\\n  content: '';\\n  display: block;\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  background: radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\\n  background: -webkit-radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\\n}\\n\\n/* :not(:required) hides these rules from IE9 and below */\\n.dialog-overlay-loading:not(:required) {\\n  /* hide \\\"loading...\\\" text */\\n  font: 0/0 a;\\n  color: transparent;\\n  text-shadow: none;\\n  background-color: transparent;\\n  border: 0;\\n}\\n.dialog-overlay-loading:not(:required):after {\\n  content: '';\\n  display: block;\\n  font-size: 10px;\\n  width: 1em;\\n  height: 1em;\\n  margin-top: -0.5em;\\n  -webkit-animation: spinner 1500ms infinite linear;\\n  -moz-animation: spinner 1500ms infinite linear;\\n  -ms-animation: spinner 1500ms infinite linear;\\n  -o-animation: spinner 1500ms infinite linear;\\n  animation: spinner 1500ms infinite linear;\\n  border-radius: 0.5em;\\n  -webkit-box-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\\nbox-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\\n}\\n\\n/* Animation */\\n@-webkit-keyframes spinner {\\n0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n}\\n100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n}\\n}\\n@-moz-keyframes spinner {\\n0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n}\\n100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n}\\n}\\n@-o-keyframes spinner {\\n0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n}\\n100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n}\\n}\\n@keyframes spinner {\\n0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n}\\n100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n}\\n}\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/vuedl/src/components/DialogOverlay.vue\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;AAqBA,6BAAA;AACA;EACA,gBAAA;EACA,aAAA;EACA,YAAA;EACA,WAAA;EACA,eAAA;EACA,aAAA;EACA,OAAA;EACA,QAAA;EACA,UAAA;EACA,SAAA;EACA,2CAAA;EACA,aAAA;CACA;;AAEA,yBAAA;AACA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,OAAA;EACA,QAAA;EACA,YAAA;EACA,aAAA;EACA,4EAAA;EACA,oFAAA;CACA;;AAEA,0DAAA;AACA;EACA,4BAAA;EACA,YAAA;EACA,mBAAA;EACA,kBAAA;EACA,8BAAA;EACA,UAAA;CACA;AAEA;EACA,YAAA;EACA,eAAA;EACA,gBAAA;EACA,WAAA;EACA,YAAA;EACA,mBAAA;EACA,kDAAA;EACA,+CAAA;EACA,8CAAA;EACA,6CAAA;EACA,0CAAA;EACA,qBAAA;EACA,iVAAA;AACA,yUAAA;CACA;;AAEA,eAAA;AAEA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA;AACA;AACA;IACA,gCAAA;IACA,6BAAA;IACA,4BAAA;IACA,2BAAA;IACA,wBAAA;CACA;AACA;IACA,kCAAA;IACA,+BAAA;IACA,8BAAA;IACA,6BAAA;IACA,0BAAA;CACA;CACA\",\"file\":\"DialogOverlay.vue\",\"sourcesContent\":[\"<template>\\n  <transition name=\\\"opacity\\\">\\n    <div class=\\\"dialog-overlay-loading\\\" :style=\\\"{zIndex: zIndex}\\\" v-if=\\\"visible\\\">Loading&#8230;</div>\\n  </transition>\\n</template>\\n<script>\\nexport default {\\n  name: 'VDialogOverlay',\\n  props: {\\n    zIndex: {\\n      type: Number,\\n      default: () => 1250\\n    },\\n    visible: {\\n      type: Boolean,\\n      default: () => false\\n    }\\n  }\\n}\\n</script>\\n<style>\\n/* Absolute Center Spinner */\\n.dialog-overlay-loading {\\n  position: fixed;\\n  z-index: 999;\\n  height: 2em;\\n  width: 2em;\\n  overflow: show;\\n  margin: auto;\\n  top: 0;\\n  left: 0;\\n  bottom: 0;\\n  right: 0;\\n  /* background: rgba(112, 112, 112, 0.4); */\\n  cursor: wait;\\n}\\n\\n/* Transparent Overlay */\\n.dialog-overlay-loading:before {\\n  content: '';\\n  display: block;\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  background: radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\\n  background: -webkit-radial-gradient(rgba(112, 112, 112, 0.4), rgba(50, 50, 50, .8));\\n}\\n\\n/* :not(:required) hides these rules from IE9 and below */\\n.dialog-overlay-loading:not(:required) {\\n  /* hide \\\"loading...\\\" text */\\n  font: 0/0 a;\\n  color: transparent;\\n  text-shadow: none;\\n  background-color: transparent;\\n  border: 0;\\n}\\n\\n.dialog-overlay-loading:not(:required):after {\\n  content: '';\\n  display: block;\\n  font-size: 10px;\\n  width: 1em;\\n  height: 1em;\\n  margin-top: -0.5em;\\n  -webkit-animation: spinner 1500ms infinite linear;\\n  -moz-animation: spinner 1500ms infinite linear;\\n  -ms-animation: spinner 1500ms infinite linear;\\n  -o-animation: spinner 1500ms infinite linear;\\n  animation: spinner 1500ms infinite linear;\\n  border-radius: 0.5em;\\n  -webkit-box-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\\nbox-shadow: rgba(255,255,255, 0.75) 1.5em 0 0 0, rgba(255,255,255, 0.75) 1.1em 1.1em 0 0, rgba(255,255,255, 0.75) 0 1.5em 0 0, rgba(255,255,255, 0.75) -1.1em 1.1em 0 0, rgba(255,255,255, 0.75) -1.5em 0 0 0, rgba(255,255,255, 0.75) -1.1em -1.1em 0 0, rgba(255,255,255, 0.75) 0 -1.5em 0 0, rgba(255,255,255, 0.75) 1.1em -1.1em 0 0;\\n}\\n\\n/* Animation */\\n\\n@-webkit-keyframes spinner {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n  }\\n}\\n@-moz-keyframes spinner {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n  }\\n}\\n@-o-keyframes spinner {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n  }\\n}\\n@keyframes spinner {\\n  0% {\\n    -webkit-transform: rotate(0deg);\\n    -moz-transform: rotate(0deg);\\n    -ms-transform: rotate(0deg);\\n    -o-transform: rotate(0deg);\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    -webkit-transform: rotate(360deg);\\n    -moz-transform: rotate(360deg);\\n    -ms-transform: rotate(360deg);\\n    -o-transform: rotate(360deg);\\n    transform: rotate(360deg);\\n  }\\n}\\n</style>\\n\"]}, media: undefined });\n\n\t    };\n\t    /* scoped */\n\t    var __vue_scope_id__$3 = undefined;\n\t    /* module identifier */\n\t    var __vue_module_identifier__$3 = undefined;\n\t    /* functional template */\n\t    var __vue_is_functional_template__$3 = false;\n\t    /* component normalizer */\n\t    function __vue_normalize__$3(\n\t      template, style, script,\n\t      scope, functional, moduleIdentifier,\n\t      createInjector, createInjectorSSR\n\t    ) {\n\t      var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t      // For security concerns, we use only base name in production mode.\n\t      component.__file = \"/Users/yarik/Projects/clones/vuedl/src/components/DialogOverlay.vue\";\n\n\t      if (!component.render) {\n\t        component.render = template.render;\n\t        component.staticRenderFns = template.staticRenderFns;\n\t        component._compiled = true;\n\n\t        if (functional) { component.functional = true; }\n\t      }\n\n\t      component._scopeId = scope;\n\n\t      {\n\t        var hook;\n\t        if (style) {\n\t          hook = function(context) {\n\t            style.call(this, createInjector(context));\n\t          };\n\t        }\n\n\t        if (hook !== undefined) {\n\t          if (component.functional) {\n\t            // register for functional component in vue file\n\t            var originalRender = component.render;\n\t            component.render = function renderWithStyleInjection(h, context) {\n\t              hook.call(context);\n\t              return originalRender(h, context)\n\t            };\n\t          } else {\n\t            // inject component registration as beforeCreate hook\n\t            var existing = component.beforeCreate;\n\t            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t          }\n\t        }\n\t      }\n\n\t      return component\n\t    }\n\t    /* style inject */\n\t    function __vue_create_injector__$3() {\n\t      var head = document.head || document.getElementsByTagName('head')[0];\n\t      var styles = __vue_create_injector__$3.styles || (__vue_create_injector__$3.styles = {});\n\t      var isOldIE =\n\t        typeof navigator !== 'undefined' &&\n\t        /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t      return function addStyle(id, css) {\n\t        if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t        var group = isOldIE ? css.media || 'default' : id;\n\t        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t        if (!style.ids.includes(id)) {\n\t          var code = css.source;\n\t          var index = style.ids.length;\n\n\t          style.ids.push(id);\n\n\t          if (isOldIE) {\n\t            style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t          }\n\n\t          if (!style.element) {\n\t            var el = style.element = document.createElement('style');\n\t            el.type = 'text/css';\n\n\t            if (css.media) { el.setAttribute('media', css.media); }\n\t            if (isOldIE) {\n\t              el.setAttribute('data-group', group);\n\t              el.setAttribute('data-next-index', '0');\n\t            }\n\n\t            head.appendChild(el);\n\t          }\n\n\t          if (isOldIE) {\n\t            index = parseInt(style.element.getAttribute('data-next-index'));\n\t            style.element.setAttribute('data-next-index', index + 1);\n\t          }\n\n\t          if (style.element.styleSheet) {\n\t            style.parts.push(code);\n\t            style.element.styleSheet.cssText = style.parts\n\t              .filter(Boolean)\n\t              .join('\\n');\n\t          } else {\n\t            var textNode = document.createTextNode(code);\n\t            var nodes = style.element.childNodes;\n\t            if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t            else { style.element.appendChild(textNode); }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    /* style inject SSR */\n\t    \n\n\t    \n\t    var DialogOverlay = __vue_normalize__$3(\n\t      { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },\n\t      __vue_inject_styles__$3,\n\t      __vue_script__$3,\n\t      __vue_scope_id__$3,\n\t      __vue_is_functional_template__$3,\n\t      __vue_module_identifier__$3,\n\t      __vue_create_injector__$3,\n\t      undefined\n\t    );\n\n\t  var Confirmable = {\n\t    name: 'Confirmable',\n\t    props: {\n\t      type: {\n\t        type: String\n\t      },\n\t      text: {\n\t        type: String,\n\t        reqiured: true\n\t      },\n\t      title: {\n\t        type: String\n\t      },\n\t      actions: {\n\t        type: [Array, Object]\n\t      }\n\t    }\n\t  };\n\n\t  /* @vue/component */\n\t  var Returnable = {\n\t    name: 'Returnable',\n\t    props: {\n\t      returnValue: null\n\t    },\n\n\t    data: function data() {\n\t      return {\n\t        originalValue: this.returnValue,\n\t        returnResovers: []\n\t      };\n\t    },\n\n\t    // watch: {\n\t    //   'wrapper.isActive' (val) {\n\t    //     console.log('watch.isActive', val)\n\t    //     if (val) {\n\t    //       this.originalValue = this.returnValue\n\t    //     } else {\n\t    //       // console.log('emit', this.originalValue)\n\t    //       // this.$emit('submit', this.originalValue)\n\t    //       this.$emit('update:returnValue', this.originalValue)\n\t    //     }\n\t    //   }\n\t    // },\n\t    methods: {\n\t      return: function return$1(value) {\n\t        this.originalValue = value;\n\t        this.$root.$emit('submit', this.originalValue);\n\t        this.$emit('submit', this.originalValue);\n\t      }\n\n\t    }\n\t  };\n\n\t  var Actionable = {\n\t    name: 'Actionable',\n\t    mixins: [Returnable],\n\n\t    data: function data() {\n\t      return {\n\t        loadingAction: null\n\t      };\n\t    },\n\n\t    props: {\n\t      actions: {\n\t        type: [Array, Object],\n\t        default: function () { return []; }\n\t      }\n\t    },\n\t    computed: {\n\t      actionlist: function actionlist() {\n\t        var this$1 = this;\n\n\t        var actions = [];\n\n\t        for (var key in this$1.actions) {\n\t          var action = this$1.actions[key];\n\n\t          if (typeof action === 'string') {\n\t            action = {\n\t              text: action\n\t            };\n\t          }\n\n\t          this$1.$set(action, 'loading', false);\n\n\t          if (!action.key) {\n\t            action.key = isNaN(key) ? key : action.text;\n\t          }\n\n\t          if (['true', 'false'].indexOf(action.key) >= 0) {\n\t            action.key = JSON.parse(action.key);\n\t          }\n\n\t          actions.push(action);\n\t        }\n\n\t        return actions;\n\t      }\n\n\t    },\n\t    methods: {\n\t      trigger: function trigger(name) {\n\t        var action = this.actionlist.find(function (action) { return action.key === name; });\n\n\t        if (action && !this.isActionDisabled(action) && this.isActionVisible(action)) {\n\t          this.onActionClick(action);\n\t        }\n\t      },\n\n\t      setLoadingToInstance: function setLoadingToInstance(vm, value) {\n\t        if (vm && vm.loading !== undefined) {\n\t          vm.loading = value;\n\t        }\n\t      },\n\n\t      setLoadingState: function setLoadingState(value) {\n\t        this.$emit('loading', value);\n\t        !value && (this.loadingAction = null);\n\t        this.setLoadingToInstance(this.$root, value);\n\t        this.setLoadingToInstance(this.$root._dialogInstance, value);\n\t      },\n\n\t      isActionDisabled: function isActionDisabled(action) {\n\t        if (action.disabled === undefined) {\n\t          return false;\n\t        }\n\n\t        if (typeof action.disabled === 'function') {\n\t          return action.disabled();\n\t        }\n\n\t        return action.disabled;\n\t      },\n\n\t      isActionVisible: function isActionVisible(action) {\n\t        if (action.visible === undefined) {\n\t          return true;\n\t        }\n\n\t        if (typeof action.visible === 'function') {\n\t          return action.visible();\n\t        }\n\n\t        return action.visible;\n\t      },\n\n\t      onActionClick: function onActionClick(action) {\n\t        return new Promise(function ($return, $error) {\n\t          var closable;\n\t          closable = action.closable === undefined || action.closable === true;\n\n\t          if (action.handle) {\n\t            this.loadingAction = action.key;\n\t            this.setLoadingState(true);\n\n\t            var $Try_1_Post = function () {\n\t              try {\n\t                return $If_2.call(this);\n\t              } catch ($boundEx) {\n\t                return $error($boundEx);\n\t              }\n\t            }.bind(this);\n\n\t            var $Try_1_Catch = function (e) {\n\t              try {\n\t                this.setLoadingState(false);\n\t                console.log('error', e); // TODO\n\n\t                throw e;\n\t              } catch ($boundEx) {\n\t                return $error($boundEx);\n\t              }\n\t            }.bind(this);\n\n\t            try {\n\t              var ret;\n\t              return Promise.resolve(action.handle()).then(function ($await_3) {\n\t                try {\n\t                  ret = $await_3;\n\t                  this.setLoadingState(false);\n\n\t                  if (ret !== false && closable) {\n\t                    this.return(ret || action.key);\n\t                  }\n\n\t                  return $Try_1_Post();\n\t                } catch ($boundEx) {\n\t                  return $Try_1_Catch($boundEx);\n\t                }\n\t              }.bind(this), $Try_1_Catch);\n\t            } catch (e) {\n\t              $Try_1_Catch(e);\n\t            }\n\t          } else {\n\t            closable && this.return(action.key);\n\t            return $If_2.call(this);\n\t          }\n\n\t          function $If_2() {\n\t            return $return();\n\t          }\n\t        }.bind(this));\n\t      }\n\n\t    }\n\t  };\n\n\t  //\n\t  var script$4 = {\n\t    mixins: [Actionable]\n\t  };\n\n\t  /* script */\n\t              var __vue_script__$4 = script$4;\n\t              \n\t  /* template */\n\t  var __vue_render__$4 = function() {\n\t    var _vm = this;\n\t    var _h = _vm.$createElement;\n\t    var _c = _vm._self._c || _h;\n\t    return _c(\n\t      \"span\",\n\t      _vm._l(_vm.actionlist, function(action) {\n\t        return _c(\n\t          \"button\",\n\t          {\n\t            key: action.key,\n\t            staticClass: \"button\",\n\t            class: { loading: _vm.loadingAction === action.key },\n\t            attrs: {\n\t              \"action-key\": \"\" + action.key,\n\t              disabled: _vm.isActionDisabled(action) || !!_vm.loadingAction\n\t            },\n\t            on: {\n\t              click: function($event) {\n\t                _vm.onActionClick(action);\n\t              }\n\t            }\n\t          },\n\t          [_vm._v(\"\\n    \" + _vm._s(action.text) + \"\\n  \")]\n\t        )\n\t      })\n\t    )\n\t  };\n\t  var __vue_staticRenderFns__$4 = [];\n\t  __vue_render__$4._withStripped = true;\n\n\t    /* style */\n\t    var __vue_inject_styles__$4 = undefined;\n\t    /* scoped */\n\t    var __vue_scope_id__$4 = undefined;\n\t    /* module identifier */\n\t    var __vue_module_identifier__$4 = undefined;\n\t    /* functional template */\n\t    var __vue_is_functional_template__$4 = false;\n\t    /* component normalizer */\n\t    function __vue_normalize__$4(\n\t      template, style, script,\n\t      scope, functional, moduleIdentifier,\n\t      createInjector, createInjectorSSR\n\t    ) {\n\t      var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t      // For security concerns, we use only base name in production mode.\n\t      component.__file = \"/Users/yarik/Projects/clones/vuedl/src/components/DialogActions.vue\";\n\n\t      if (!component.render) {\n\t        component.render = template.render;\n\t        component.staticRenderFns = template.staticRenderFns;\n\t        component._compiled = true;\n\n\t        if (functional) { component.functional = true; }\n\t      }\n\n\t      component._scopeId = scope;\n\n\t      \n\n\t      return component\n\t    }\n\t    /* style inject */\n\t    function __vue_create_injector__$4() {\n\t      var head = document.head || document.getElementsByTagName('head')[0];\n\t      var styles = __vue_create_injector__$4.styles || (__vue_create_injector__$4.styles = {});\n\t      var isOldIE =\n\t        typeof navigator !== 'undefined' &&\n\t        /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t      return function addStyle(id, css) {\n\t        if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t        var group = isOldIE ? css.media || 'default' : id;\n\t        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t        if (!style.ids.includes(id)) {\n\t          var code = css.source;\n\t          var index = style.ids.length;\n\n\t          style.ids.push(id);\n\n\t          if (isOldIE) {\n\t            style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t          }\n\n\t          if (!style.element) {\n\t            var el = style.element = document.createElement('style');\n\t            el.type = 'text/css';\n\n\t            if (css.media) { el.setAttribute('media', css.media); }\n\t            if (isOldIE) {\n\t              el.setAttribute('data-group', group);\n\t              el.setAttribute('data-next-index', '0');\n\t            }\n\n\t            head.appendChild(el);\n\t          }\n\n\t          if (isOldIE) {\n\t            index = parseInt(style.element.getAttribute('data-next-index'));\n\t            style.element.setAttribute('data-next-index', index + 1);\n\t          }\n\n\t          if (style.element.styleSheet) {\n\t            style.parts.push(code);\n\t            style.element.styleSheet.cssText = style.parts\n\t              .filter(Boolean)\n\t              .join('\\n');\n\t          } else {\n\t            var textNode = document.createTextNode(code);\n\t            var nodes = style.element.childNodes;\n\t            if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t            else { style.element.appendChild(textNode); }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    /* style inject SSR */\n\t    \n\n\t    \n\t    var DialogActions = __vue_normalize__$4(\n\t      { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },\n\t      __vue_inject_styles__$4,\n\t      __vue_script__$4,\n\t      __vue_scope_id__$4,\n\t      __vue_is_functional_template__$4,\n\t      __vue_module_identifier__$4,\n\t      __vue_create_injector__$4,\n\t      undefined\n\t    );\n\n\t  //\n\t  var script$5 = {\n\t    components: {\n\t      DialogActions: DialogActions\n\t    },\n\t    layout: 'default',\n\t    mixins: [Confirmable]\n\t  };\n\n\t  /* script */\n\t              var __vue_script__$5 = script$5;\n\t              \n\t  /* template */\n\t  var __vue_render__$5 = function() {\n\t    var _vm = this;\n\t    var _h = _vm.$createElement;\n\t    var _c = _vm._self._c || _h;\n\t    return _c(\"div\", { staticClass: \"confirm-box\" }, [\n\t      !!_vm.title\n\t        ? _c(\"div\", { staticClass: \"confirm-title\" }, [\n\t            _c(\"h1\", { staticClass: \"title\" }, [_vm._v(_vm._s(_vm.title))])\n\t          ])\n\t        : _vm._e(),\n\t      _vm._v(\" \"),\n\t      _c(\"div\", {\n\t        staticClass: \"confirm-message\",\n\t        domProps: { innerHTML: _vm._s(_vm.message) }\n\t      }),\n\t      _vm._v(\" \"),\n\t      _c(\"div\", { staticClass: \"confirm-buttons\" }, [\n\t        _c(\n\t          \"div\",\n\t          { staticClass: \"column\" },\n\t          [_c(\"DialogActions\", { attrs: { actions: _vm.actions } })],\n\t          1\n\t        )\n\t      ])\n\t    ])\n\t  };\n\t  var __vue_staticRenderFns__$5 = [];\n\t  __vue_render__$5._withStripped = true;\n\n\t    /* style */\n\t    var __vue_inject_styles__$5 = function (inject) {\n\t      if (!inject) { return }\n\t      inject(\"data-v-8a87651c_0\", { source: \"\\n.confirm-box {\\n  background: #ffffff;\\n}\\n.confirm-box .confirm-title {\\n  padding: 20px\\n}\\n.confirm-box .confirm-message {\\n  padding: 0 20px;\\n}\\n.confirm-box .confirm-buttons {\\n  text-align:  right;\\n  padding: 10px 20px;\\n}\\n.confirm-box .confirm-buttons .button {\\n  font-size: 20px;\\n  padding-left: 20px;\\n}\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/vuedl/src/components/Confirm.vue\"],\"names\":[],\"mappings\":\";AA6BA;EACA,oBAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,gBAAA;CACA;AACA;EACA,mBAAA;EACA,mBAAA;CACA;AACA;EACA,gBAAA;EACA,mBAAA;CACA\",\"file\":\"Confirm.vue\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"confirm-box\\\">\\n    <div v-if=\\\"!!title\\\" class=\\\"confirm-title\\\">\\n      <h1 class=\\\"title\\\">{{ title }}</h1>\\n    </div>\\n    <div class=\\\"confirm-message\\\" v-html=\\\"message\\\" />\\n    <div class=\\\"confirm-buttons\\\">\\n      <div class=\\\"column\\\">\\n        <DialogActions :actions=\\\"actions\\\"/>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n<script>\\n\\nimport Confirmable from '../mixins/confirmable'\\nimport DialogActions from './DialogActions.vue'\\n\\nexport default {\\n  components: {\\n    DialogActions\\n  },\\n  layout: 'default',\\n  mixins: [ Confirmable ]\\n}\\n\\n</script>\\n\\n<style>\\n  .confirm-box {\\n    background: #ffffff;\\n  }\\n  .confirm-box .confirm-title {\\n    padding: 20px\\n  }\\n  .confirm-box .confirm-message {\\n    padding: 0 20px;\\n  }\\n  .confirm-box .confirm-buttons {\\n    text-align:  right;\\n    padding: 10px 20px;\\n  }\\n  .confirm-box .confirm-buttons .button {\\n    font-size: 20px;\\n    padding-left: 20px;\\n  }\\n</style>\\n\"]}, media: undefined });\n\n\t    };\n\t    /* scoped */\n\t    var __vue_scope_id__$5 = undefined;\n\t    /* module identifier */\n\t    var __vue_module_identifier__$5 = undefined;\n\t    /* functional template */\n\t    var __vue_is_functional_template__$5 = false;\n\t    /* component normalizer */\n\t    function __vue_normalize__$5(\n\t      template, style, script,\n\t      scope, functional, moduleIdentifier,\n\t      createInjector, createInjectorSSR\n\t    ) {\n\t      var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t      // For security concerns, we use only base name in production mode.\n\t      component.__file = \"/Users/yarik/Projects/clones/vuedl/src/components/Confirm.vue\";\n\n\t      if (!component.render) {\n\t        component.render = template.render;\n\t        component.staticRenderFns = template.staticRenderFns;\n\t        component._compiled = true;\n\n\t        if (functional) { component.functional = true; }\n\t      }\n\n\t      component._scopeId = scope;\n\n\t      {\n\t        var hook;\n\t        if (style) {\n\t          hook = function(context) {\n\t            style.call(this, createInjector(context));\n\t          };\n\t        }\n\n\t        if (hook !== undefined) {\n\t          if (component.functional) {\n\t            // register for functional component in vue file\n\t            var originalRender = component.render;\n\t            component.render = function renderWithStyleInjection(h, context) {\n\t              hook.call(context);\n\t              return originalRender(h, context)\n\t            };\n\t          } else {\n\t            // inject component registration as beforeCreate hook\n\t            var existing = component.beforeCreate;\n\t            component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t          }\n\t        }\n\t      }\n\n\t      return component\n\t    }\n\t    /* style inject */\n\t    function __vue_create_injector__$5() {\n\t      var head = document.head || document.getElementsByTagName('head')[0];\n\t      var styles = __vue_create_injector__$5.styles || (__vue_create_injector__$5.styles = {});\n\t      var isOldIE =\n\t        typeof navigator !== 'undefined' &&\n\t        /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t      return function addStyle(id, css) {\n\t        if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t        var group = isOldIE ? css.media || 'default' : id;\n\t        var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t        if (!style.ids.includes(id)) {\n\t          var code = css.source;\n\t          var index = style.ids.length;\n\n\t          style.ids.push(id);\n\n\t          if (isOldIE) {\n\t            style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t          }\n\n\t          if (!style.element) {\n\t            var el = style.element = document.createElement('style');\n\t            el.type = 'text/css';\n\n\t            if (css.media) { el.setAttribute('media', css.media); }\n\t            if (isOldIE) {\n\t              el.setAttribute('data-group', group);\n\t              el.setAttribute('data-next-index', '0');\n\t            }\n\n\t            head.appendChild(el);\n\t          }\n\n\t          if (isOldIE) {\n\t            index = parseInt(style.element.getAttribute('data-next-index'));\n\t            style.element.setAttribute('data-next-index', index + 1);\n\t          }\n\n\t          if (style.element.styleSheet) {\n\t            style.parts.push(code);\n\t            style.element.styleSheet.cssText = style.parts\n\t              .filter(Boolean)\n\t              .join('\\n');\n\t          } else {\n\t            var textNode = document.createTextNode(code);\n\t            var nodes = style.element.childNodes;\n\t            if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t            if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t            else { style.element.appendChild(textNode); }\n\t          }\n\t        }\n\t      }\n\t    }\n\t    /* style inject SSR */\n\t    \n\n\t    \n\t    var Confirm = __vue_normalize__$5(\n\t      { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },\n\t      __vue_inject_styles__$5,\n\t      __vue_script__$5,\n\t      __vue_scope_id__$5,\n\t      __vue_is_functional_template__$5,\n\t      __vue_module_identifier__$5,\n\t      __vue_create_injector__$5,\n\t      undefined\n\t    );\n\n\t  /*\n\t   * vuedl\n\t   *\n\t   * (c) Savaryn Yaroslav <yariksav@gmail.com>\n\t   *\n\t   * For the full copyright and license information, please view the LICENSE\n\t   * file that was distributed with this source code.\n\t  */\n\t  var Plugin = {\n\t    install: function install(Vue$$1, options) {\n\t      if ( options === void 0 ) options = {};\n\n\t      var property = options.property || '$dialog';\n\t      var manager = new DialogManager(options); // const no = new Notificator(manager)\n\n\t      Object.defineProperty(Vue$$1.prototype, property, {\n\t        get: function get() {\n\t          return manager;\n\t        }\n\n\t      });\n\t      manager.layout('default', DialogLayout);\n\t      manager.layout('notification', NotificationLayout);\n\t      manager.overlay('default', DialogOverlay);\n\t      manager.component('confirm', Confirm, {\n\t        waitForResult: true,\n\t        actions: {\n\t          'false': 'Cancel',\n\t          'true': 'OK'\n\t        }\n\t      });\n\t      manager.component('warning', Confirm, {\n\t        type: 'warning',\n\t        waitForResult: true,\n\t        actions: {\n\t          'false': 'Cancel',\n\t          'true': 'OK'\n\t        }\n\t      });\n\t      manager.component('error', Confirm, {\n\t        type: 'error',\n\t        waitForResult: true,\n\t        actions: ['OK']\n\t      });\n\t    }\n\n\t  };\n\n\t  return Plugin;\n\n\t})));\n\t});\n\n\t/* @vue/component */\n\tvar Returnable = {\n\t  name: 'Returnable',\n\n\t  props: {\n\t    returnValue: null\n\t  },\n\n\t  data () {\n\t    return {\n\t      originalValue: this.returnValue,\n\t      returnResovers: []\n\t    }\n\t  },\n\n\t  // watch: {\n\t  //   'wrapper.isActive' (val) {\n\t  //     console.log('watch.isActive', val)\n\t  //     if (val) {\n\t  //       this.originalValue = this.returnValue\n\t  //     } else {\n\t  //       // console.log('emit', this.originalValue)\n\t  //       // this.$emit('submit', this.originalValue)\n\t  //       this.$emit('update:returnValue', this.originalValue)\n\t  //     }\n\t  //   }\n\t  // },\n\n\t  methods: {\n\t    return (value) {\n\t      this.originalValue = value;\n\t      this.$root.$emit('submit', this.originalValue);\n\t      this.$emit('submit', this.originalValue);\n\t    }\n\t  }\n\t}\n\n\tvar Actionable = {\n\t  name: 'Actionable',\n\n\t  mixins: [ Returnable ],\n\n\t  data () {\n\t    return {\n\t      loadingAction: null\n\t    }\n\t  },\n\n\t  props: {\n\t    actions: {\n\t      type: [Array, Object],\n\t      default: () => []\n\t    }\n\t  },\n\n\t  computed: {\n\t    actionlist () {\n\t      const actions = [];\n\t      for (let key in this.actions) {\n\t        let action = this.actions[key];\n\t        if (typeof action === 'string') {\n\t          action = {text: action};\n\t        }\n\t        this.$set(action, 'loading', false);\n\t        if (!action.key) {\n\t          action.key = isNaN(key) ? key : action.text;\n\t        }\n\t        if (['true', 'false'].indexOf(action.key) >= 0) {\n\t          action.key = JSON.parse(action.key);\n\t        }\n\t        actions.push(action);\n\t      }\n\t      return actions\n\t    }\n\t  },\n\n\t  methods: {\n\t    trigger (name) {\n\t      const action = this.actionlist.find(action => action.key === name);\n\t      if (action && !this.isActionDisabled(action) && this.isActionVisible(action)) {\n\t        this.onActionClick(action);\n\t      }\n\t    },\n\t    setLoadingToInstance (vm, value) {\n\t      if (vm && vm.loading !== undefined) {\n\t        vm.loading = value;\n\t      }\n\t    },\n\t    setLoadingState (value) {\n\t      this.$emit('loading', value);\n\t      !value && (this.loadingAction = null);\n\t      this.setLoadingToInstance(this.$root, value);\n\t      this.setLoadingToInstance(this.$root._dialogInstance, value);\n\t    },\n\t    isActionDisabled (action) {\n\t      if (action.disabled === undefined) {\n\t        return false\n\t      }\n\t      if (typeof action.disabled === 'function') {\n\t        return action.disabled()\n\t      }\n\t      return action.disabled\n\t    },\n\t    isActionVisible (action) {\n\t      if (action.visible === undefined) {\n\t        return true\n\t      }\n\t      if (typeof action.visible === 'function') {\n\t        return action.visible()\n\t      }\n\t      return action.visible\n\t    },\n\t    async onActionClick (action) {\n\t      const closable = action.closable === undefined || action.closable === true;\n\t      if (action.handle) {\n\t        this.loadingAction = action.key;\n\t        this.setLoadingState(true);\n\t        try {\n\t          let ret = await action.handle();\n\t          this.setLoadingState(false);\n\t          if (ret !== false && closable) {\n\t            this.return(ret || action.key);\n\t          }\n\t        } catch (e) {\n\t          this.setLoadingState(false);\n\t          console.log('error', e); // TODO\n\t          throw e\n\t        }\n\t      } else {\n\t        closable && this.return(action.key);\n\t      }\n\t    }\n\t  }\n\t}\n\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\t//\n\tvar script = {\n\t  name: 'BeatLoader',\n\t  props: {\n\t    loading: {\n\t      type: Boolean,\n\t      default: true\n\t    },\n\t    color: {\n\t      type: String,\n\t      default: '#5dc596'\n\t    },\n\t    size: {\n\t      type: String,\n\t      default: '15px'\n\t    },\n\t    margin: {\n\t      type: String,\n\t      default: '2px'\n\t    },\n\t    radius: {\n\t      type: String,\n\t      default: '100%'\n\t    }\n\t  },\n\n\t  data: function data() {\n\t    return {\n\t      spinnerStyle: {\n\t        backgroundColor: this.color,\n\t        height: this.size,\n\t        width: this.size,\n\t        margin: this.margin,\n\t        borderRadius: this.radius\n\t      }\n\t    };\n\t  }\n\n\t};\n\n\t/* script */\n\t            var __vue_script__ = script;\n\t            \n\t/* template */\n\tvar __vue_render__ = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\n\t    \"div\",\n\t    {\n\t      directives: [\n\t        {\n\t          name: \"show\",\n\t          rawName: \"v-show\",\n\t          value: _vm.loading,\n\t          expression: \"loading\"\n\t        }\n\t      ],\n\t      staticClass: \"v-spinner\"\n\t    },\n\t    [\n\t      _c(\"div\", { staticClass: \"v-beat v-beat-odd\", style: _vm.spinnerStyle }),\n\t      _vm._v(\" \"),\n\t      _c(\"div\", { staticClass: \"v-beat v-beat-even\", style: _vm.spinnerStyle }),\n\t      _vm._v(\" \"),\n\t      _c(\"div\", { staticClass: \"v-beat v-beat-odd\", style: _vm.spinnerStyle })\n\t    ]\n\t  )\n\t};\n\tvar __vue_staticRenderFns__ = [];\n\t__vue_render__._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__ = function (inject) {\n\t    if (!inject) { return }\n\t    inject(\"data-v-7929aa72_0\", { source: \"\\n.v-spinner .v-beat\\n{\\n    -webkit-animation: v-beatStretchDelay 0.7s infinite linear;\\n            animation: v-beatStretchDelay 0.7s infinite linear;\\n    -webkit-animation-fill-mode: both;\\n            animation-fill-mode: both;\\n    display: inline-block;\\n}\\n.v-spinner .v-beat-odd\\n{\\n  animation-delay: 0s;\\n}\\n.v-spinner .v-beat-even\\n{\\n  animation-delay: 0.35s;\\n}\\n@-webkit-keyframes v-beatStretchDelay\\n{\\n50%\\n    {\\n        -webkit-transform: scale(0.75);\\n                transform: scale(0.75);\\n        -webkit-opacity: 0.2;\\n                opacity: 0.2;\\n}\\n100%\\n    {\\n        -webkit-transform: scale(1);\\n                transform: scale(1);\\n        -webkit-opacity: 1;\\n                opacity: 1;\\n}\\n}\\n@keyframes v-beatStretchDelay\\n{\\n50%\\n    {\\n        -webkit-transform: scale(0.75);\\n                transform: scale(0.75);\\n        -webkit-opacity: 0.2;\\n                opacity: 0.2;\\n}\\n100%\\n    {\\n        -webkit-transform: scale(1);\\n                transform: scale(1);\\n        -webkit-opacity: 1;\\n                opacity: 1;\\n}\\n}\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Loader.vue\"],\"names\":[],\"mappings\":\";AAmDA;;IAEA,2DAAA;YACA,mDAAA;IACA,kCAAA;YACA,0BAAA;IACA,sBAAA;CACA;AAEA;;EAEA,oBAAA;CACA;AACA;;EAEA,uBAAA;CACA;AAEA;;AAEA;;QAEA,+BAAA;gBACA,uBAAA;QACA,qBAAA;gBACA,aAAA;CACA;AACA;;QAEA,4BAAA;gBACA,oBAAA;QACA,mBAAA;gBACA,WAAA;CACA;CACA;AAEA;;AAEA;;QAEA,+BAAA;gBACA,uBAAA;QACA,qBAAA;gBACA,aAAA;CACA;AACA;;QAEA,4BAAA;gBACA,oBAAA;QACA,mBAAA;gBACA,WAAA;CACA;CACA\",\"file\":\"Loader.vue\",\"sourcesContent\":[\"<template>\\n  <div class=\\\"v-spinner\\\" v-show=\\\"loading\\\">\\n    <div class=\\\"v-beat v-beat-odd\\\" :style=\\\"spinnerStyle\\\"/>\\n    <div class=\\\"v-beat v-beat-even\\\" :style=\\\"spinnerStyle\\\"/>\\n    <div class=\\\"v-beat v-beat-odd\\\" :style=\\\"spinnerStyle\\\"/>\\n  </div>\\n</template>\\n\\n<script>\\nexport default {\\n  name: 'BeatLoader',\\n\\n  props: {\\n    loading: {\\n      type: Boolean,\\n      default: true\\n    },\\n    color: {\\n      type: String,\\n      default: '#5dc596'\\n    },\\n    size: {\\n      type: String,\\n      default: '15px'\\n    },\\n    margin: {\\n      type: String,\\n      default: '2px'\\n    },\\n    radius: {\\n      type: String,\\n      default: '100%'\\n    }\\n  },\\n  data () {\\n    return {\\n      spinnerStyle: {\\n        backgroundColor: this.color,\\n        height: this.size,\\n        width: this.size,\\n        margin: this.margin,\\n        borderRadius: this.radius\\n      }\\n    }\\n  }\\n\\n}\\n</script>\\n\\n<style>\\n\\n.v-spinner .v-beat\\n{\\n    -webkit-animation: v-beatStretchDelay 0.7s infinite linear;\\n            animation: v-beatStretchDelay 0.7s infinite linear;\\n    -webkit-animation-fill-mode: both;\\n            animation-fill-mode: both;\\n    display: inline-block;\\n}\\n\\n.v-spinner .v-beat-odd\\n{\\n  animation-delay: 0s;\\n}\\n.v-spinner .v-beat-even\\n{\\n  animation-delay: 0.35s;\\n}\\n\\n@-webkit-keyframes v-beatStretchDelay\\n{\\n    50%\\n    {\\n        -webkit-transform: scale(0.75);\\n                transform: scale(0.75);\\n        -webkit-opacity: 0.2;\\n                opacity: 0.2;\\n    }\\n    100%\\n    {\\n        -webkit-transform: scale(1);\\n                transform: scale(1);\\n        -webkit-opacity: 1;\\n                opacity: 1;\\n    }\\n}\\n\\n@keyframes v-beatStretchDelay\\n{\\n    50%\\n    {\\n        -webkit-transform: scale(0.75);\\n                transform: scale(0.75);\\n        -webkit-opacity: 0.2;\\n                opacity: 0.2;\\n    }\\n    100%\\n    {\\n        -webkit-transform: scale(1);\\n                transform: scale(1);\\n        -webkit-opacity: 1;\\n                opacity: 1;\\n    }\\n}\\n</style>\\n\"]}, media: undefined });\n\n\t  };\n\t  /* scoped */\n\t  var __vue_scope_id__ = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__ = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__ = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__(\n\t    template, style, script$$1,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script$$1 === 'function' ? script$$1.options : script$$1) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Loader.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    {\n\t      var hook;\n\t      if (style) {\n\t        hook = function(context) {\n\t          style.call(this, createInjector(context));\n\t        };\n\t      }\n\n\t      if (hook !== undefined) {\n\t        if (component.functional) {\n\t          // register for functional component in vue file\n\t          var originalRender = component.render;\n\t          component.render = function renderWithStyleInjection(h, context) {\n\t            hook.call(context);\n\t            return originalRender(h, context)\n\t          };\n\t        } else {\n\t          // inject component registration as beforeCreate hook\n\t          var existing = component.beforeCreate;\n\t          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t        }\n\t      }\n\t    }\n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  function __vue_create_injector__() {\n\t    var head = document.head || document.getElementsByTagName('head')[0];\n\t    var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});\n\t    var isOldIE =\n\t      typeof navigator !== 'undefined' &&\n\t      /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t    return function addStyle(id, css) {\n\t      if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t      var group = isOldIE ? css.media || 'default' : id;\n\t      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t      if (!style.ids.includes(id)) {\n\t        var code = css.source;\n\t        var index = style.ids.length;\n\n\t        style.ids.push(id);\n\n\t        if (isOldIE) {\n\t          style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t        }\n\n\t        if (!style.element) {\n\t          var el = style.element = document.createElement('style');\n\t          el.type = 'text/css';\n\n\t          if (css.media) { el.setAttribute('media', css.media); }\n\t          if (isOldIE) {\n\t            el.setAttribute('data-group', group);\n\t            el.setAttribute('data-next-index', '0');\n\t          }\n\n\t          head.appendChild(el);\n\t        }\n\n\t        if (isOldIE) {\n\t          index = parseInt(style.element.getAttribute('data-next-index'));\n\t          style.element.setAttribute('data-next-index', index + 1);\n\t        }\n\n\t        if (style.element.styleSheet) {\n\t          style.parts.push(code);\n\t          style.element.styleSheet.cssText = style.parts\n\t            .filter(Boolean)\n\t            .join('\\n');\n\t        } else {\n\t          var textNode = document.createTextNode(code);\n\t          var nodes = style.element.childNodes;\n\t          if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t          else { style.element.appendChild(textNode); }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var Loader = __vue_normalize__(\n\t    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },\n\t    __vue_inject_styles__,\n\t    __vue_script__,\n\t    __vue_scope_id__,\n\t    __vue_is_functional_template__,\n\t    __vue_module_identifier__,\n\t    __vue_create_injector__,\n\t    undefined\n\t  )\n\n\t//\n\tvar script$1 = {\n\t  components: {\n\t    Loader: Loader\n\t  },\n\t  mixins: [Actionable],\n\t  props: {\n\t    variant: {\n\t      type: String,\n\t      default: 'outline-primary'\n\t    }\n\t  }\n\t};\n\n\t/* script */\n\t            var __vue_script__$1 = script$1;\n\t            \n\t/* template */\n\tvar __vue_render__$1 = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\n\t    \"span\",\n\t    { staticClass: \"dialog-actions\" },\n\t    _vm._l(_vm.actionlist, function(action) {\n\t      return _c(\n\t        \"b-btn\",\n\t        {\n\t          key: action.key,\n\t          attrs: {\n\t            variant: action.variant || _vm.variant,\n\t            loading: _vm.loadingAction === action.key,\n\t            disabled: _vm.isActionDisabled(action) || !!_vm.loadingAction\n\t          },\n\t          on: {\n\t            click: function($event) {\n\t              _vm.onActionClick(action);\n\t            }\n\t          }\n\t        },\n\t        [\n\t          _vm.loadingAction === action.key\n\t            ? _c(\"Loader\", { attrs: { size: \"8px\" } })\n\t            : [_vm._v(_vm._s(action.text))]\n\t        ],\n\t        2\n\t      )\n\t    })\n\t  )\n\t};\n\tvar __vue_staticRenderFns__$1 = [];\n\t__vue_render__$1._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__$1 = function (inject) {\n\t    if (!inject) { return }\n\t    inject(\"data-v-b0725018_0\", { source: \"\\n.dialog-actions button {\\n   margin-right: 4px;\\n   margin-right: .25rem;\\n}\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogActions.vue\"],\"names\":[],\"mappings\":\";AA+BA;GACA,kBAAA;GACA,qBAAA;CACA\",\"file\":\"DialogActions.vue\",\"sourcesContent\":[\"<template>\\n  <span class=\\\"dialog-actions\\\">\\n    <b-btn v-for=\\\"action in actionlist\\\" :key=\\\"action.key\\\"\\n      :variant=\\\"action.variant || variant\\\"\\n      :loading=\\\"loadingAction === action.key\\\"\\n      :disabled=\\\"isActionDisabled(action) || !!loadingAction\\\"\\n      @click=\\\"onActionClick(action)\\\">\\n      <Loader v-if=\\\"loadingAction === action.key\\\" size=\\\"8px\\\"/>\\n      <template v-else>{{ action.text }}</template>\\n    </b-btn>\\n  </span>\\n</template>\\n<script>\\n\\nimport Actionable from 'vuedl/src/mixins/actionable'\\nimport Loader from './Loader.vue'\\n\\nexport default {\\n  components: {\\n    Loader\\n  },\\n  mixins: [ Actionable ],\\n  props: {\\n    variant: {\\n      type: String,\\n      default: 'outline-primary'\\n    }\\n  }\\n}\\n</script>\\n<style>\\n  .dialog-actions button {\\n     margin-right: 4px;\\n     margin-right: .25rem;\\n  }\\n</style>\\n\"]}, media: undefined });\n\n\t  };\n\t  /* scoped */\n\t  var __vue_scope_id__$1 = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__$1 = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__$1 = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__$1(\n\t    template, style, script,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogActions.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    {\n\t      var hook;\n\t      if (style) {\n\t        hook = function(context) {\n\t          style.call(this, createInjector(context));\n\t        };\n\t      }\n\n\t      if (hook !== undefined) {\n\t        if (component.functional) {\n\t          // register for functional component in vue file\n\t          var originalRender = component.render;\n\t          component.render = function renderWithStyleInjection(h, context) {\n\t            hook.call(context);\n\t            return originalRender(h, context)\n\t          };\n\t        } else {\n\t          // inject component registration as beforeCreate hook\n\t          var existing = component.beforeCreate;\n\t          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t        }\n\t      }\n\t    }\n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  function __vue_create_injector__$1() {\n\t    var head = document.head || document.getElementsByTagName('head')[0];\n\t    var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});\n\t    var isOldIE =\n\t      typeof navigator !== 'undefined' &&\n\t      /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t    return function addStyle(id, css) {\n\t      if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t      var group = isOldIE ? css.media || 'default' : id;\n\t      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t      if (!style.ids.includes(id)) {\n\t        var code = css.source;\n\t        var index = style.ids.length;\n\n\t        style.ids.push(id);\n\n\t        if (isOldIE) {\n\t          style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t        }\n\n\t        if (!style.element) {\n\t          var el = style.element = document.createElement('style');\n\t          el.type = 'text/css';\n\n\t          if (css.media) { el.setAttribute('media', css.media); }\n\t          if (isOldIE) {\n\t            el.setAttribute('data-group', group);\n\t            el.setAttribute('data-next-index', '0');\n\t          }\n\n\t          head.appendChild(el);\n\t        }\n\n\t        if (isOldIE) {\n\t          index = parseInt(style.element.getAttribute('data-next-index'));\n\t          style.element.setAttribute('data-next-index', index + 1);\n\t        }\n\n\t        if (style.element.styleSheet) {\n\t          style.parts.push(code);\n\t          style.element.styleSheet.cssText = style.parts\n\t            .filter(Boolean)\n\t            .join('\\n');\n\t        } else {\n\t          var textNode = document.createTextNode(code);\n\t          var nodes = style.element.childNodes;\n\t          if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t          else { style.element.appendChild(textNode); }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var DialogActions = __vue_normalize__$1(\n\t    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },\n\t    __vue_inject_styles__$1,\n\t    __vue_script__$1,\n\t    __vue_scope_id__$1,\n\t    __vue_is_functional_template__$1,\n\t    __vue_module_identifier__$1,\n\t    __vue_create_injector__$1,\n\t    undefined\n\t  )\n\n\t//\n\tvar zIndex = 1100;\n\tvar script$2 = {\n\t  components: {\n\t    DialogActions: DialogActions\n\t  },\n\t  props: {\n\t    size: {\n\t      type: String,\n\t      default: function () {\n\t        'md';\n\t      }\n\t    },\n\t    title: String,\n\t    actions: [Array, Object],\n\t    hideBackdrop: Boolean,\n\t    centered: Boolean\n\t  },\n\t  methods: {\n\t    _destroy: function _destroy() {// stub\n\t    },\n\n\t    onModalHidden: function onModalHidden() {\n\t      zIndex = zIndex - 2;\n\t      this.$destroy();\n\t    },\n\n\t    onModalShown: function onModalShown(ev) {\n\t      var parent = ev.target.parentElement;\n\t      var backdrop = parent.querySelector('.modal-backdrop');\n\t      backdrop && backdrop.style && (backdrop.style['z-index'] = ++zIndex);\n\t      var modal = parent.querySelector('.modal');\n\t      modal && modal.style && (modal.style['z-index'] = ++zIndex);\n\t    }\n\n\t  }\n\t};\n\n\t/* script */\n\t            var __vue_script__$2 = script$2;\n\t            \n\t/* template */\n\tvar __vue_render__$2 = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\n\t    \"b-modal\",\n\t    {\n\t      staticClass: \"dialog-layout\",\n\t      attrs: {\n\t        \"hide-header\": \"\",\n\t        \"hide-footer\": \"\",\n\t        \"hide-backdrop\": _vm.hideBackdrop,\n\t        centered: _vm.centered,\n\t        size: _vm.size,\n\t        \"body-class\": \"dialog-layout-modal-body\",\n\t        \"no-close-on-backdrop\": _vm.persistent || _vm.loading,\n\t        \"no-close-on-esc\": _vm.persistent || _vm.loading\n\t      },\n\t      on: { hidden: _vm.onModalHidden, shown: _vm.onModalShown },\n\t      model: {\n\t        value: _vm.isActive,\n\t        callback: function($$v) {\n\t          _vm.isActive = $$v;\n\t        },\n\t        expression: \"isActive\"\n\t      }\n\t    },\n\t    [_vm._t(\"default\")],\n\t    2\n\t  )\n\t};\n\tvar __vue_staticRenderFns__$2 = [];\n\t__vue_render__$2._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__$2 = function (inject) {\n\t    if (!inject) { return }\n\t    inject(\"data-v-0f764872_0\", { source: \"\\n.dialog-layout-modal-body {\\n  padding: 0;\\n}\\n\", map: {\"version\":3,\"sources\":[\"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogLayout.vue\"],\"names\":[],\"mappings\":\";AAwDA;EACA,WAAA;CACA\",\"file\":\"DialogLayout.vue\",\"sourcesContent\":[\"<template>\\n  <b-modal v-model=\\\"isActive\\\"\\n    class=\\\"dialog-layout\\\"\\n    hide-header\\n    hide-footer\\n    :hide-backdrop=\\\"hideBackdrop\\\"\\n    :centered=\\\"centered\\\"\\n    :size=\\\"size\\\"\\n    body-class=\\\"dialog-layout-modal-body\\\"\\n    :no-close-on-backdrop=\\\"persistent || loading\\\"\\n    :no-close-on-esc=\\\"persistent || loading\\\"\\n    @hidden=\\\"onModalHidden\\\"\\n    @shown=\\\"onModalShown\\\">\\n    <slot/>\\n  </b-modal>\\n</template>\\n\\n<script>\\n\\nimport DialogActions from './DialogActions.vue'\\n\\nlet zIndex = 1100\\n\\nexport default {\\n  components: {\\n    DialogActions\\n  },\\n  props: {\\n    size: {\\n      type: String,\\n      default: () => { 'md' }\\n    },\\n    title: String,\\n    actions: [Array, Object],\\n    hideBackdrop: Boolean,\\n    centered: Boolean\\n  },\\n  methods: {\\n    _destroy () {\\n      // stub\\n    },\\n    onModalHidden () {\\n      zIndex = zIndex - 2\\n      this.$destroy()\\n    },\\n    onModalShown (ev) {\\n      const parent = ev.target.parentElement\\n      const backdrop = parent.querySelector('.modal-backdrop')\\n      backdrop && backdrop.style && (backdrop.style['z-index'] = ++zIndex)\\n      const modal = parent.querySelector('.modal')\\n      modal && modal.style && (modal.style['z-index'] = ++zIndex)\\n    }\\n  }\\n}\\n</script>\\n<style>\\n  .dialog-layout-modal-body {\\n    padding: 0;\\n  }\\n</style>\\n\"]}, media: undefined });\n\n\t  };\n\t  /* scoped */\n\t  var __vue_scope_id__$2 = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__$2 = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__$2 = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__$2(\n\t    template, style, script,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogLayout.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    {\n\t      var hook;\n\t      if (style) {\n\t        hook = function(context) {\n\t          style.call(this, createInjector(context));\n\t        };\n\t      }\n\n\t      if (hook !== undefined) {\n\t        if (component.functional) {\n\t          // register for functional component in vue file\n\t          var originalRender = component.render;\n\t          component.render = function renderWithStyleInjection(h, context) {\n\t            hook.call(context);\n\t            return originalRender(h, context)\n\t          };\n\t        } else {\n\t          // inject component registration as beforeCreate hook\n\t          var existing = component.beforeCreate;\n\t          component.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n\t        }\n\t      }\n\t    }\n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  function __vue_create_injector__$2() {\n\t    var head = document.head || document.getElementsByTagName('head')[0];\n\t    var styles = __vue_create_injector__$2.styles || (__vue_create_injector__$2.styles = {});\n\t    var isOldIE =\n\t      typeof navigator !== 'undefined' &&\n\t      /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\n\n\t    return function addStyle(id, css) {\n\t      if (document.querySelector('style[data-vue-ssr-id~=\"' + id + '\"]')) { return } // SSR styles are present.\n\n\t      var group = isOldIE ? css.media || 'default' : id;\n\t      var style = styles[group] || (styles[group] = { ids: [], parts: [], element: undefined });\n\n\t      if (!style.ids.includes(id)) {\n\t        var code = css.source;\n\t        var index = style.ids.length;\n\n\t        style.ids.push(id);\n\n\t        if (isOldIE) {\n\t          style.element = style.element || document.querySelector('style[data-group=' + group + ']');\n\t        }\n\n\t        if (!style.element) {\n\t          var el = style.element = document.createElement('style');\n\t          el.type = 'text/css';\n\n\t          if (css.media) { el.setAttribute('media', css.media); }\n\t          if (isOldIE) {\n\t            el.setAttribute('data-group', group);\n\t            el.setAttribute('data-next-index', '0');\n\t          }\n\n\t          head.appendChild(el);\n\t        }\n\n\t        if (isOldIE) {\n\t          index = parseInt(style.element.getAttribute('data-next-index'));\n\t          style.element.setAttribute('data-next-index', index + 1);\n\t        }\n\n\t        if (style.element.styleSheet) {\n\t          style.parts.push(code);\n\t          style.element.styleSheet.cssText = style.parts\n\t            .filter(Boolean)\n\t            .join('\\n');\n\t        } else {\n\t          var textNode = document.createTextNode(code);\n\t          var nodes = style.element.childNodes;\n\t          if (nodes[index]) { style.element.removeChild(nodes[index]); }\n\t          if (nodes.length) { style.element.insertBefore(textNode, nodes[index]); }\n\t          else { style.element.appendChild(textNode); }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var DialogLayout = __vue_normalize__$2(\n\t    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },\n\t    __vue_inject_styles__$2,\n\t    __vue_script__$2,\n\t    __vue_scope_id__$2,\n\t    __vue_is_functional_template__$2,\n\t    __vue_module_identifier__$2,\n\t    __vue_create_injector__$2,\n\t    undefined\n\t  )\n\n\tvar Confirmable = {\n\t  name: 'Confirmable',\n\n\t  props: {\n\t    type: {\n\t      type: String\n\t    },\n\t    text: {\n\t      type: String,\n\t      reqiured: true\n\t    },\n\t    title: {\n\t      type: String\n\t    },\n\t    actions: {\n\t      type: [Array, Object]\n\t    }\n\t  }\n\t}\n\n\tvar Colorable = {\n\t  props: {\n\t    type: String,\n\t    color: String\n\t  },\n\t  computed: {\n\t    getColor: function getColor() {\n\t      return this.color || this.type;\n\t    }\n\n\t  }\n\t};\n\n\t//\n\tvar script$3 = {\n\t  components: {\n\t    DialogActions: DialogActions\n\t  },\n\t  layout: 'default',\n\t  mixins: [Confirmable, Colorable],\n\t  computed: {\n\t    headerTextVariant: function headerTextVariant() {\n\t      return ['info', 'danger'].indexOf(this.type) >= 0 ? 'light' : 'dark';\n\t    }\n\n\t  }\n\t};\n\n\t/* script */\n\t            var __vue_script__$3 = script$3;\n\t            \n\t/* template */\n\tvar __vue_render__$3 = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\n\t    \"div\",\n\t    [\n\t      _c(\n\t        \"DialogCard\",\n\t        {\n\t          attrs: {\n\t            actions: _vm.actions,\n\t            title: _vm.title,\n\t            \"header-bg-variant\": _vm.type,\n\t            \"header-text-variant\": _vm.headerTextVariant\n\t          }\n\t        },\n\t        [\n\t          _c(\"div\", {\n\t            staticClass: \"dialog-confirm-text\",\n\t            domProps: { innerHTML: _vm._s(_vm.text) }\n\t          })\n\t        ]\n\t      )\n\t    ],\n\t    1\n\t  )\n\t};\n\tvar __vue_staticRenderFns__$3 = [];\n\t__vue_render__$3._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__$3 = undefined;\n\t  /* scoped */\n\t  var __vue_scope_id__$3 = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__$3 = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__$3 = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__$3(\n\t    template, style, script,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Confirm.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    \n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  \n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var Confirm = __vue_normalize__$3(\n\t    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },\n\t    __vue_inject_styles__$3,\n\t    __vue_script__$3,\n\t    __vue_scope_id__$3,\n\t    __vue_is_functional_template__$3,\n\t    __vue_module_identifier__$3,\n\t    undefined,\n\t    undefined\n\t  )\n\n\t//\n\tvar script$4 = {\n\t  components: {\n\t    DialogActions: DialogActions\n\t  },\n\t  layout: ['notification', {\n\t    showClose: false\n\t  }],\n\t  props: {\n\t    type: {\n\t      type: String,\n\t      default: function () { return 'info'; }\n\t    },\n\t    actions: [Array, Object],\n\t    text: String,\n\t    dismissible: {\n\t      type: Boolean,\n\t      default: true\n\t    }\n\t  }\n\t};\n\n\t/* script */\n\t            var __vue_script__$4 = script$4;\n\t            \n\t/* template */\n\tvar __vue_render__$4 = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\n\t    \"b-alert\",\n\t    {\n\t      staticStyle: { \"margin-bottom\": \"0\" },\n\t      attrs: { show: \"\", variant: _vm.type, dismissible: _vm.dismissible },\n\t      on: {\n\t        dismissed: function($event) {\n\t          _vm.$emit(\"submit\");\n\t        }\n\t      }\n\t    },\n\t    [_c(\"span\", { domProps: { innerHTML: _vm._s(_vm.text) } })]\n\t  )\n\t};\n\tvar __vue_staticRenderFns__$4 = [];\n\t__vue_render__$4._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__$4 = undefined;\n\t  /* scoped */\n\t  var __vue_scope_id__$4 = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__$4 = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__$4 = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__$4(\n\t    template, style, script,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Alert.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    \n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  \n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var Alert = __vue_normalize__$4(\n\t    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },\n\t    __vue_inject_styles__$4,\n\t    __vue_script__$4,\n\t    __vue_scope_id__$4,\n\t    __vue_is_functional_template__$4,\n\t    __vue_module_identifier__$4,\n\t    undefined,\n\t    undefined\n\t  )\n\n\t//\n\tvar script$5 = {\n\t  components: {\n\t    DialogActions: DialogActions\n\t  },\n\t  props: {\n\t    title: String,\n\t    actions: [Array, Object],\n\t    headerBgVariant: String,\n\t    headerTextVariant: String,\n\t    headerBorderVariant: String,\n\t    headerClass: String\n\t  },\n\t  computed: {\n\t    headerClasses: function headerClasses() {\n\t      var obj;\n\n\t      return ['modal-header', ( obj = {}, obj[(\"bg-\" + (this.headerBgVariant))] = Boolean(this.headerBgVariant), obj[(\"text-\" + (this.headerTextVariant))] = Boolean(this.headerTextVariant), obj[(\"border-\" + (this.headerBorderVariant))] = Boolean(this.headerBorderVariant), obj), this.headerClass];\n\t    }\n\n\t  },\n\t  methods: {\n\t    trigger: function trigger(name) {\n\t      this.$refs.actions && this.$refs.actions.trigger(name);\n\t    }\n\n\t  }\n\t};\n\n\t/* script */\n\t            var __vue_script__$5 = script$5;\n\t            \n\t/* template */\n\tvar __vue_render__$5 = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\"div\", [\n\t    _c(\n\t      \"header\",\n\t      { class: _vm.headerClasses },\n\t      [\n\t        _vm._t(\"title\", [\n\t          _c(\"h5\", { staticClass: \"modal-title\" }, [_vm._v(_vm._s(_vm.title))])\n\t        ]),\n\t        _vm._v(\" \"),\n\t        _c(\n\t          \"button\",\n\t          {\n\t            staticClass: \"close\",\n\t            attrs: { type: \"button\", \"aria-label\": \"Close\" }\n\t          },\n\t          [_vm._v(\"×\")]\n\t        )\n\t      ],\n\t      2\n\t    ),\n\t    _vm._v(\" \"),\n\t    _c(\"div\", { staticClass: \"modal-body\" }, [_vm._t(\"default\")], 2),\n\t    _vm._v(\" \"),\n\t    _vm.actions\n\t      ? _c(\n\t          \"footer\",\n\t          { staticClass: \"modal-footer\" },\n\t          [\n\t            _c(\"DialogActions\", {\n\t              ref: \"actions\",\n\t              attrs: { actions: _vm.actions }\n\t            })\n\t          ],\n\t          1\n\t        )\n\t      : _vm._e()\n\t  ])\n\t};\n\tvar __vue_staticRenderFns__$5 = [];\n\t__vue_render__$5._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__$5 = undefined;\n\t  /* scoped */\n\t  var __vue_scope_id__$5 = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__$5 = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__$5 = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__$5(\n\t    template, style, script,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/DialogCard.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    \n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  \n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var DialogCard = __vue_normalize__$5(\n\t    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },\n\t    __vue_inject_styles__$5,\n\t    __vue_script__$5,\n\t    __vue_scope_id__$5,\n\t    __vue_is_functional_template__$5,\n\t    __vue_module_identifier__$5,\n\t    undefined,\n\t    undefined\n\t  )\n\n\t//\n\tvar script$6 = {\n\t  components: {\n\t    DialogCard: DialogCard\n\t  },\n\t  layout: 'default',\n\t  mixins: [Confirmable],\n\t  props: {\n\t    value: String\n\t  },\n\t  computed: {\n\t    parsedActions: function parsedActions() {\n\t      var actions = this.actions;\n\n\t      if (actions[true]) {\n\t        if (typeof actions[true] === 'string') {\n\t          actions[true] = {\n\t            'text': actions[true],\n\t            handle: this.onSubmit\n\t          };\n\t        } else {\n\t          actions[true].handle = this.onSubmit;\n\t        }\n\t      }\n\n\t      return actions;\n\t    }\n\n\t  },\n\n\t  data: function data() {\n\t    return {\n\t      editedValue: this.value\n\t    };\n\t  },\n\n\t  methods: {\n\t    onSubmit: function onSubmit() {\n\t      this.$emit('submit', this.editedValue);\n\t    }\n\n\t  }\n\t};\n\n\t/* script */\n\t            var __vue_script__$6 = script$6;\n\t            \n\t/* template */\n\tvar __vue_render__$6 = function() {\n\t  var _vm = this;\n\t  var _h = _vm.$createElement;\n\t  var _c = _vm._self._c || _h;\n\t  return _c(\n\t    \"div\",\n\t    [\n\t      _c(\n\t        \"DialogCard\",\n\t        { attrs: { title: _vm.title, actions: _vm.parsedActions } },\n\t        [\n\t          _c(\"b-form-input\", {\n\t            attrs: { autofocus: \"\", placeholder: _vm.text, required: \"\" },\n\t            on: {\n\t              keypress: function($event) {\n\t                if (\n\t                  !(\"button\" in $event) &&\n\t                  _vm._k($event.keyCode, \"enter\", 13, $event.key, \"Enter\")\n\t                ) {\n\t                  return null\n\t                }\n\t                return _vm.onSubmit($event)\n\t              }\n\t            },\n\t            model: {\n\t              value: _vm.editedValue,\n\t              callback: function($$v) {\n\t                _vm.editedValue = $$v;\n\t              },\n\t              expression: \"editedValue\"\n\t            }\n\t          })\n\t        ],\n\t        1\n\t      )\n\t    ],\n\t    1\n\t  )\n\t};\n\tvar __vue_staticRenderFns__$6 = [];\n\t__vue_render__$6._withStripped = true;\n\n\t  /* style */\n\t  var __vue_inject_styles__$6 = undefined;\n\t  /* scoped */\n\t  var __vue_scope_id__$6 = undefined;\n\t  /* module identifier */\n\t  var __vue_module_identifier__$6 = undefined;\n\t  /* functional template */\n\t  var __vue_is_functional_template__$6 = false;\n\t  /* component normalizer */\n\t  function __vue_normalize__$6(\n\t    template, style, script,\n\t    scope, functional, moduleIdentifier,\n\t    createInjector, createInjectorSSR\n\t  ) {\n\t    var component = (typeof script === 'function' ? script.options : script) || {};\n\n\t    // For security concerns, we use only base name in production mode.\n\t    component.__file = \"/Users/yarik/Projects/clones/bootstrap-vue-dialog/src/components/Prompt.vue\";\n\n\t    if (!component.render) {\n\t      component.render = template.render;\n\t      component.staticRenderFns = template.staticRenderFns;\n\t      component._compiled = true;\n\n\t      if (functional) { component.functional = true; }\n\t    }\n\n\t    component._scopeId = scope;\n\n\t    \n\n\t    return component\n\t  }\n\t  /* style inject */\n\t  \n\t  /* style inject SSR */\n\t  \n\n\t  \n\t  var Prompt = __vue_normalize__$6(\n\t    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },\n\t    __vue_inject_styles__$6,\n\t    __vue_script__$6,\n\t    __vue_scope_id__$6,\n\t    __vue_is_functional_template__$6,\n\t    __vue_module_identifier__$6,\n\t    undefined,\n\t    undefined\n\t  )\n\n\tvar Plugin = {\n\t  install: function install(Vue, options) {\n\t    if ( options === void 0 ) options = {};\n\n\t    var property = options.property || '$dialog'; // const messageProperty = options.messageProperty\n\n\t    Vue.use(vuedl, options);\n\t    var manager = Vue.prototype[property];\n\t    manager.layout('default', DialogLayout);\n\t    Vue.component('DialogActions', DialogActions);\n\t    Vue.component('DialogCard', DialogCard);\n\t    manager.on('show', function () {\n\t      document.body.classList.remove('modal-open');\n\t    });\n\t    manager.component('confirm', Confirm, {\n\t      waitForResult: true,\n\t      actions: {\n\t        'false': 'Cancel',\n\t        'true': 'OK'\n\t      }\n\t    });\n\t    manager.component('warning', Confirm, {\n\t      type: 'warning',\n\t      waitForResult: true,\n\t      actions: {\n\t        'false': 'Cancel',\n\t        'true': 'OK'\n\t      }\n\t    });\n\t    manager.component('info', Confirm, {\n\t      type: 'info',\n\t      waitForResult: true,\n\t      actions: {\n\t        'false': 'Cancel',\n\t        'true': 'OK'\n\t      }\n\t    });\n\t    manager.component('error', Confirm, {\n\t      type: 'danger',\n\t      waitForResult: true,\n\t      actions: ['Close']\n\t    }); // manager.component('toast', Toast, {\n\t    //   waitForResult: true\n\t    // })\n\t    // manager.message = {\n\t    //   info: (message, options) => manager.toast({ text: message, variant: 'info', ...options }),\n\t    //   error: (message, options) => manager.toast({ text: message, variant: 'danger', ...options }),\n\t    //   success: (message, options) => manager.toast({ text: message, variant: 'success', ...options }),\n\t    //   warning: (message, options) => manager.toast({ text: message, variant: 'warning', ...options })\n\t    // }\n\t    // messageProperty && (Vue.prototype[messageProperty] = manager.message)\n\n\t    manager.component('alert', Alert, {\n\t      waitForResult: true\n\t    });\n\t    manager.notify = {\n\t      info: function (message, options) { return manager.alert(Object.assign({\n\t        text: message,\n\t        type: 'info'\n\t      }, options)); },\n\t      error: function (message, options) { return manager.alert(Object.assign({\n\t        text: message,\n\t        type: 'danger'\n\t      }, options)); },\n\t      success: function (message, options) { return manager.alert(Object.assign({\n\t        text: message,\n\t        type: 'success'\n\t      }, options)); },\n\t      warning: function (message, options) { return manager.alert(Object.assign({\n\t        text: message,\n\t        type: 'warning'\n\t      }, options)); }\n\t    };\n\t    manager.component('prompt', Prompt, {\n\t      waitForResult: true,\n\t      actions: {\n\t        false: 'Cancel',\n\t        true: 'OK'\n\t      }\n\t    });\n\t  }\n\n\t};\n\n\treturn Plugin;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXZ1ZS1kaWFsb2cvZGlzdC9ib290c3RyYXAtdnVlLWRpYWxvZy5qcz9kN2U0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsQ0FBQyxLQUE0RCw0QkFBNEIsbUJBQU8sQ0FBQyxrREFBSztBQUN0RyxDQUFDLFNBQ2lEO0FBQ2xELENBQUMsd0JBQXdCOztBQUV6Qjs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZLEVBQUU7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQyxRQUFRO0FBQ1I7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsWUFBWSxFQUFFO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLEVBQUU7QUFDaEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLEVBQUU7QUFDaEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBLE1BQU07QUFDTixJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBb0I7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxNQUFNO0FBQ3BCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQixFQUFFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBb0I7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBb0I7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTs7QUFFSjtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE1BQU07QUFDcEIsY0FBYyxPQUFPLFdBQVc7QUFDaEMsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFNBQVM7QUFDdkIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGNBQWMsUUFBUTtBQUN0QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsU0FBUztBQUN2QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUU7QUFDaEIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsRUFBRTtBQUNoQixjQUFjLE1BQU07QUFDcEIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLE9BQU87QUFDckIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0EsY0FBYyxTQUFTLEdBQUcsU0FBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsRUFBRTtBQUNoQixjQUFjLEVBQUU7QUFDaEIsY0FBYyxFQUFFO0FBQ2hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLFVBQVU7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLEdBQUcsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVMsR0FBRyxTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUSxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsNkJBQTZCO0FBQ3ZEOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsU0FBUzs7QUFFdkY7QUFDQSx3REFBd0QseUNBQXlDOztBQUVqRztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIscUNBQXFDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUF5QztBQUN6RSxnQ0FBZ0Msb0RBQW9EO0FBQ3BGLG1CQUFtQixxQ0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0EsUUFBUSxtRUFBbUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFdBQVcsRUFBRTs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYyxPQUFPO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFNBQVM7QUFDekIsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsbURBQW1ELHlCQUF5QjtBQUM1Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBLFFBQVEsdUVBQXVFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQSw4REFBOEQsNEJBQTRCLEVBQUU7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FB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QUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFD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TUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFO0FBQ1I7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxxREFBcUQsNkNBQTZDO0FBQ2xHLHNEQUFzRCwrQ0FBK0M7QUFDckcsd0RBQXdELGdEQUFnRDtBQUN4Ryx3REFBd0QsZ0RBQWdEO0FBQ3hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsUUFBUSxZQUFZLEVBQUU7QUFDdEIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxRQUFRLFlBQVksRUFBRTtBQUN0Qiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVEsWUFBWSxFQUFFO0FBQ3RCLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXZ1ZS1kaWFsb2cvZGlzdC9ib290c3RyYXAtdnVlLWRpYWxvZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCd2dWUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWyd2dWUnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLmJvb3RzdHJhcFZ1ZURpYWxvZyA9IGZhY3RvcnkoZ2xvYmFsLlZ1ZSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKHZ1ZSkgeyAndXNlIHN0cmljdCc7XG5cblx0dnVlID0gdnVlICYmIHZ1ZS5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gdnVlWydkZWZhdWx0J10gOiB2dWU7XG5cblx0dmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHR9XG5cblx0dmFyIHZ1ZWRsID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSh2dWUpO1xuXHR9KGNvbW1vbmpzR2xvYmFsLCAoZnVuY3Rpb24gKFZ1ZSkge1xuXHQgIFZ1ZSA9IFZ1ZSAmJiBWdWUuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IFZ1ZVsnZGVmYXVsdCddIDogVnVlO1xuXG5cdCAgdmFyIFJlY29yZGFibGUgPSB7XG5cdCAgICBjb21wdXRlZDoge1xuXHQgICAgICAkcGFyYW1ldGVyczogZnVuY3Rpb24gJHBhcmFtZXRlcnMoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMucHJvcHNEYXRhO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIGlzTmV3UmVjb3JkOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICF0aGlzLiRvcHRpb25zLnByaW1hcnlLZXkgfHwgIXRoaXMuJG9wdGlvbnMucHJvcHNEYXRhIHx8ICF0aGlzLiRvcHRpb25zLnByb3BzRGF0YVt0aGlzLiRvcHRpb25zLnByaW1hcnlLZXldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBBY3RpdmFibGUgPSB7XG5cdCAgICBuYW1lOiAnQWN0aXZhYmxlJyxcblxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBpc0FjdGl2ZTogZmFsc2Vcblx0ICAgICAgfTtcblx0ICAgIH0sXG5cblx0ICAgIHdhdGNoOiB7XG5cdCAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbiBpc0FjdGl2ZSh2YWwpIHtcblx0ICAgICAgICAvLyBkZWJ1Z2dlclxuXHQgICAgICAgIC8vIGlmICh0aGlzLmlzTGF5b3V0KSB7XG5cdCAgICAgICAgLy8gdGhpcy4kY2hpbGRyZW4uZm9yRWFjaCh2bSA9PiB7XG5cdCAgICAgICAgLy8gICBpZiAodm0uaXNBY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIC8vICAgICB2bS5pc0FjdGl2ZSA9IHZhbFxuXHQgICAgICAgIC8vICAgfVxuXHQgICAgICAgIC8vIH0pXG5cdCAgICAgICAgaWYgKHRoaXMuX2RpYWxvZ0luc3RhbmNlKSB7XG5cdCAgICAgICAgICBpZiAodGhpcy5fZGlhbG9nSW5zdGFuY2UuaXNBY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB0aGlzLl9kaWFsb2dJbnN0YW5jZS5pc0FjdGl2ZSA9IHZhbDtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgaWYgKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuaXNBY3RpdmUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICB0aGlzLiRwYXJlbnQuaXNBY3RpdmUgPSB2YWw7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgIH0sXG5cdCAgICBtZXRob2RzOiB7XG5cdCAgICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0ICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG5cdCAgICAgIH1cblxuXHQgICAgfVxuXHQgIH07XG5cblx0ICB2YXIgTGF5b3V0YWJsZSA9IHtcblx0ICAgIG5hbWU6ICdMYXlvdXRhYmxlJyxcblx0ICAgIG1peGluczogW0FjdGl2YWJsZV0sXG5cdCAgICBwcm9wczoge1xuXHQgICAgICB3aWR0aDoge1xuXHQgICAgICAgIHR5cGU6IE51bWJlcixcblx0ICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA0NTA7IH1cblx0ICAgICAgfSxcblx0ICAgICAgcGVyc2lzdGVudDogQm9vbGVhblxuXHQgICAgfSxcblxuXHQgICAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBsb2FkaW5nOiBmYWxzZVxuXHQgICAgICB9O1xuXHQgICAgfSxcblxuXHQgICAgY29tcG91dGVkOiB7XG5cdCAgICAgIGlzTGF5b3V0OiBmdW5jdGlvbiBpc0xheW91dCgpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXG5cdCAgICB9LFxuXHQgICAgd2F0Y2g6IHtcblx0ICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKHZhbCkge1xuXHQgICAgICAgIGlmICghdmFsKSB7XG5cdCAgICAgICAgICAvLyB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCB0aGlzLmNsb3NlKVxuXHQgICAgICAgICAgdGhpcy5fZGVzdHJveSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICB9LFxuXG5cdCAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuXHQgICAgICAvLyB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG5cdCAgICAgIC8vIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuY2xvc2UpXG5cdCAgICAgIC8vIH0pXG5cdCAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuXHQgICAgfSxcblxuXHQgICAgbWV0aG9kczoge1xuXHQgICAgICBfZGVzdHJveTogZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG5cdCAgICAgICAgdGhpcy4kZGVzdHJveSgpO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIGRpc21pc3M6IGZ1bmN0aW9uIGRpc21pc3MoKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQgJiYgIXRoaXMubG9hZGluZykge1xuXHQgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSxcblxuXHQgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG5cdCAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXHQgICAgICB9XG5cblx0ICAgIH0sXG5cblx0ICAgIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG5cdCAgICAgIGlmICh0eXBlb2YgdGhpcy4kZWwucmVtb3ZlICE9PSAndW5kZWZpbmVkJykge1xuXHQgICAgICAgIHRoaXMuJGVsLnJlbW92ZSgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMuJGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy4kZWwpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgY2xlYXJcblx0ICAgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG5cdCAgICB0aGlzLl9fZGF0YV9fID0gW107XG5cdCAgICB0aGlzLnNpemUgPSAwO1xuXHQgIH1cblxuXHQgIHZhciBfbGlzdENhY2hlQ2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcblxuXHQgIC8qKlxuXHQgICAqIFBlcmZvcm1zIGFcblx0ICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuXHQgICAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuXHQgICAqXG5cdCAgICogQHN0YXRpY1xuXHQgICAqIEBtZW1iZXJPZiBfXG5cdCAgICogQHNpbmNlIDQuMC4wXG5cdCAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuXHQgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG5cdCAgICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcblx0ICAgKlxuXHQgICAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG5cdCAgICogLy8gPT4gZmFsc2Vcblx0ICAgKlxuXHQgICAqIF8uZXEoJ2EnLCAnYScpO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG5cdCAgICogLy8gPT4gZmFsc2Vcblx0ICAgKlxuXHQgICAqIF8uZXEoTmFOLCBOYU4pO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcblx0ICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xuXHQgIH1cblxuXHQgIHZhciBlcV8xID0gZXE7XG5cblx0ICAvKipcblx0ICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cblx0ICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG5cdCAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHQgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICAgIGlmIChlcV8xKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcblx0ICAgICAgICByZXR1cm4gbGVuZ3RoO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gLTE7XG5cdCAgfVxuXG5cdCAgdmFyIF9hc3NvY0luZGV4T2YgPSBhc3NvY0luZGV4T2Y7XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cblx0ICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgZGVsZXRlXG5cdCAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICAgIGlmIChpbmRleCA8IDApIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcblx0ICAgIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcblx0ICAgICAgZGF0YS5wb3AoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcblx0ICAgIH1cblx0ICAgIC0tdGhpcy5zaXplO1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXG5cdCAgdmFyIF9saXN0Q2FjaGVEZWxldGUgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblx0ICAvKipcblx0ICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgZ2V0XG5cdCAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgICAgaW5kZXggPSBfYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICAgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcblx0ICB9XG5cblx0ICB2YXIgX2xpc3RDYWNoZUdldCA9IGxpc3RDYWNoZUdldDtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgaGFzXG5cdCAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG5cdCAgICByZXR1cm4gX2Fzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG5cdCAgfVxuXG5cdCAgdmFyIF9saXN0Q2FjaGVIYXMgPSBsaXN0Q2FjaGVIYXM7XG5cblx0ICAvKipcblx0ICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIHNldFxuXHQgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuXHQgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuXHQgICAgICAgIGluZGV4ID0gX2Fzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG5cdCAgICBpZiAoaW5kZXggPCAwKSB7XG5cdCAgICAgICsrdGhpcy5zaXplO1xuXHQgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICB2YXIgX2xpc3RDYWNoZVNldCA9IGxpc3RDYWNoZVNldDtcblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBjb25zdHJ1Y3RvclxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG5cdCAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cblx0ICAgIHRoaXMuY2xlYXIoKTtcblx0ICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuXHQgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuXHQgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBfbGlzdENhY2hlQ2xlYXI7XG5cdCAgTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfbGlzdENhY2hlRGVsZXRlO1xuXHQgIExpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX2xpc3RDYWNoZUdldDtcblx0ICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IF9saXN0Q2FjaGVIYXM7XG5cdCAgTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBfbGlzdENhY2hlU2V0O1xuXG5cdCAgdmFyIF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGU7XG5cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgY2xlYXJcblx0ICAgKiBAbWVtYmVyT2YgU3RhY2tcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuXHQgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBfTGlzdENhY2hlO1xuXHQgICAgdGhpcy5zaXplID0gMDtcblx0ICB9XG5cblx0ICB2YXIgX3N0YWNrQ2xlYXIgPSBzdGFja0NsZWFyO1xuXG5cdCAgLyoqXG5cdCAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAbmFtZSBkZWxldGVcblx0ICAgKiBAbWVtYmVyT2YgU3RhY2tcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuXHQgICAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICB2YXIgX3N0YWNrRGVsZXRlID0gc3RhY2tEZWxldGU7XG5cblx0ICAvKipcblx0ICAgKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIGdldFxuXHQgICAqIEBtZW1iZXJPZiBTdGFja1xuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcblx0ICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xuXHQgIH1cblxuXHQgIHZhciBfc3RhY2tHZXQgPSBzdGFja0dldDtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIGhhc1xuXHQgICAqIEBtZW1iZXJPZiBTdGFja1xuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcblx0ICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xuXHQgIH1cblxuXHQgIHZhciBfc3RhY2tIYXMgPSBzdGFja0hhcztcblxuXHQgIHZhciBjb21tb25qc0dsb2JhbCQkMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGNvbW1vbmpzR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGNvbW1vbmpzR2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cdCAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUkJDEoZm4sIG1vZHVsZSkge1xuXHQgIFx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xuXHQgIH1cblxuXHQgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG5cdCAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgY29tbW9uanNHbG9iYWwkJDEgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwkJDEgJiYgY29tbW9uanNHbG9iYWwkJDEuT2JqZWN0ID09PSBPYmplY3QgJiYgY29tbW9uanNHbG9iYWwkJDE7XG5cblx0ICB2YXIgX2ZyZWVHbG9iYWwgPSBmcmVlR2xvYmFsO1xuXG5cdCAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cblx0ICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuXHQgIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuXHQgIHZhciByb290ID0gX2ZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXHQgIHZhciBfcm9vdCA9IHJvb3Q7XG5cblx0ICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgU3ltYm9sID0gX3Jvb3QuU3ltYm9sO1xuXG5cdCAgdmFyIF9TeW1ib2wgPSBTeW1ib2w7XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHQgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdCAgLyoqXG5cdCAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuXHQgICAqIG9mIHZhbHVlcy5cblx0ICAgKi9cblx0ICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuXHQgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHQgIHZhciBzeW1Ub1N0cmluZ1RhZyA9IF9TeW1ib2wgPyBfU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG5cdCAgLyoqXG5cdCAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG5cdCAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG5cdCAgICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG5cdCAgICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG5cdCAgICB0cnkge1xuXHQgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG5cdCAgICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXG5cdCAgICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdCAgICBpZiAodW5tYXNrZWQpIHtcblx0ICAgICAgaWYgKGlzT3duKSB7XG5cdCAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgdmFyIF9nZXRSYXdUYWcgPSBnZXRSYXdUYWc7XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG9iamVjdFByb3RvJDEgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdCAgLyoqXG5cdCAgICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgICAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuXHQgICAqIG9mIHZhbHVlcy5cblx0ICAgKi9cblx0ICB2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7XG5cblx0ICAvKipcblx0ICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmckMS5jYWxsKHZhbHVlKTtcblx0ICB9XG5cblx0ICB2YXIgX29iamVjdFRvU3RyaW5nID0gb2JqZWN0VG9TdHJpbmc7XG5cblx0ICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG5cdCAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG5cdCAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIHN5bVRvU3RyaW5nVGFnJDEgPSBfU3ltYm9sID8gX1N5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuXHQgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyQxICYmIHN5bVRvU3RyaW5nVGFnJDEgaW4gT2JqZWN0KHZhbHVlKSlcblx0ICAgICAgPyBfZ2V0UmF3VGFnKHZhbHVlKVxuXHQgICAgICA6IF9vYmplY3RUb1N0cmluZyh2YWx1ZSk7XG5cdCAgfVxuXG5cdCAgdmFyIF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZztcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuXHQgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcblx0ICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAc2luY2UgMC4xLjBcblx0ICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuXHQgICAqIEBleGFtcGxlXG5cdCAgICpcblx0ICAgKiBfLmlzT2JqZWN0KHt9KTtcblx0ICAgKiAvLyA9PiB0cnVlXG5cdCAgICpcblx0ICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc09iamVjdChfLm5vb3ApO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIF8uaXNPYmplY3QobnVsbCk7XG5cdCAgICogLy8gPT4gZmFsc2Vcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXHQgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuXHQgIH1cblxuXHQgIHZhciBpc09iamVjdF8xID0gaXNPYmplY3Q7XG5cblx0ICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuXHQgICAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcblx0ICAgICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcblx0ICAgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuXHQgICAqXG5cdCAgICogQHN0YXRpY1xuXHQgICAqIEBtZW1iZXJPZiBfXG5cdCAgICogQHNpbmNlIDAuMS4wXG5cdCAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG5cdCAgICogQGV4YW1wbGVcblx0ICAgKlxuXHQgICAqIF8uaXNGdW5jdGlvbihfKTtcblx0ICAgKiAvLyA9PiB0cnVlXG5cdCAgICpcblx0ICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgaWYgKCFpc09iamVjdF8xKHZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3Jcblx0ICAgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuXHQgICAgdmFyIHRhZyA9IF9iYXNlR2V0VGFnKHZhbHVlKTtcblx0ICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG5cdCAgfVxuXG5cdCAgdmFyIGlzRnVuY3Rpb25fMSA9IGlzRnVuY3Rpb247XG5cblx0ICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG5cdCAgdmFyIGNvcmVKc0RhdGEgPSBfcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cblx0ICB2YXIgX2NvcmVKc0RhdGEgPSBjb3JlSnNEYXRhO1xuXG5cdCAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cblx0ICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcblx0ICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKF9jb3JlSnNEYXRhICYmIF9jb3JlSnNEYXRhLmtleXMgJiYgX2NvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG5cdCAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG5cdCAgfSgpKTtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcblx0ICAgIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG5cdCAgfVxuXG5cdCAgdmFyIF9pc01hc2tlZCA9IGlzTWFza2VkO1xuXG5cdCAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHQgIHZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cblx0ICAvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG5cdCAgdmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuXHQgIC8qKlxuXHQgICAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG5cdCAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuXHQgICAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuXHQgICAgICB0cnkge1xuXHQgICAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge31cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gJyc7XG5cdCAgfVxuXG5cdCAgdmFyIF90b1NvdXJjZSA9IHRvU291cmNlO1xuXG5cdCAgLyoqXG5cdCAgICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuXHQgICAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuXHQgICAqL1xuXHQgIHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cblx0ICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG5cdCAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIGZ1bmNQcm90byQxID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQgICAgICBvYmplY3RQcm90byQyID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblx0ICB2YXIgZnVuY1RvU3RyaW5nJDEgPSBmdW5jUHJvdG8kMS50b1N0cmluZztcblxuXHQgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHQgIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTtcblxuXHQgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG5cdCAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcblx0ICAgIGZ1bmNUb1N0cmluZyQxLmNhbGwoaGFzT3duUHJvcGVydHkkMSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuXHQgICAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG5cdCAgKTtcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG5cdCAgICogIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcblx0ICAgIGlmICghaXNPYmplY3RfMSh2YWx1ZSkgfHwgX2lzTWFza2VkKHZhbHVlKSkge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fMSh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuXHQgICAgcmV0dXJuIHBhdHRlcm4udGVzdChfdG9Tb3VyY2UodmFsdWUpKTtcblx0ICB9XG5cblx0ICB2YXIgX2Jhc2VJc05hdGl2ZSA9IGJhc2VJc05hdGl2ZTtcblxuXHQgIC8qKlxuXHQgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcblx0ICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuXHQgIH1cblxuXHQgIHZhciBfZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcblxuXHQgIC8qKlxuXHQgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cblx0ICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG5cdCAgICB2YXIgdmFsdWUgPSBfZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuXHQgICAgcmV0dXJuIF9iYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgdmFyIF9nZXROYXRpdmUgPSBnZXROYXRpdmU7XG5cblx0ICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG5cdCAgdmFyIE1hcCA9IF9nZXROYXRpdmUoX3Jvb3QsICdNYXAnKTtcblxuXHQgIHZhciBfTWFwID0gTWFwO1xuXG5cdCAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuXHQgIHZhciBuYXRpdmVDcmVhdGUgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5cdCAgdmFyIF9uYXRpdmVDcmVhdGUgPSBuYXRpdmVDcmVhdGU7XG5cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAbmFtZSBjbGVhclxuXHQgICAqIEBtZW1iZXJPZiBIYXNoXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuXHQgICAgdGhpcy5fX2RhdGFfXyA9IF9uYXRpdmVDcmVhdGUgPyBfbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG5cdCAgICB0aGlzLnNpemUgPSAwO1xuXHQgIH1cblxuXHQgIHZhciBfaGFzaENsZWFyID0gaGFzaENsZWFyO1xuXG5cdCAgLyoqXG5cdCAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIGRlbGV0ZVxuXHQgICAqIEBtZW1iZXJPZiBIYXNoXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcblx0ICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgdmFyIF9oYXNoRGVsZXRlID0gaGFzaERlbGV0ZTtcblxuXHQgIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cblx0ICB2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG9iamVjdFByb3RvJDMgPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdCAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdCAgdmFyIGhhc093blByb3BlcnR5JDIgPSBvYmplY3RQcm90byQzLmhhc093blByb3BlcnR5O1xuXG5cdCAgLyoqXG5cdCAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIGdldFxuXHQgICAqIEBtZW1iZXJPZiBIYXNoXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgICBpZiAoX25hdGl2ZUNyZWF0ZSkge1xuXHQgICAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuXHQgICAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSQyLmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICB2YXIgX2hhc2hHZXQgPSBoYXNoR2V0O1xuXG5cdCAgLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHQgIHZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHQgIHZhciBoYXNPd25Qcm9wZXJ0eSQzID0gb2JqZWN0UHJvdG8kNC5oYXNPd25Qcm9wZXJ0eTtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgaGFzXG5cdCAgICogQG1lbWJlck9mIEhhc2hcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICAgIHJldHVybiBfbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5JDMuY2FsbChkYXRhLCBrZXkpO1xuXHQgIH1cblxuXHQgIHZhciBfaGFzaEhhcyA9IGhhc2hIYXM7XG5cblx0ICAvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG5cdCAgdmFyIEhBU0hfVU5ERUZJTkVEJDEgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cblx0ICAvKipcblx0ICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIHNldFxuXHQgICAqIEBtZW1iZXJPZiBIYXNoXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG5cdCAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuXHQgICAgZGF0YVtrZXldID0gKF9uYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCQxIDogdmFsdWU7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICB2YXIgX2hhc2hTZXQgPSBoYXNoU2V0O1xuXG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAY29uc3RydWN0b3Jcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcblx0ICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgICAgdGhpcy5jbGVhcigpO1xuXHQgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuXHQgIEhhc2gucHJvdG90eXBlLmNsZWFyID0gX2hhc2hDbGVhcjtcblx0ICBIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBfaGFzaERlbGV0ZTtcblx0ICBIYXNoLnByb3RvdHlwZS5nZXQgPSBfaGFzaEdldDtcblx0ICBIYXNoLnByb3RvdHlwZS5oYXMgPSBfaGFzaEhhcztcblx0ICBIYXNoLnByb3RvdHlwZS5zZXQgPSBfaGFzaFNldDtcblxuXHQgIHZhciBfSGFzaCA9IEhhc2g7XG5cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIGNsZWFyXG5cdCAgICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcblx0ICAgIHRoaXMuc2l6ZSA9IDA7XG5cdCAgICB0aGlzLl9fZGF0YV9fID0ge1xuXHQgICAgICAnaGFzaCc6IG5ldyBfSGFzaCxcblx0ICAgICAgJ21hcCc6IG5ldyAoX01hcCB8fCBfTGlzdENhY2hlKSxcblx0ICAgICAgJ3N0cmluZyc6IG5ldyBfSGFzaFxuXHQgICAgfTtcblx0ICB9XG5cblx0ICB2YXIgX21hcENhY2hlQ2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcblx0ICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgICAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcblx0ICAgICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuXHQgICAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG5cdCAgfVxuXG5cdCAgdmFyIF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cblx0ICAvKipcblx0ICAgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG5cdCAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcblx0ICAgIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuXHQgICAgcmV0dXJuIF9pc0tleWFibGUoa2V5KVxuXHQgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuXHQgICAgICA6IGRhdGEubWFwO1xuXHQgIH1cblxuXHQgIHZhciBfZ2V0TWFwRGF0YSA9IGdldE1hcERhdGE7XG5cblx0ICAvKipcblx0ICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAbmFtZSBkZWxldGVcblx0ICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gX2dldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcblx0ICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgdmFyIF9tYXBDYWNoZURlbGV0ZSA9IG1hcENhY2hlRGVsZXRlO1xuXG5cdCAgLyoqXG5cdCAgICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgZ2V0XG5cdCAgICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG5cdCAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuXHQgICAgcmV0dXJuIF9nZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG5cdCAgfVxuXG5cdCAgdmFyIF9tYXBDYWNoZUdldCA9IG1hcENhY2hlR2V0O1xuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBuYW1lIGhhc1xuXHQgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcblx0ICAgIHJldHVybiBfZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuXHQgIH1cblxuXHQgIHZhciBfbWFwQ2FjaGVIYXMgPSBtYXBDYWNoZUhhcztcblxuXHQgIC8qKlxuXHQgICAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAbmFtZSBzZXRcblx0ICAgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcblx0ICAgIHZhciBkYXRhID0gX2dldE1hcERhdGEodGhpcywga2V5KSxcblx0ICAgICAgICBzaXplID0gZGF0YS5zaXplO1xuXG5cdCAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcblx0ICAgIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIF9tYXBDYWNoZVNldCA9IG1hcENhY2hlU2V0O1xuXG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAY29uc3RydWN0b3Jcblx0ICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG5cdCAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cblx0ICAgIHRoaXMuY2xlYXIoKTtcblx0ICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuXHQgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5cdCAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gX21hcENhY2hlQ2xlYXI7XG5cdCAgTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IF9tYXBDYWNoZURlbGV0ZTtcblx0ICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX21hcENhY2hlR2V0O1xuXHQgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbWFwQ2FjaGVIYXM7XG5cdCAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldDtcblxuXHQgIHZhciBfTWFwQ2FjaGUgPSBNYXBDYWNoZTtcblxuXHQgIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuXHQgIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG5cdCAgLyoqXG5cdCAgICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQG5hbWUgc2V0XG5cdCAgICogQG1lbWJlck9mIFN0YWNrXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcblx0ICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcblx0ICAgIGlmIChkYXRhIGluc3RhbmNlb2YgX0xpc3RDYWNoZSkge1xuXHQgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuXHQgICAgICBpZiAoIV9NYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuXHQgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcblx0ICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgfVxuXHQgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBfTWFwQ2FjaGUocGFpcnMpO1xuXHQgICAgfVxuXHQgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG5cdCAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICB2YXIgX3N0YWNrU2V0ID0gc3RhY2tTZXQ7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQGNvbnN0cnVjdG9yXG5cdCAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuXHQgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IF9MaXN0Q2FjaGUoZW50cmllcyk7XG5cdCAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG5cdCAgfVxuXG5cdCAgLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblx0ICBTdGFjay5wcm90b3R5cGUuY2xlYXIgPSBfc3RhY2tDbGVhcjtcblx0ICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gX3N0YWNrRGVsZXRlO1xuXHQgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBfc3RhY2tHZXQ7XG5cdCAgU3RhY2sucHJvdG90eXBlLmhhcyA9IF9zdGFja0hhcztcblx0ICBTdGFjay5wcm90b3R5cGUuc2V0ID0gX3N0YWNrU2V0O1xuXG5cdCAgdmFyIF9TdGFjayA9IFN0YWNrO1xuXG5cdCAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgdmFyIGZ1bmMgPSBfZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG5cdCAgICAgIGZ1bmMoe30sICcnLCB7fSk7XG5cdCAgICAgIHJldHVybiBmdW5jO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9KCkpO1xuXG5cdCAgdmFyIF9kZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5O1xuXG5cdCAgLyoqXG5cdCAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcblx0ICAgKiB2YWx1ZSBjaGVja3MuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICAgIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgX2RlZmluZVByb3BlcnR5KSB7XG5cdCAgICAgIF9kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXHQgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuXHQgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcblx0ICAgICAgICAndmFsdWUnOiB2YWx1ZSxcblx0ICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICB2YXIgX2Jhc2VBc3NpZ25WYWx1ZSA9IGJhc2VBc3NpZ25WYWx1ZTtcblxuXHQgIC8qKlxuXHQgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG5cdCAgICogYHVuZGVmaW5lZGAgdmFsdWVzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuXHQgICAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcV8xKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG5cdCAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcblx0ICAgICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBfYXNzaWduTWVyZ2VWYWx1ZSA9IGFzc2lnbk1lcmdlVmFsdWU7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG5cdCAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG5cdCAgICAgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcblx0ICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuXHQgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcblx0ICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG5cdCAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBvYmplY3Q7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIHZhciBfY3JlYXRlQmFzZUZvciA9IGNyZWF0ZUJhc2VGb3I7XG5cblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuXHQgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuXHQgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG5cdCAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgKi9cblx0ICB2YXIgYmFzZUZvciA9IF9jcmVhdGVCYXNlRm9yKCk7XG5cblx0ICB2YXIgX2Jhc2VGb3IgPSBiYXNlRm9yO1xuXG5cdCAgdmFyIF9jbG9uZUJ1ZmZlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlJCQxKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHQgIHZhciBmcmVlRXhwb3J0cyA9ICdvYmplY3QnID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblx0ICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuXHQgIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdCAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cblx0ICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IF9yb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcblx0ICAgICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG5cdCAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cblx0ICAgKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG5cdCAgICBpZiAoaXNEZWVwKSB7XG5cdCAgICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcblx0ICAgIH1cblx0ICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuXHQgICAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuXHQgICAgYnVmZmVyLmNvcHkocmVzdWx0KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcblx0ICB9KTtcblxuXHQgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHQgIHZhciBVaW50OEFycmF5ID0gX3Jvb3QuVWludDhBcnJheTtcblxuXHQgIHZhciBfVWludDhBcnJheSA9IFVpbnQ4QXJyYXk7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cblx0ICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcblx0ICAgIG5ldyBfVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgX1VpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgdmFyIF9jbG9uZUFycmF5QnVmZmVyID0gY2xvbmVBcnJheUJ1ZmZlcjtcblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cblx0ICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuXHQgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG5cdCAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gX2Nsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG5cdCAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcblx0ICB9XG5cblx0ICB2YXIgX2Nsb25lVHlwZWRBcnJheSA9IGNsb25lVHlwZWRBcnJheTtcblxuXHQgIC8qKlxuXHQgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cblx0ICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cblx0ICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuXHQgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuXHQgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG5cdCAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycmF5O1xuXHQgIH1cblxuXHQgIHZhciBfY29weUFycmF5ID0gY29weUFycmF5O1xuXG5cdCAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG5cdCAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cblx0ICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuXHQgICAqL1xuXHQgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cblx0ICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuXHQgICAgICBpZiAoIWlzT2JqZWN0XzEocHJvdG8pKSB7XG5cdCAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChvYmplY3RDcmVhdGUpIHtcblx0ICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcblx0ICAgICAgfVxuXHQgICAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG5cdCAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuXHQgICAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuXHQgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICB9KCkpO1xuXG5cdCAgdmFyIF9iYXNlQ3JlYXRlID0gYmFzZUNyZWF0ZTtcblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuXHQgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG5cdCAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgdmFyIF9vdmVyQXJnID0gb3ZlckFyZztcblxuXHQgIC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHQgIHZhciBnZXRQcm90b3R5cGUgPSBfb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cblx0ICB2YXIgX2dldFByb3RvdHlwZSA9IGdldFByb3RvdHlwZTtcblxuXHQgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0ICAvKipcblx0ICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG5cdCAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuXHQgICAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvJDU7XG5cblx0ICAgIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG5cdCAgfVxuXG5cdCAgdmFyIF9pc1Byb3RvdHlwZSA9IGlzUHJvdG90eXBlO1xuXG5cdCAgLyoqXG5cdCAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG5cdCAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuXHQgICAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIV9pc1Byb3RvdHlwZShvYmplY3QpKVxuXHQgICAgICA/IF9iYXNlQ3JlYXRlKF9nZXRQcm90b3R5cGUob2JqZWN0KSlcblx0ICAgICAgOiB7fTtcblx0ICB9XG5cblx0ICB2YXIgX2luaXRDbG9uZU9iamVjdCA9IGluaXRDbG9uZU9iamVjdDtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuXHQgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSA0LjAuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogXy5pc09iamVjdExpa2Uoe30pO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqXG5cdCAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG5cdCAgICogLy8gPT4gZmFsc2Vcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcblx0ICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcblx0ICB9XG5cblx0ICB2YXIgaXNPYmplY3RMaWtlXzEgPSBpc09iamVjdExpa2U7XG5cblx0ICAvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBfYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcblx0ICB9XG5cblx0ICB2YXIgX2Jhc2VJc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cztcblxuXHQgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgb2JqZWN0UHJvdG8kNiA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0ICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0ICB2YXIgaGFzT3duUHJvcGVydHkkNCA9IG9iamVjdFByb3RvJDYuaGFzT3duUHJvcGVydHk7XG5cblx0ICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90byQ2LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSAwLjEuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuXHQgICAqICBlbHNlIGBmYWxzZWAuXG5cdCAgICogQGV4YW1wbGVcblx0ICAgKlxuXHQgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICovXG5cdCAgdmFyIGlzQXJndW1lbnRzID0gX2Jhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IF9iYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eSQ0LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuXHQgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuXHQgIH07XG5cblx0ICB2YXIgaXNBcmd1bWVudHNfMSA9IGlzQXJndW1lbnRzO1xuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSAwLjEuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICpcblx0ICAgKiBfLmlzQXJyYXkoJ2FiYycpO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICpcblx0ICAgKiBfLmlzQXJyYXkoXy5ub29wKTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqL1xuXHQgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuXHQgIHZhciBpc0FycmF5XzEgPSBpc0FycmF5O1xuXG5cdCAgLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cdCAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG5cdCAgLyoqXG5cdCAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cblx0ICAgKlxuXHQgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG5cdCAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSA0LjAuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogXy5pc0xlbmd0aCgzKTtcblx0ICAgKiAvLyA9PiB0cnVlXG5cdCAgICpcblx0ICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICpcblx0ICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqXG5cdCAgICogXy5pc0xlbmd0aCgnMycpO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcblx0ICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcblx0ICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuXHQgIH1cblxuXHQgIHZhciBpc0xlbmd0aF8xID0gaXNMZW5ndGg7XG5cblx0ICAvKipcblx0ICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG5cdCAgICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuXHQgICAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAc2luY2UgNC4wLjBcblx0ICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcblx0ICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoXzEodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbl8xKHZhbHVlKTtcblx0ICB9XG5cblx0ICB2YXIgaXNBcnJheUxpa2VfMSA9IGlzQXJyYXlMaWtlO1xuXG5cdCAgLyoqXG5cdCAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuXHQgICAqIGlzIGFuIG9iamVjdC5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSA0LjAuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG5cdCAgICogIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKlxuXHQgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG5cdCAgICogLy8gPT4gZmFsc2Vcblx0ICAgKlxuXHQgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG5cdCAgICByZXR1cm4gaXNPYmplY3RMaWtlXzEodmFsdWUpICYmIGlzQXJyYXlMaWtlXzEodmFsdWUpO1xuXHQgIH1cblxuXHQgIHZhciBpc0FycmF5TGlrZU9iamVjdF8xID0gaXNBcnJheUxpa2VPYmplY3Q7XG5cblx0ICAvKipcblx0ICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAc2luY2UgNC4xMy4wXG5cdCAgICogQGNhdGVnb3J5IFV0aWxcblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuXHQgICAqIEBleGFtcGxlXG5cdCAgICpcblx0ICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcblx0ICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICB2YXIgc3R1YkZhbHNlXzEgPSBzdHViRmFsc2U7XG5cblx0ICB2YXIgaXNCdWZmZXJfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlJCQxKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHQgIHZhciBmcmVlRXhwb3J0cyA9ICdvYmplY3QnID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblx0ICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuXHQgIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdCAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cblx0ICAvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IF9yb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuXHQgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0ICB2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cblx0ICAvKipcblx0ICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSA0LjMuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcblx0ICAgKiAvLyA9PiB0cnVlXG5cdCAgICpcblx0ICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqL1xuXHQgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZV8xO1xuXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcblx0ICB9KTtcblxuXHQgIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIGZ1bmNQcm90byQyID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuXHQgICAgICBvYmplY3RQcm90byQ3ID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cblx0ICB2YXIgZnVuY1RvU3RyaW5nJDIgPSBmdW5jUHJvdG8kMi50b1N0cmluZztcblxuXHQgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHQgIHZhciBoYXNPd25Qcm9wZXJ0eSQ1ID0gb2JqZWN0UHJvdG8kNy5oYXNPd25Qcm9wZXJ0eTtcblxuXHQgIC8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cblx0ICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZyQyLmNhbGwoT2JqZWN0KTtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcblx0ICAgKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAc2luY2UgMC44LjBcblx0ICAgKiBAY2F0ZWdvcnkgTGFuZ1xuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG5cdCAgICogQGV4YW1wbGVcblx0ICAgKlxuXHQgICAqIGZ1bmN0aW9uIEZvbygpIHtcblx0ICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICogfVxuXHQgICAqXG5cdCAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICpcblx0ICAgKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcblx0ICAgKiAvLyA9PiBmYWxzZVxuXHQgICAqXG5cdCAgICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHQgICAqIC8vID0+IHRydWVcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG5cdCAgICBpZiAoIWlzT2JqZWN0TGlrZV8xKHZhbHVlKSB8fCBfYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHZhciBwcm90byA9IF9nZXRQcm90b3R5cGUodmFsdWUpO1xuXHQgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eSQ1LmNhbGwocHJvdG8sICdjb25zdHJ1Y3RvcicpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuXHQgICAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcblx0ICAgICAgZnVuY1RvU3RyaW5nJDIuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuXHQgIH1cblxuXHQgIHZhciBpc1BsYWluT2JqZWN0XzEgPSBpc1BsYWluT2JqZWN0O1xuXG5cdCAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuXHQgIHZhciBhcmdzVGFnJDEgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcblx0ICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuXHQgICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuXHQgICAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuXHQgICAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG5cdCAgICAgIGZ1bmNUYWckMSA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG5cdCAgICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuXHQgICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcblx0ICAgICAgb2JqZWN0VGFnJDEgPSAnW29iamVjdCBPYmplY3RdJyxcblx0ICAgICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG5cdCAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuXHQgICAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcblx0ICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxuXHQgIHZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG5cdCAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcblx0ICAgICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuXHQgICAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG5cdCAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcblx0ICAgICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG5cdCAgICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuXHQgICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcblx0ICAgICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcblx0ICAgICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcblx0ICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuXHQgIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cblx0ICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcblx0ICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5cdCAgdHlwZWRBcnJheVRhZ3NbYXJnc1RhZyQxXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuXHQgIHR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cblx0ICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnJDFdID1cblx0ICB0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG5cdCAgdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxuXHQgIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuIGlzT2JqZWN0TGlrZV8xKHZhbHVlKSAmJlxuXHQgICAgICBpc0xlbmd0aF8xKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tfYmFzZUdldFRhZyh2YWx1ZSldO1xuXHQgIH1cblxuXHQgIHZhciBfYmFzZUlzVHlwZWRBcnJheSA9IGJhc2VJc1R5cGVkQXJyYXk7XG5cblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cblx0ICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgIH1cblxuXHQgIHZhciBfYmFzZVVuYXJ5ID0gYmFzZVVuYXJ5O1xuXG5cdCAgdmFyIF9ub2RlVXRpbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlJCQxKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuXHQgIHZhciBmcmVlRXhwb3J0cyA9ICdvYmplY3QnID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuXHQgIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cblx0ICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmICdvYmplY3QnID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuXHQgIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG5cdCAgdmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cblx0ICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cblx0ICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIF9mcmVlR2xvYmFsLnByb2Nlc3M7XG5cblx0ICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cblx0ICB2YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cblx0ICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cblx0ICAgICAgaWYgKHR5cGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVzO1xuXHQgICAgICB9XG5cblx0ICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cblx0ICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuXHQgICAgfSBjYXRjaCAoZSkge31cblx0ICB9KCkpO1xuXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblx0ICB9KTtcblxuXHQgIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBfbm9kZVV0aWwgJiYgX25vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuXHQgIC8qKlxuXHQgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSAzLjAuMFxuXHQgICAqIEBjYXRlZ29yeSBMYW5nXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuXHQgICAqIEBleGFtcGxlXG5cdCAgICpcblx0ICAgKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqXG5cdCAgICogXy5pc1R5cGVkQXJyYXkoW10pO1xuXHQgICAqIC8vID0+IGZhbHNlXG5cdCAgICovXG5cdCAgdmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBfYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogX2Jhc2VJc1R5cGVkQXJyYXk7XG5cblx0ICB2YXIgaXNUeXBlZEFycmF5XzEgPSBpc1R5cGVkQXJyYXk7XG5cblx0ICAvKipcblx0ICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuXHQgICAgcmV0dXJuIGtleSA9PSAnX19wcm90b19fJ1xuXHQgICAgICA/IHVuZGVmaW5lZFxuXHQgICAgICA6IG9iamVjdFtrZXldO1xuXHQgIH1cblxuXHQgIHZhciBfc2FmZUdldCA9IHNhZmVHZXQ7XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG9iamVjdFByb3RvJDggPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdCAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdCAgdmFyIGhhc093blByb3BlcnR5JDYgPSBvYmplY3RQcm90byQ4Lmhhc093blByb3BlcnR5O1xuXG5cdCAgLyoqXG5cdCAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuXHQgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuXHQgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcblx0ICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuXHQgICAgaWYgKCEoaGFzT3duUHJvcGVydHkkNi5jYWxsKG9iamVjdCwga2V5KSAmJiBlcV8xKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG5cdCAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcblx0ICAgICAgX2Jhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIHZhciBfYXNzaWduVmFsdWUgPSBhc3NpZ25WYWx1ZTtcblxuXHQgIC8qKlxuXHQgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG5cdCAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG5cdCAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuXHQgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcblx0ICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG5cdCAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0ICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cblx0ICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuXHQgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG5cdCAgICAgICAgOiB1bmRlZmluZWQ7XG5cblx0ICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChpc05ldykge1xuXHQgICAgICAgIF9iYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBfYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG9iamVjdDtcblx0ICB9XG5cblx0ICB2YXIgX2NvcHlPYmplY3QgPSBjb3B5T2JqZWN0O1xuXG5cdCAgLyoqXG5cdCAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuXHQgICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG5cdCAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuXHQgICAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cblx0ICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuXHQgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICB2YXIgX2Jhc2VUaW1lcyA9IGJhc2VUaW1lcztcblxuXHQgIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXHQgIHZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG5cdCAgLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xuXHQgIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cblx0ICAvKipcblx0ICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiQxIDogbGVuZ3RoO1xuXG5cdCAgICByZXR1cm4gISFsZW5ndGggJiZcblx0ICAgICAgKHR5cGUgPT0gJ251bWJlcicgfHxcblx0ICAgICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG5cdCAgICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG5cdCAgfVxuXG5cdCAgdmFyIF9pc0luZGV4ID0gaXNJbmRleDtcblxuXHQgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cblx0ICB2YXIgb2JqZWN0UHJvdG8kOSA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0ICAvKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cblx0ICB2YXIgaGFzT3duUHJvcGVydHkkNyA9IG9iamVjdFByb3RvJDkuaGFzT3duUHJvcGVydHk7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuXHQgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cblx0ICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuXHQgICAgdmFyIGlzQXJyID0gaXNBcnJheV8xKHZhbHVlKSxcblx0ICAgICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50c18xKHZhbHVlKSxcblx0ICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyXzEodmFsdWUpLFxuXHQgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXlfMSh2YWx1ZSksXG5cdCAgICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuXHQgICAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gX2Jhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcblx0ICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0ICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkNy5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuXHQgICAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG5cdCAgICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG5cdCAgICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcblx0ICAgICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuXHQgICAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG5cdCAgICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG5cdCAgICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcblx0ICAgICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cblx0ICAgICAgICAgICAgIF9pc0luZGV4KGtleSwgbGVuZ3RoKVxuXHQgICAgICAgICAgKSkpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIHZhciBfYXJyYXlMaWtlS2V5cyA9IGFycmF5TGlrZUtleXM7XG5cblx0ICAvKipcblx0ICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2Vcblx0ICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG5cdCAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG5cdCAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgdmFyIF9uYXRpdmVLZXlzSW4gPSBuYXRpdmVLZXlzSW47XG5cblx0ICAvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdCAgdmFyIG9iamVjdFByb3RvJDEwID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQgIC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHQgIHZhciBoYXNPd25Qcm9wZXJ0eSQ4ID0gb2JqZWN0UHJvdG8kMTAuaGFzT3duUHJvcGVydHk7XG5cblx0ICAvKipcblx0ICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcblx0ICAgIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG5cdCAgICAgIHJldHVybiBfbmF0aXZlS2V5c0luKG9iamVjdCk7XG5cdCAgICB9XG5cdCAgICB2YXIgaXNQcm90byA9IF9pc1Byb3RvdHlwZShvYmplY3QpLFxuXHQgICAgICAgIHJlc3VsdCA9IFtdO1xuXG5cdCAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG5cdCAgICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eSQ4LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH1cblxuXHQgIHZhciBfYmFzZUtleXNJbiA9IGJhc2VLZXlzSW47XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuXHQgICAqXG5cdCAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAc2luY2UgMy4wLjBcblx0ICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG5cdCAgICogQGV4YW1wbGVcblx0ICAgKlxuXHQgICAqIGZ1bmN0aW9uIEZvbygpIHtcblx0ICAgKiAgIHRoaXMuYSA9IDE7XG5cdCAgICogICB0aGlzLmIgPSAyO1xuXHQgICAqIH1cblx0ICAgKlxuXHQgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG5cdCAgICpcblx0ICAgKiBfLmtleXNJbihuZXcgRm9vKTtcblx0ICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcblx0ICAgKi9cblx0ICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gaXNBcnJheUxpa2VfMShvYmplY3QpID8gX2FycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IF9iYXNlS2V5c0luKG9iamVjdCk7XG5cdCAgfVxuXG5cdCAgdmFyIGtleXNJbl8xID0ga2V5c0luO1xuXG5cdCAgLyoqXG5cdCAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuXHQgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuXHQgICAqXG5cdCAgICogQHN0YXRpY1xuXHQgICAqIEBtZW1iZXJPZiBfXG5cdCAgICogQHNpbmNlIDMuMC4wXG5cdCAgICogQGNhdGVnb3J5IExhbmdcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG5cdCAgICogQGV4YW1wbGVcblx0ICAgKlxuXHQgICAqIGZ1bmN0aW9uIEZvbygpIHtcblx0ICAgKiAgIHRoaXMuYiA9IDI7XG5cdCAgICogfVxuXHQgICAqXG5cdCAgICogRm9vLnByb3RvdHlwZS5jID0gMztcblx0ICAgKlxuXHQgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuXHQgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuXHQgICAqXG5cdCAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcblx0ICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcblx0ICAgIHJldHVybiBfY29weU9iamVjdCh2YWx1ZSwga2V5c0luXzEodmFsdWUpKTtcblx0ICB9XG5cblx0ICB2YXIgdG9QbGFpbk9iamVjdF8xID0gdG9QbGFpbk9iamVjdDtcblxuXHQgIC8qKlxuXHQgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZU1lcmdlYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG5cdCAgICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcblx0ICAgKiByZWZlcmVuY2VzIHRvIGJlIG1lcmdlZC5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IG1lcmdlRnVuYyBUaGUgZnVuY3Rpb24gdG8gbWVyZ2UgdmFsdWVzLlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuXHQgICAqICBjb3VudGVycGFydHMuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgbWVyZ2VGdW5jLCBjdXN0b21pemVyLCBzdGFjaykge1xuXHQgICAgdmFyIG9ialZhbHVlID0gX3NhZmVHZXQob2JqZWN0LCBrZXkpLFxuXHQgICAgICAgIHNyY1ZhbHVlID0gX3NhZmVHZXQoc291cmNlLCBrZXkpLFxuXHQgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG5cdCAgICBpZiAoc3RhY2tlZCkge1xuXHQgICAgICBfYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcblx0ICAgICAgPyBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwgKGtleSArICcnKSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKVxuXHQgICAgICA6IHVuZGVmaW5lZDtcblxuXHQgICAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuXHQgICAgaWYgKGlzQ29tbW9uKSB7XG5cdCAgICAgIHZhciBpc0FyciA9IGlzQXJyYXlfMShzcmNWYWx1ZSksXG5cdCAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXJfMShzcmNWYWx1ZSksXG5cdCAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5XzEoc3JjVmFsdWUpO1xuXG5cdCAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG5cdCAgICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuXHQgICAgICAgIGlmIChpc0FycmF5XzEob2JqVmFsdWUpKSB7XG5cdCAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdF8xKG9ialZhbHVlKSkge1xuXHQgICAgICAgICAgbmV3VmFsdWUgPSBfY29weUFycmF5KG9ialZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG5cdCAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuXHQgICAgICAgICAgbmV3VmFsdWUgPSBfY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChpc1R5cGVkKSB7XG5cdCAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuXHQgICAgICAgICAgbmV3VmFsdWUgPSBfY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0XzEoc3JjVmFsdWUpIHx8IGlzQXJndW1lbnRzXzEoc3JjVmFsdWUpKSB7XG5cdCAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcblx0ICAgICAgICBpZiAoaXNBcmd1bWVudHNfMShvYmpWYWx1ZSkpIHtcblx0ICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdF8xKG9ialZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0XzEob2JqVmFsdWUpIHx8IChzcmNJbmRleCAmJiBpc0Z1bmN0aW9uXzEob2JqVmFsdWUpKSkge1xuXHQgICAgICAgICAgbmV3VmFsdWUgPSBfaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZSB7XG5cdCAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzQ29tbW9uKSB7XG5cdCAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXHQgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcblx0ICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcblx0ICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcblx0ICAgIH1cblx0ICAgIF9hc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG5cdCAgfVxuXG5cdCAgdmFyIF9iYXNlTWVyZ2VEZWVwID0gYmFzZU1lcmdlRGVlcDtcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuXHQgICAqICBjb3VudGVycGFydHMuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcblx0ICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBfYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcblx0ICAgICAgaWYgKGlzT2JqZWN0XzEoc3JjVmFsdWUpKSB7XG5cdCAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IF9TdGFjayk7XG5cdCAgICAgICAgX2Jhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuXHQgICAgICB9XG5cdCAgICAgIGVsc2Uge1xuXHQgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcblx0ICAgICAgICAgID8gY3VzdG9taXplcihfc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG5cdCAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuXHQgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuXHQgICAgICB9XG5cdCAgICB9LCBrZXlzSW5fMSk7XG5cdCAgfVxuXG5cdCAgdmFyIF9iYXNlTWVyZ2UgPSBiYXNlTWVyZ2U7XG5cblx0ICAvKipcblx0ICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAc2luY2UgMC4xLjBcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBjYXRlZ29yeSBVdGlsXG5cdCAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG5cdCAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG5cdCAgICpcblx0ICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdCAgfVxuXG5cdCAgdmFyIGlkZW50aXR5XzEgPSBpZGVudGl0eTtcblxuXHQgIC8qKlxuXHQgICAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2Bcblx0ICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG5cdCAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG5cdCAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cblx0ICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG5cdCAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG5cdCAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcblx0ICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuXHQgICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG5cdCAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHQgIH1cblxuXHQgIHZhciBfYXBwbHkgPSBhcHBseTtcblxuXHQgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0ICB2YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cblx0ICAvKipcblx0ICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuXHQgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuXHQgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcblx0ICAgIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG5cdCAgICAgICAgICBpbmRleCA9IC0xLFxuXHQgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuXHQgICAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG5cdCAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcblx0ICAgICAgfVxuXHQgICAgICBpbmRleCA9IC0xO1xuXHQgICAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcblx0ICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuXHQgICAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcblx0ICAgICAgfVxuXHQgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcblx0ICAgICAgcmV0dXJuIF9hcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICB2YXIgX292ZXJSZXN0ID0gb3ZlclJlc3Q7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG5cdCAgICpcblx0ICAgKiBAc3RhdGljXG5cdCAgICogQG1lbWJlck9mIF9cblx0ICAgKiBAc2luY2UgMi40LjBcblx0ICAgKiBAY2F0ZWdvcnkgVXRpbFxuXHQgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG5cdCAgICogQGV4YW1wbGVcblx0ICAgKlxuXHQgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcblx0ICAgKlxuXHQgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuXHQgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuXHQgICAqXG5cdCAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG5cdCAgICogLy8gPT4gdHJ1ZVxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgfVxuXG5cdCAgdmFyIGNvbnN0YW50XzEgPSBjb25zdGFudDtcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG5cdCAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cblx0ICAgKi9cblx0ICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIV9kZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5XzEgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcblx0ICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoZnVuYywgJ3RvU3RyaW5nJywge1xuXHQgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcblx0ICAgICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcblx0ICAgICAgJ3ZhbHVlJzogY29uc3RhbnRfMShzdHJpbmcpLFxuXHQgICAgICAnd3JpdGFibGUnOiB0cnVlXG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgdmFyIF9iYXNlU2V0VG9TdHJpbmcgPSBiYXNlU2V0VG9TdHJpbmc7XG5cblx0ICAvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG5cdCAgdmFyIEhPVF9DT1VOVCA9IDgwMCxcblx0ICAgICAgSE9UX1NQQU4gPSAxNjtcblxuXHQgIC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cblx0ICB2YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cblx0ICAvKipcblx0ICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcblx0ICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcblx0ICAgKiBtaWxsaXNlY29uZHMuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuXHQgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cblx0ICAgKi9cblx0ICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG5cdCAgICB2YXIgY291bnQgPSAwLFxuXHQgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuXHQgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuXHQgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG5cdCAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG5cdCAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG5cdCAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjb3VudCA9IDA7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICB2YXIgX3Nob3J0T3V0ID0gc2hvcnRPdXQ7XG5cblx0ICAvKipcblx0ICAgKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cblx0ICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuXHQgICAqL1xuXHQgIHZhciBzZXRUb1N0cmluZyA9IF9zaG9ydE91dChfYmFzZVNldFRvU3RyaW5nKTtcblxuXHQgIHZhciBfc2V0VG9TdHJpbmcgPSBzZXRUb1N0cmluZztcblxuXHQgIC8qKlxuXHQgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cblx0ICAgKlxuXHQgICAqIEBwcml2YXRlXG5cdCAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cblx0ICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG5cdCAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcblx0ICAgIHJldHVybiBfc2V0VG9TdHJpbmcoX292ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eV8xKSwgZnVuYyArICcnKTtcblx0ICB9XG5cblx0ICB2YXIgX2Jhc2VSZXN0ID0gYmFzZVJlc3Q7XG5cblx0ICAvKipcblx0ICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuXHQgICAqXG5cdCAgICogQHByaXZhdGVcblx0ICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG5cdCAgICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cblx0ICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cblx0ICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuXHQgICAqICBlbHNlIGBmYWxzZWAuXG5cdCAgICovXG5cdCAgZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcblx0ICAgIGlmICghaXNPYmplY3RfMShvYmplY3QpKSB7XG5cdCAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuXHQgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcblx0ICAgICAgICAgID8gKGlzQXJyYXlMaWtlXzEob2JqZWN0KSAmJiBfaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG5cdCAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcblx0ICAgICAgICApIHtcblx0ICAgICAgcmV0dXJuIGVxXzEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHZhciBfaXNJdGVyYXRlZUNhbGwgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXHQgIC8qKlxuXHQgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmFzc2lnbmAuXG5cdCAgICpcblx0ICAgKiBAcHJpdmF0ZVxuXHQgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbmVyIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuXHQgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuXHQgICAqL1xuXHQgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG5cdCAgICByZXR1cm4gX2Jhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuXHQgICAgICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuXHQgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuXHQgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuXHQgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcblx0ICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcblx0ICAgICAgICA6IHVuZGVmaW5lZDtcblxuXHQgICAgICBpZiAoZ3VhcmQgJiYgX2lzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuXHQgICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPCAzID8gdW5kZWZpbmVkIDogY3VzdG9taXplcjtcblx0ICAgICAgICBsZW5ndGggPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXHQgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcblx0ICAgICAgICBpZiAoc291cmNlKSB7XG5cdCAgICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gb2JqZWN0O1xuXHQgICAgfSk7XG5cdCAgfVxuXG5cdCAgdmFyIF9jcmVhdGVBc3NpZ25lciA9IGNyZWF0ZUFzc2lnbmVyO1xuXG5cdCAgLyoqXG5cdCAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG5cdCAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcblx0ICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcblx0ICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcblx0ICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuXHQgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuXHQgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG5cdCAgICpcblx0ICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cblx0ICAgKlxuXHQgICAqIEBzdGF0aWNcblx0ICAgKiBAbWVtYmVyT2YgX1xuXHQgICAqIEBzaW5jZSAwLjUuMFxuXHQgICAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG5cdCAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG5cdCAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cblx0ICAgKiBAZXhhbXBsZVxuXHQgICAqXG5cdCAgICogdmFyIG9iamVjdCA9IHtcblx0ICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG5cdCAgICogfTtcblx0ICAgKlxuXHQgICAqIHZhciBvdGhlciA9IHtcblx0ICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG5cdCAgICogfTtcblx0ICAgKlxuXHQgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG5cdCAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuXHQgICAqL1xuXHQgIHZhciBtZXJnZSA9IF9jcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcblx0ICAgIF9iYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcblx0ICB9KTtcblxuXHQgIHZhciBtZXJnZV8xID0gbWVyZ2U7XG5cblx0ICAvL1xuXHQgIC8vXG5cdCAgLy9cblx0ICAvL1xuXHQgIC8vXG5cdCAgLy9cblx0ICB2YXIgc2NyaXB0ID0ge307XG5cblx0ICAvKiBzY3JpcHQgKi9cblx0ICAgICAgICAgICAgICB2YXIgX192dWVfc2NyaXB0X18gPSBzY3JpcHQ7XG5cdCAgICAgICAgICAgICAgXG5cdCAgLyogdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfcmVuZGVyX18gPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBfdm0gPSB0aGlzO1xuXHQgICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50O1xuXHQgICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oO1xuXHQgICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZGlhbG9nLWxheW91dFwiIH0sIFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwgMilcblx0ICB9O1xuXHQgIHZhciBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyA9IFtdO1xuXHQgIF9fdnVlX3JlbmRlcl9fLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuXG5cdCAgICAvKiBzdHlsZSAqL1xuXHQgICAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyA9IHVuZGVmaW5lZDtcblx0ICAgIC8qIHNjb3BlZCAqL1xuXHQgICAgdmFyIF9fdnVlX3Njb3BlX2lkX18gPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuXHQgICAgdmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG5cdCAgICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fID0gZmFsc2U7XG5cdCAgICAvKiBjb21wb25lbnQgbm9ybWFsaXplciAqL1xuXHQgICAgZnVuY3Rpb24gX192dWVfbm9ybWFsaXplX18oXG5cdCAgICAgIHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0JCQxLFxuXHQgICAgICBzY29wZSwgZnVuY3Rpb25hbCwgbW9kdWxlSWRlbnRpZmllcixcblx0ICAgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgICApIHtcblx0ICAgICAgdmFyIGNvbXBvbmVudCA9ICh0eXBlb2Ygc2NyaXB0JCQxID09PSAnZnVuY3Rpb24nID8gc2NyaXB0JCQxLm9wdGlvbnMgOiBzY3JpcHQkJDEpIHx8IHt9O1xuXG5cdCAgICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgICAgY29tcG9uZW50Ll9fZmlsZSA9IFwiL1VzZXJzL3lhcmlrL1Byb2plY3RzL2Nsb25lcy92dWVkbC9zcmMvY29tcG9uZW50cy9EZWZhdWx0TGF5b3V0LnZ1ZVwiO1xuXG5cdCAgICAgIGlmICghY29tcG9uZW50LnJlbmRlcikge1xuXHQgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgICAgY29tcG9uZW50LnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICAgICAgICBjb21wb25lbnQuX2NvbXBpbGVkID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgICB9XG5cblx0ICAgICAgY29tcG9uZW50Ll9zY29wZUlkID0gc2NvcGU7XG5cblx0ICAgICAgXG5cblx0ICAgICAgcmV0dXJuIGNvbXBvbmVudFxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgICBmdW5jdGlvbiBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXygpIHtcblx0ICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdCAgICAgIHZhciBzdHlsZXMgPSBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXy5zdHlsZXMgfHwgKF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fLnN0eWxlcyA9IHt9KTtcblx0ICAgICAgdmFyIGlzT2xkSUUgPVxuXHQgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgICAgL21zaWUgWzYtOV1cXFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBhZGRTdHlsZShpZCwgY3NzKSB7XG5cdCAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgaWQgKyAnXCJdJykpIHsgcmV0dXJuIH0gLy8gU1NSIHN0eWxlcyBhcmUgcHJlc2VudC5cblxuXHQgICAgICAgIHZhciBncm91cCA9IGlzT2xkSUUgPyBjc3MubWVkaWEgfHwgJ2RlZmF1bHQnIDogaWQ7XG5cdCAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2dyb3VwXSB8fCAoc3R5bGVzW2dyb3VwXSA9IHsgaWRzOiBbXSwgcGFydHM6IFtdLCBlbGVtZW50OiB1bmRlZmluZWQgfSk7XG5cblx0ICAgICAgICBpZiAoIXN0eWxlLmlkcy5pbmNsdWRlcyhpZCkpIHtcblx0ICAgICAgICAgIHZhciBjb2RlID0gY3NzLnNvdXJjZTtcblx0ICAgICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmlkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgIHN0eWxlLmlkcy5wdXNoKGlkKTtcblxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudCA9IHN0eWxlLmVsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1ncm91cD0nICsgZ3JvdXAgKyAnXScpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoIXN0eWxlLmVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGVsID0gc3R5bGUuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICAgICAgICAgIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuXG5cdCAgICAgICAgICAgIGlmIChjc3MubWVkaWEpIHsgZWwuc2V0QXR0cmlidXRlKCdtZWRpYScsIGNzcy5tZWRpYSk7IH1cblx0ICAgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnLCBncm91cCk7XG5cdCAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnLCAnMCcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoc3R5bGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcpKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsIGluZGV4ICsgMSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0ICAgICAgICAgICAgc3R5bGUucGFydHMucHVzaChjb2RlKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZS5wYXJ0c1xuXHQgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcblx0ICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb2RlKTtcblx0ICAgICAgICAgICAgdmFyIG5vZGVzID0gc3R5bGUuZWxlbWVudC5jaGlsZE5vZGVzO1xuXHQgICAgICAgICAgICBpZiAobm9kZXNbaW5kZXhdKSB7IHN0eWxlLmVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZXNbaW5kZXhdKTsgfVxuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7IHN0eWxlLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICAgIGVsc2UgeyBzdHlsZS5lbGVtZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTsgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgICAgXG5cblx0ICAgIFxuXHQgICAgdmFyIERlZmF1bHRMYXlvdXQgPSBfX3Z1ZV9ub3JtYWxpemVfXyhcblx0ICAgICAgeyByZW5kZXI6IF9fdnVlX3JlbmRlcl9fLCBzdGF0aWNSZW5kZXJGbnM6IF9fdnVlX3N0YXRpY1JlbmRlckZuc19fIH0sXG5cdCAgICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyxcblx0ICAgICAgX192dWVfc2NyaXB0X18sXG5cdCAgICAgIF9fdnVlX3Njb3BlX2lkX18sXG5cdCAgICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyxcblx0ICAgICAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyxcblx0ICAgICAgX192dWVfY3JlYXRlX2luamVjdG9yX18sXG5cdCAgICAgIHVuZGVmaW5lZFxuXHQgICAgKTtcblxuXHQgIC8qXG5cdCAgICogdnVlZGxcblx0ICAgKlxuXHQgICAqIChjKSBTYXZhcnluIFlhcm9zbGF2IDx5YXJpa3NhdkBnbWFpbC5jb20+XG5cdCAgICpcblx0ICAgKiBTb21lIGZ1bmN0aW9ucyB3YXMgaW1wb3J0ZWQgZnJvbSBudXh0LmpzL2xpYi9hcHAvdXRpbHMuanNcblx0ICAgKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuXHQgICAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuXHQgICovXG5cblx0ICB2YXIgbm9vcERhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe30pOyB9O1xuXG5cdCAgZnVuY3Rpb24gcHJvbWlzaWZ5KGZuLCBjb250ZXh0KSB7XG5cdCAgICB2YXIgcHJvbWlzZTtcblxuXHQgICAgaWYgKGZuLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICAvLyBmbihjb250ZXh0LCBjYWxsYmFjaylcblx0ICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgZm4oY29udGV4dCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuXHQgICAgICAgICAgaWYgKGVycikge1xuXHQgICAgICAgICAgICBjb250ZXh0LmVycm9yKGVycik7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuXHQgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgfSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBwcm9taXNlID0gZm4oY29udGV4dCk7XG5cdCAgICB9XG5cblx0ICAgIGlmICghcHJvbWlzZSB8fCAhKHByb21pc2UgaW5zdGFuY2VvZiBQcm9taXNlKSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuICE9PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBwcm9taXNlO1xuXHQgIH1cblx0ICBmdW5jdGlvbiBkZXN0cm95VnVlRWxlbWVudCh2bSkge1xuXHQgICAgaWYgKHZtICYmICF2bS5faXNEZXN0cm95ZWQgJiYgdHlwZW9mIHZtLiRkZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZtLiRkZXN0cm95KCk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGZ1bmN0aW9uIGZpbmRDb250YWluZXIoY29udGFpbmVyKSB7XG5cdCAgICB2YXIgZm91bmQ7XG5cblx0ICAgIGlmICh0eXBlb2YgY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuXHQgICAgICBmb3VuZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvdW5kID0gY29udGFpbmVyO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoIWZvdW5kKSB7XG5cdCAgICAgIGZvdW5kID0gZG9jdW1lbnQuYm9keTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGZvdW5kO1xuXHQgIH1cblx0ICBmdW5jdGlvbiBhcHBseUFzeW5jRGF0YShDb21wb25lbnQsIGFzeW5jRGF0YSkge1xuXHQgICAgdmFyIENvbXBvbmVudERhdGEgPSBDb21wb25lbnQub3B0aW9ucy5kYXRhIHx8IG5vb3BEYXRhOyAvLyBQcmV2ZW50IGNhbGxpbmcgdGhpcyBtZXRob2QgZm9yIGVhY2ggcmVxdWVzdCBvbiBTU1IgY29udGV4dFxuXG5cdCAgICBpZiAoIWFzeW5jRGF0YSAmJiBDb21wb25lbnQub3B0aW9ucy5oYXNBc3luY0RhdGEpIHtcblx0ICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXG5cdCAgICBDb21wb25lbnQub3B0aW9ucy5oYXNBc3luY0RhdGEgPSB0cnVlO1xuXG5cdCAgICBDb21wb25lbnQub3B0aW9ucy5kYXRhID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICB2YXIgZGF0YSA9IENvbXBvbmVudERhdGEuY2FsbCh0aGlzKTtcblxuXHQgICAgICBpZiAodGhpcy4kc3NyQ29udGV4dCkge1xuXHQgICAgICAgIGFzeW5jRGF0YSA9IHRoaXMuJHNzckNvbnRleHQuYXN5bmNEYXRhW0NvbXBvbmVudC5jaWRdO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRhdGEsIGFzeW5jRGF0YSk7XG5cdCAgICB9O1xuXG5cdCAgICBpZiAoQ29tcG9uZW50Ll9DdG9yICYmIENvbXBvbmVudC5fQ3Rvci5vcHRpb25zKSB7XG5cdCAgICAgIENvbXBvbmVudC5fQ3Rvci5vcHRpb25zLmRhdGEgPSBDb21wb25lbnQub3B0aW9ucy5kYXRhO1xuXHQgICAgfVxuXHQgIH1cblx0ICBmdW5jdGlvbiBlbnN1cmVBc3luY0RhdGFzKGNvbXBvbmVudHMsIGNvbnRleHQpIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoJHJldHVybiwgJGVycm9yKSB7XG5cdCAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb21wb25lbnRzKSkge1xuXHQgICAgICAgIGlmICghY29tcG9uZW50cykge1xuXHQgICAgICAgICAgcmV0dXJuICRyZXR1cm4obnVsbCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGNvbXBvbmVudHMgPSBbY29tcG9uZW50c107XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuICRyZXR1cm4oUHJvbWlzZS5hbGwoY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKENvbXBvbmVudCkge1xuXHQgICAgICAgIHZhciBwcm9taXNlcyA9IFtdOyAvLyBDYWxsIGFzeW5jRGF0YShjb250ZXh0KVxuXG5cdCAgICAgICAgaWYgKENvbXBvbmVudC5vcHRpb25zLmFzeW5jRGF0YSAmJiB0eXBlb2YgQ29tcG9uZW50Lm9wdGlvbnMuYXN5bmNEYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICB2YXIgcHJvbWlzZSA9IHByb21pc2lmeShDb21wb25lbnQub3B0aW9ucy5hc3luY0RhdGEsIGNvbnRleHQpO1xuXHQgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChhc3luY0RhdGFSZXN1bHQpIHtcblx0ICAgICAgICAgICAgLy8gc3NyQ29udGV4dC5hc3luY0RhdGFbQ29tcG9uZW50LmNpZF0gPSBhc3luY0RhdGFSZXN1bHRcblx0ICAgICAgICAgICAgYXBwbHlBc3luY0RhdGEoQ29tcG9uZW50LCBhc3luY0RhdGFSZXN1bHQpO1xuXHQgICAgICAgICAgICByZXR1cm4gYXN5bmNEYXRhUmVzdWx0O1xuXHQgICAgICAgICAgfSk7XG5cdCAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBwcm9taXNlcy5wdXNoKG51bGwpO1xuXHQgICAgICAgIH0gLy8gQ2FsbCBmZXRjaChjb250ZXh0KVxuXG5cblx0ICAgICAgICBpZiAoQ29tcG9uZW50Lm9wdGlvbnMuZmV0Y2gpIHtcblx0ICAgICAgICAgIHByb21pc2VzLnB1c2goQ29tcG9uZW50Lm9wdGlvbnMuZmV0Y2goY29udGV4dCkpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBwcm9taXNlcy5wdXNoKG51bGwpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cdCAgICAgIH0pKSk7XG5cdCAgICB9KTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBIZWxwZXJzLlxuXHQgICAqL1xuXG5cdCAgdmFyIHMgPSAxMDAwO1xuXHQgIHZhciBtID0gcyAqIDYwO1xuXHQgIHZhciBoID0gbSAqIDYwO1xuXHQgIHZhciBkID0gaCAqIDI0O1xuXHQgIHZhciB5ID0gZCAqIDM2NS4yNTtcblxuXHQgIC8qKlxuXHQgICAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG5cdCAgICpcblx0ICAgKiBPcHRpb25zOlxuXHQgICAqXG5cdCAgICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cblx0ICAgKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcblx0ICAgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICB2YXIgbXMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcblx0ICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXHQgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG5cdCAgICAgIHJldHVybiBwYXJzZSh2YWwpO1xuXHQgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuXHQgICAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcblx0ICAgICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG5cdCAgICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuXHQgICAgKTtcblx0ICB9O1xuXG5cdCAgLyoqXG5cdCAgICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuXHQgICAqIEByZXR1cm4ge051bWJlcn1cblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuXHQgICAgc3RyID0gU3RyaW5nKHN0cik7XG5cdCAgICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuXHQgICAgICBzdHJcblx0ICAgICk7XG5cdCAgICBpZiAoIW1hdGNoKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgc3dpdGNoICh0eXBlKSB7XG5cdCAgICAgIGNhc2UgJ3llYXJzJzpcblx0ICAgICAgY2FzZSAneWVhcic6XG5cdCAgICAgIGNhc2UgJ3lycyc6XG5cdCAgICAgIGNhc2UgJ3lyJzpcblx0ICAgICAgY2FzZSAneSc6XG5cdCAgICAgICAgcmV0dXJuIG4gKiB5O1xuXHQgICAgICBjYXNlICdkYXlzJzpcblx0ICAgICAgY2FzZSAnZGF5Jzpcblx0ICAgICAgY2FzZSAnZCc6XG5cdCAgICAgICAgcmV0dXJuIG4gKiBkO1xuXHQgICAgICBjYXNlICdob3Vycyc6XG5cdCAgICAgIGNhc2UgJ2hvdXInOlxuXHQgICAgICBjYXNlICdocnMnOlxuXHQgICAgICBjYXNlICdocic6XG5cdCAgICAgIGNhc2UgJ2gnOlxuXHQgICAgICAgIHJldHVybiBuICogaDtcblx0ICAgICAgY2FzZSAnbWludXRlcyc6XG5cdCAgICAgIGNhc2UgJ21pbnV0ZSc6XG5cdCAgICAgIGNhc2UgJ21pbnMnOlxuXHQgICAgICBjYXNlICdtaW4nOlxuXHQgICAgICBjYXNlICdtJzpcblx0ICAgICAgICByZXR1cm4gbiAqIG07XG5cdCAgICAgIGNhc2UgJ3NlY29uZHMnOlxuXHQgICAgICBjYXNlICdzZWNvbmQnOlxuXHQgICAgICBjYXNlICdzZWNzJzpcblx0ICAgICAgY2FzZSAnc2VjJzpcblx0ICAgICAgY2FzZSAncyc6XG5cdCAgICAgICAgcmV0dXJuIG4gKiBzO1xuXHQgICAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuXHQgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG5cdCAgICAgIGNhc2UgJ21zZWNzJzpcblx0ICAgICAgY2FzZSAnbXNlYyc6XG5cdCAgICAgIGNhc2UgJ21zJzpcblx0ICAgICAgICByZXR1cm4gbjtcblx0ICAgICAgZGVmYXVsdDpcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgICAqIEByZXR1cm4ge1N0cmluZ31cblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG5cdCAgICBpZiAobXMgPj0gZCkge1xuXHQgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuXHQgICAgfVxuXHQgICAgaWYgKG1zID49IGgpIHtcblx0ICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcblx0ICAgIH1cblx0ICAgIGlmIChtcyA+PSBtKSB7XG5cdCAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG5cdCAgICB9XG5cdCAgICBpZiAobXMgPj0gcykge1xuXHQgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG1zICsgJ21zJztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuXHQgICAqIEByZXR1cm4ge1N0cmluZ31cblx0ICAgKiBAYXBpIHByaXZhdGVcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGZtdExvbmcobXMpIHtcblx0ICAgIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuXHQgICAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcblx0ICAgICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcblx0ICAgICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcblx0ICAgICAgbXMgKyAnIG1zJztcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuXHQgICAgaWYgKG1zIDwgbikge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cdCAgICBpZiAobXMgPCBuICogMS41KSB7XG5cdCAgICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcblx0ICB9XG5cblx0ICB2YXIgZGVidWcgPSBjcmVhdGVDb21tb25qc01vZHVsZSQkMShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCAgLyoqXG5cdCAgICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuXHQgICAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG5cdCAgICpcblx0ICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAgICovXG5cblx0ICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1Zztcblx0ICBleHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcblx0ICBleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuXHQgIGV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuXHQgIGV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdCAgZXhwb3J0cy5odW1hbml6ZSA9IG1zO1xuXG5cdCAgLyoqXG5cdCAgICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuXHQgICAqL1xuXHQgIGV4cG9ydHMuaW5zdGFuY2VzID0gW107XG5cblx0ICAvKipcblx0ICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0ICAgKi9cblxuXHQgIGV4cG9ydHMubmFtZXMgPSBbXTtcblx0ICBleHBvcnRzLnNraXBzID0gW107XG5cblx0ICAvKipcblx0ICAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCAgICpcblx0ICAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQgIC8qKlxuXHQgICAqIFNlbGVjdCBhIGNvbG9yLlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0ICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0ICAgIHZhciBoYXNoID0gMCwgaTtcblxuXHQgICAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuXHQgICAgICBoYXNoICA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCAgICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXG5cdCAgICB2YXIgcHJldlRpbWU7XG5cblx0ICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuXHQgICAgICAvLyBkaXNhYmxlZD9cblx0ICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cblx0ICAgICAgdmFyIHNlbGYgPSBkZWJ1ZztcblxuXHQgICAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHQgICAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuXHQgICAgICB2YXIgbXMkJDEgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHQgICAgICBzZWxmLmRpZmYgPSBtcyQkMTtcblx0ICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdCAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG5cdCAgICAgIHByZXZUaW1lID0gY3VycjtcblxuXHQgICAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG5cdCAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHQgICAgICB9XG5cblx0ICAgICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdCAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcblx0ICAgICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHQgICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdCAgICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG5cdCAgICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHQgICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuXHQgICAgICAgIGluZGV4Kys7XG5cdCAgICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHQgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG5cdCAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG5cdCAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0ICAgICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0ICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgICAgIGluZGV4LS07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBtYXRjaDtcblx0ICAgICAgfSk7XG5cblx0ICAgICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0ICAgICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0ICAgICAgdmFyIGxvZ0ZuID0gZGVidWcubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5cdCAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHQgICAgfVxuXG5cdCAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdCAgICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdCAgICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuXHQgICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHQgICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0ICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdCAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuXHQgICAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuXHQgICAgfVxuXG5cdCAgICBleHBvcnRzLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcblxuXHQgICAgcmV0dXJuIGRlYnVnO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xuXHQgICAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblx0ICAgIGlmIChpbmRleCAhPT0gLTEpIHtcblx0ICAgICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQgICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHQgICAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdCAgICBleHBvcnRzLm5hbWVzID0gW107XG5cdCAgICBleHBvcnRzLnNraXBzID0gW107XG5cblx0ICAgIHZhciBpO1xuXHQgICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0ICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0ICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0ICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cdCAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0ICAgICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgZXhwb3J0cy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIGluc3RhbmNlID0gZXhwb3J0cy5pbnN0YW5jZXNbaV07XG5cdCAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcblx0ICAgIH1cblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHQgICAgZXhwb3J0cy5lbmFibGUoJycpO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCAgICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICAgKiBAYXBpIHB1YmxpY1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdCAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICB2YXIgaSwgbGVuO1xuXHQgICAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIENvZXJjZSBgdmFsYC5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQgICAqIEByZXR1cm4ge01peGVkfVxuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHQgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHQgICAgcmV0dXJuIHZhbDtcblx0ICB9XG5cdCAgfSk7XG5cdCAgdmFyIGRlYnVnXzEgPSBkZWJ1Zy5jb2VyY2U7XG5cdCAgdmFyIGRlYnVnXzIgPSBkZWJ1Zy5kaXNhYmxlO1xuXHQgIHZhciBkZWJ1Z18zID0gZGVidWcuZW5hYmxlO1xuXHQgIHZhciBkZWJ1Z180ID0gZGVidWcuZW5hYmxlZDtcblx0ICB2YXIgZGVidWdfNSA9IGRlYnVnLmh1bWFuaXplO1xuXHQgIHZhciBkZWJ1Z182ID0gZGVidWcuaW5zdGFuY2VzO1xuXHQgIHZhciBkZWJ1Z183ID0gZGVidWcubmFtZXM7XG5cdCAgdmFyIGRlYnVnXzggPSBkZWJ1Zy5za2lwcztcblx0ICB2YXIgZGVidWdfOSA9IGRlYnVnLmZvcm1hdHRlcnM7XG5cblx0ICB2YXIgYnJvd3NlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlJCQxKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0ICAvKipcblx0ICAgKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG5cdCAgICpcblx0ICAgKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG5cdCAgICovXG5cblx0ICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1Zztcblx0ICBleHBvcnRzLmxvZyA9IGxvZztcblx0ICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHQgIGV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5cdCAgZXhwb3J0cy5sb2FkID0gbG9hZDtcblx0ICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblx0ICBleHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG5cdCAgICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG5cdCAgICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuXHQgICAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cblx0ICAvKipcblx0ICAgKiBDb2xvcnMuXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmNvbG9ycyA9IFtcblx0ICAgICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcblx0ICAgICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcblx0ICAgICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcblx0ICAgICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcblx0ICAgICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcblx0ICAgICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcblx0ICAgICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2Jyxcblx0ICAgICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcblx0ICAgICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcblx0ICAgICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcblx0ICAgICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcblx0ICBdO1xuXG5cdCAgLyoqXG5cdCAgICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcblx0ICAgKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cblx0ICAgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG5cdCAgICpcblx0ICAgKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQgICAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQgICAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0ICAgIC8vIGV4cGxpY2l0bHlcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdCAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXG5cdCAgICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQgICAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0ICAgIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHQgICAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdCAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdCAgICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuXHQgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0ICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdCAgICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0ICAgICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcblx0ICB9XG5cblx0ICAvKipcblx0ICAgKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG5cdCAgICovXG5cblx0ICBleHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0ICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyLm1lc3NhZ2U7XG5cdCAgICB9XG5cdCAgfTtcblxuXG5cdCAgLyoqXG5cdCAgICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuXHQgICAqXG5cdCAgICogQGFwaSBwdWJsaWNcblx0ICAgKi9cblxuXHQgIGZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHQgICAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG5cdCAgICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcblx0ICAgICAgKyB0aGlzLm5hbWVzcGFjZVxuXHQgICAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcblx0ICAgICAgKyBhcmdzWzBdXG5cdCAgICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuXHQgICAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHQgICAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuXHQgICAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHQgICAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0ICAgIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdCAgICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdCAgICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0ICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICB2YXIgbGFzdEMgPSAwO1xuXHQgICAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG5cdCAgICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuXHQgICAgICBpbmRleCsrO1xuXHQgICAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcblx0ICAgICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0ICAgICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHQgICAgICAgIGxhc3RDID0gaW5kZXg7XG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG5cdCAgICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cblx0ICAgKlxuXHQgICAqIEBhcGkgcHVibGljXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBsb2coKSB7XG5cdCAgICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuXHQgICAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0ICAgIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcblx0ICAgICAgJiYgY29uc29sZS5sb2dcblx0ICAgICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogU2F2ZSBgbmFtZXNwYWNlc2AuXG5cdCAgICpcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG5cdCAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcblx0ICAgICAgfVxuXHQgICAgfSBjYXRjaChlKSB7fVxuXHQgIH1cblxuXHQgIC8qKlxuXHQgICAqIExvYWQgYG5hbWVzcGFjZXNgLlxuXHQgICAqXG5cdCAgICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuXHQgICAqIEBhcGkgcHJpdmF0ZVxuXHQgICAqL1xuXG5cdCAgZnVuY3Rpb24gbG9hZCgpIHtcblx0ICAgIHZhciByO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1Zztcblx0ICAgIH0gY2F0Y2goZSkge31cblxuXHQgICAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHQgICAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdCAgICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfVxuXG5cdCAgLyoqXG5cdCAgICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cblx0ICAgKi9cblxuXHQgIGV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblx0ICAvKipcblx0ICAgKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG5cdCAgICpcblx0ICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3Ncblx0ICAgKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuXHQgICAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG5cdCAgICpcblx0ICAgKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG5cdCAgICogQGFwaSBwcml2YXRlXG5cdCAgICovXG5cblx0ICBmdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgfVxuXHQgIH0pO1xuXHQgIHZhciBicm93c2VyXzEgPSBicm93c2VyLmxvZztcblx0ICB2YXIgYnJvd3Nlcl8yID0gYnJvd3Nlci5mb3JtYXRBcmdzO1xuXHQgIHZhciBicm93c2VyXzMgPSBicm93c2VyLnNhdmU7XG5cdCAgdmFyIGJyb3dzZXJfNCA9IGJyb3dzZXIubG9hZDtcblx0ICB2YXIgYnJvd3Nlcl81ID0gYnJvd3Nlci51c2VDb2xvcnM7XG5cdCAgdmFyIGJyb3dzZXJfNiA9IGJyb3dzZXIuc3RvcmFnZTtcblx0ICB2YXIgYnJvd3Nlcl83ID0gYnJvd3Nlci5jb2xvcnM7XG5cblx0ICAvKlxuXHQgICAqIHZ1ZWRsXG5cdCAgICpcblx0ICAgKiAoYykgU2F2YXJ5biBZYXJvc2xhdiA8eWFyaWtzYXZAZ21haWwuY29tPlxuXHQgICAqXG5cdCAgICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0Vcblx0ICAgKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cblx0ICAqL1xuXHQgIHZhciBkZWJ1ZyQxID0gYnJvd3NlcigndnVlZGw6ZGlhbG9nJyk7XG5cdCAgdmFyIHNlZWQgPSAxO1xuXHQgIHZhciBEaWFsb2cgPSBmdW5jdGlvbiBEaWFsb2coY29tcG9uZW50LCByZWYpIHtcblx0ICAgIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcblx0ICAgIHZhciBsYXlvdXQgPSByZWYubGF5b3V0O1xuXHQgICAgdmFyIGNvbnRhaW5lciA9IHJlZi5jb250YWluZXI7XG5cblx0ICAgIGlmICghY29tcG9uZW50KSB7XG5cdCAgICAgIHRocm93IEVycm9yKCdDb21wb25lbnQgd2FzIG5vdCBzZXR0ZWQnKTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0IHx8IHtcblx0ICAgICAgY29tcG9uZW50OiBEZWZhdWx0TGF5b3V0LFxuXHQgICAgICBvcHRpb25zOiB7fVxuXHQgICAgfTtcblx0ICAgIHRoaXMuX2NvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0ICAgIHRoaXMuX3ZtID0gbnVsbDtcblx0ICAgIHRoaXMuX3ZtRGlhbG9nID0gbnVsbDtcblx0ICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcblx0ICAgIHRoaXMuaWQgPSArK3NlZWQ7XG5cdCAgICB0aGlzLl9yZXNvbHZlcnMgPSBbXTtcblx0ICAgIHRoaXMuY29udGFpbmVyID0gZmluZENvbnRhaW5lcihjb250YWluZXIpO1xuXHQgICAgZGVidWckMSgnY3JlYXRlZCcpO1xuXHQgIH07XG5cblx0ICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBzaG93ZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZWxlbWVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSxoYXNBc3luY1ByZWxvYWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdm06IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sdm1kOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblx0ICBEaWFsb2cucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93IChwYXJhbXMsIG9wdGlvbnMpIHtcblx0ICAgICAgaWYgKCBwYXJhbXMgPT09IHZvaWQgMCApIHBhcmFtcyA9IHt9O1xuXHQgICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uICgkcmV0dXJuLCAkZXJyb3IpIHtcblx0ICAgICAgdmFyIExheW91dEN0b3IsIGxheW91dCwgRGlhbG9nQ3RvciwgZGlhbG9nO1xuXHQgICAgICBpZiAoVnVlLnByb3RvdHlwZS4kaXNTZXJ2ZXIpIHsgcmV0dXJuICRyZXR1cm4oKTsgfVxuXHQgICAgICBkZWJ1ZyQxKCdiZWZvcmUgc2hvdycsIHtcblx0ICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICBvcHRpb25zOiBvcHRpb25zXG5cdCAgICAgIH0pOyAvLyBjcmVhdGUgbGF5b3V0XG5cblx0ICAgICAgTGF5b3V0Q3RvciA9IFZ1ZS5leHRlbmQodGhpcy5fbGF5b3V0LmNvbXBvbmVudCk7XG5cdCAgICAgIExheW91dEN0b3IgPSBMYXlvdXRDdG9yLmV4dGVuZCh7XG5cdCAgICAgICAgbWl4aW5zOiBbTGF5b3V0YWJsZV0sXG5cdCAgICAgICAgZGVzdHJveWVkOiB0aGlzLl9vbkRlc3Ryb3llZC5iaW5kKHRoaXMpXG5cdCAgICAgIH0pO1xuXHQgICAgICBsYXlvdXQgPSBuZXcgTGF5b3V0Q3RvcihtZXJnZV8xKHtcblx0ICAgICAgICBwcm9wc0RhdGE6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2xheW91dC5vcHRpb25zLCBwYXJhbXMpXG5cdCAgICAgIH0sIHRoaXMuY29udGV4dCwgb3B0aW9ucykpO1xuXHQgICAgICBEaWFsb2dDdG9yID0gVnVlLmV4dGVuZChPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9jb21wb25lbnQsIHtcblx0ICAgICAgICBwYXJlbnQ6IGxheW91dFxuXHQgICAgICB9KSk7XG5cblx0ICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudC5wcmltYXJ5S2V5KSB7XG5cdCAgICAgICAgRGlhbG9nQ3RvciA9IERpYWxvZ0N0b3IuZXh0ZW5kKHtcblx0ICAgICAgICAgIG1peGluczogW1JlY29yZGFibGVdXG5cdCAgICAgICAgfSk7XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAodGhpcy5oYXNBc3luY1ByZWxvYWQpIHtcblx0ICAgICAgICB2YXIgcmVzO1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZW5zdXJlQXN5bmNEYXRhcyhEaWFsb2dDdG9yLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbnRleHQsIHtcblx0ICAgICAgICAgIHBhcmFtczogcGFyYW1zXG5cdCAgICAgICAgfSkpKS50aGVuKGZ1bmN0aW9uICgkYXdhaXRfMikge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmVzID0gJGF3YWl0XzI7XG5cdCAgICAgICAgICAgIGRlYnVnJDEoJ2FzeW5jIGRhdGFzJywgcmVzKTtcblx0ICAgICAgICAgICAgcmV0dXJuICRJZl8xLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICB9IGNhdGNoICgkYm91bmRFeCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJGVycm9yKCRib3VuZEV4KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9LmJpbmQodGhpcyksICRlcnJvcik7XG5cdCAgICAgIH1cblxuXHQgICAgICBmdW5jdGlvbiAkSWZfMSgpIHtcblx0ICAgICAgICBkaWFsb2cgPSBuZXcgRGlhbG9nQ3RvcihtZXJnZV8xKHtcblx0ICAgICAgICAgIHByb3BzRGF0YTogcGFyYW1zXG5cdCAgICAgICAgfSwgdGhpcy5jb250ZXh0LCBvcHRpb25zKSk7XG5cdCAgICAgICAgLy8gbW91bnRpbmdcblx0ICAgICAgICBkaWFsb2cuJG1vdW50KCk7XG5cdCAgICAgICAgbGF5b3V0LiRzbG90cy5kZWZhdWx0ID0gZGlhbG9nLl92bm9kZTtcblx0ICAgICAgICBsYXlvdXQuJG1vdW50KCk7XG5cdCAgICAgICAgbGF5b3V0LiRvbignc3VibWl0JywgdGhpcy5vblJldHVybi5iaW5kKHRoaXMpKTtcblx0ICAgICAgICBkaWFsb2cuJG9uKCdzdWJtaXQnLCB0aGlzLm9uUmV0dXJuLmJpbmQodGhpcykpO1xuXHQgICAgICAgIHRoaXMuX3ZtID0gbGF5b3V0O1xuXHQgICAgICAgIHRoaXMuX3ZtLl9kaWFsb2dJbnN0YW5jZSA9IGRpYWxvZztcblx0ICAgICAgICB0aGlzLl92bURpYWxvZyA9IGRpYWxvZztcblx0ICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG9wdGlvbnMuY29udGFpbmVyID8gZmluZENvbnRhaW5lcihvcHRpb25zLmNvbnRhaW5lcikgOiB0aGlzLmNvbnRhaW5lcjtcblx0ICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuXHQgICAgICAgIHJldHVybiAkcmV0dXJuKHRoaXMpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuICRJZl8xLmNhbGwodGhpcyk7XG5cdCAgICB9LmJpbmQodGhpcykpO1xuXHQgIH07XG5cblx0ICBEaWFsb2cucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiB3YWl0ICgpIHtcblx0ICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0ICAgIC8vIGlmICghdGhpcy5zaG93ZWQpIHtcblx0ICAgIC8vIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0RpYWxvZyB3YXMgY2xvc2VkIG9yIG5vdCBzaG93ZWQnKSlcblx0ICAgIC8vIH1cblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICB0aGlzJDEuX3Jlc29sdmVycy5wdXNoKHJlc29sdmUpO1xuXHQgICAgfSk7XG5cdCAgfTtcblxuXHQgIERpYWxvZy5wcm90b3R5cGUuX29uRGVzdHJveWVkID0gZnVuY3Rpb24gX29uRGVzdHJveWVkICgpIHtcblx0ICAgIHRoaXMucmVtb3ZlKCk7XG5cdCAgfTtcblxuXHQgIERpYWxvZy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcblx0ICAgIGRlYnVnJDEoJ3JlbW92ZScpO1xuXHQgICAgdGhpcy5vbkRlc3Ryb3llZCAmJiB0aGlzLm9uRGVzdHJveWVkKHRoaXMpOyAvLyB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpXG5cblx0ICAgIHRoaXMuX3Byb2Nlc3NSZXN1bHRQcm9taXNlcygpO1xuXG5cdCAgICBkZXN0cm95VnVlRWxlbWVudCh0aGlzLl92bSk7XG5cdCAgICBkZXN0cm95VnVlRWxlbWVudCh0aGlzLl92bURpYWxvZyk7XG5cdCAgICB0aGlzLl92bSA9IG51bGw7XG5cdCAgICB0aGlzLl92bURpYWxvZyA9IG51bGw7XG5cdCAgfTtcblxuXHQgIERpYWxvZy5wcm90b3R5cGUuX3Byb2Nlc3NSZXN1bHRQcm9taXNlcyA9IGZ1bmN0aW9uIF9wcm9jZXNzUmVzdWx0UHJvbWlzZXMgKHJlc3VsdCkge1xuXHQgICAgaWYgKCF0aGlzLl9yZXNvbHZlcnMubGVuZ3RoKSB7XG5cdCAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgZGVidWckMSgncHJvY2Vzc1Jlc3VsdFByb21pc2VzJywgcmVzdWx0KTtcblxuXHQgICAgdGhpcy5fcmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVyKSB7IHJldHVybiByZXNvbHZlcihyZXN1bHQpOyB9KTtcblxuXHQgICAgdGhpcy5fcmVzb2x2ZXJzID0gW107XG5cdCAgfTtcblxuXHQgIERpYWxvZy5wcm90b3R5cGUub25SZXR1cm4gPSBmdW5jdGlvbiBvblJldHVybiAocmVzdWx0KSB7XG5cdCAgICBkZWJ1ZyQxKCdvblJldHVybicsIHJlc3VsdCk7XG5cblx0ICAgIHRoaXMuX3Byb2Nlc3NSZXN1bHRQcm9taXNlcyhyZXN1bHQpO1xuXG5cdCAgICB0aGlzLmNsb3NlKCk7XG5cdCAgfTtcblxuXHQgIHByb3RvdHlwZUFjY2Vzc29ycy5zaG93ZWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuICEhdGhpcy5fdm0gJiYgIXRoaXMuX3ZtLl9pc0Rlc3Ryb3llZDtcblx0ICB9O1xuXG5cdCAgcHJvdG90eXBlQWNjZXNzb3JzLmVsZW1lbnQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3ZtICYmIHRoaXMuX3ZtLiRlbDtcblx0ICB9O1xuXG5cdCAgcHJvdG90eXBlQWNjZXNzb3JzLmhhc0FzeW5jUHJlbG9hZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50ICYmICh0aGlzLl9jb21wb25lbnQuYXN5bmNEYXRhIHx8IHRoaXMuX2NvbXBvbmVudC5mZXRjaCk7XG5cdCAgfTtcblxuXHQgIHByb3RvdHlwZUFjY2Vzc29ycy52bS5nZXQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5fdm07XG5cdCAgfTtcblxuXHQgIHByb3RvdHlwZUFjY2Vzc29ycy52bWQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX3ZtRGlhbG9nO1xuXHQgIH07XG5cblx0ICBEaWFsb2cucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UgKCkge1xuXHQgICAgdGhpcy5fdm0uY2xvc2UoKTtcblx0ICB9O1xuXG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERpYWxvZy5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5cdCAgLypcblx0ICAgKiB2dWVkbFxuXHQgICAqXG5cdCAgICogKGMpIFNhdmFyeW4gWWFyb3NsYXYgPHlhcmlrc2F2QGdtYWlsLmNvbT5cblx0ICAgKlxuXHQgICAqIEZvciB0aGUgZnVsbCBjb3B5cmlnaHQgYW5kIGxpY2Vuc2UgaW5mb3JtYXRpb24sIHBsZWFzZSB2aWV3IHRoZSBMSUNFTlNFXG5cdCAgICogZmlsZSB0aGF0IHdhcyBkaXN0cmlidXRlZCB3aXRoIHRoaXMgc291cmNlIGNvZGUuXG5cdCAgKi9cblx0ICB2YXIgT3ZlcmxheSA9IGZ1bmN0aW9uIE92ZXJsYXkoY29tcG9uZW50KSB7XG5cdCAgICB0aGlzLl9jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cdCAgICB0aGlzLl92bSA9IG51bGw7XG5cdCAgfTtcblxuXHQgIE92ZXJsYXkucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93ICgpIHtcblx0ICAgIGlmICghdGhpcy5fdm0pIHtcblx0ICAgICAgdmFyIEN0b3IgPSBWdWUuZXh0ZW5kKHRoaXMuX2NvbXBvbmVudCk7XG5cdCAgICAgIHRoaXMuX3ZtID0gbmV3IEN0b3IoKTsgLy8ge3Byb3BzRGF0YTogeyB2aXNpYmxlOiB0cnVlIH19XG5cblx0ICAgICAgdGhpcy5fdm0uJG1vdW50KCk7XG5cblx0ICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl92bS4kZWwpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLl92bS52aXNpYmxlID0gdHJ1ZTtcblx0ICB9O1xuXG5cdCAgT3ZlcmxheS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIGhpZGUgKCkge1xuXHQgICAgdGhpcy5fdm0udmlzaWJsZSA9IGZhbHNlO1xuXHQgIH07XG5cblx0ICAvKlxuXHQgICAqIHZ1ZWRsXG5cdCAgICpcblx0ICAgKiAoYykgU2F2YXJ5biBZYXJvc2xhdiA8eWFyaWtzYXZAZ21haWwuY29tPlxuXHQgICAqXG5cdCAgICogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIExJQ0VOU0Vcblx0ICAgKiBmaWxlIHRoYXQgd2FzIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyBzb3VyY2UgY29kZS5cblx0ICAqL1xuXG5cdCAgdmFyIHByb3h5SGFuZGxlciA9IHtcblx0ICAgIGdldDogZnVuY3Rpb24gZ2V0KHRhcmdldCwgbmFtZSkge1xuXHQgICAgICAvKipcblx0ICAgICAgICogaWYgbm9kZSBpcyBpbnNwZWN0aW5nIHRoZW4gc3RpY2sgdG8gdGFyZ2V0IHByb3BlcnRpZXNcblx0ICAgICAgICovXG5cdCAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N5bWJvbCcgfHwgbmFtZSA9PT0gJ2luc3BlY3QnKSB7XG5cdCAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmICh0YXJnZXRbbmFtZV0pIHtcblx0ICAgICAgICByZXR1cm4gdGFyZ2V0W25hbWVdO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHRhcmdldC5fY29tcG9uZW50c1tuYW1lXSkge1xuXHQgICAgICAgIHJldHVybiB0YXJnZXQuY3JlYXRlRnVuY3Rpb25XcmFwcGVyKG5hbWUpO1xuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcblx0ICAgIH1cblxuXHQgIH07XG5cdCAgdmFyIERpYWxvZ01hbmFnZXIgPSBmdW5jdGlvbiBEaWFsb2dNYW5hZ2VyKHJlZikge1xuXHQgICAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuXHQgICAgdmFyIGNvbnRleHQgPSByZWYuY29udGV4dDtcblx0ICAgIHZhciBjb250YWluZXIgPSByZWYuY29udGFpbmVyO1xuXG5cdCAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dCB8fCB7fTtcblx0ICAgIERpYWxvZy5wcm90b3R5cGUuY29udGV4dCA9IGNvbnRleHQgfHwge307XG5cdCAgICB0aGlzLl9jb21wb25lbnRzID0ge307XG5cdCAgICB0aGlzLl9sYXlvdXRzID0ge307XG5cdCAgICB0aGlzLl9vdmVybGF5cyA9IHt9O1xuXHQgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXHQgICAgdGhpcy5fZW1pdHRlciA9IG5ldyBWdWUoe30pO1xuXHQgICAgdGhpcy5faW5zdGFuY2VzID0gW107IC8vIHRoaXMuaW5pdEVtaXR0ZXIoKVxuXG5cdCAgICByZXR1cm4gbmV3IFByb3h5KHRoaXMsIHByb3h5SGFuZGxlcik7XG5cdCAgfTtcblxuXHQgIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgY29udGV4dDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9OyAvLyBpbml0RW1pdHRlciAoKSB7XG5cdCAgLy8gdGhpcy5fZW1pdHRlci4kb24oJ3Nob3duJywgKHsgZGlhbG9nIH0pID0+IHtcblx0ICAvLyAgIGNvbnN0IHBvc2l0aW9uID0gZGlhbG9nLnZtLnBvc2l0aW9uXG5cdCAgLy8gICBsZXQgdmVydGljYWxPZmZzZXQgPSBub3RpZmljYXRpb25HYXBcblx0ICAvLyAgIHRoaXMuX2luc3RhbmNlcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnZtLnBvc2l0aW9uID09PSBwb3NpdGlvbikuZm9yRWFjaChpdGVtID0+IHtcblx0ICAvLyAgICAgdmVydGljYWxPZmZzZXQgKz0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodCArIG5vdGlmaWNhdGlvbkdhcFxuXHQgIC8vICAgfSlcblx0ICAvLyAgIHRoaXMuX2luc3RhbmNlcy5wdXNoKGRpYWxvZylcblx0ICAvLyAgIGRpYWxvZy52bS52ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsT2Zmc2V0XG5cdCAgLy8gfSlcblx0ICAvLyB0aGlzLl9lbWl0dGVyLiRvbignZGVzdHJveWVkJywgKHsgZGlhbG9nIH0pID0+IHtcblx0ICAvLyAgIGxldCBpbmRleCA9IHRoaXMuX2luc3RhbmNlcy5maW5kSW5kZXgoaW5zdGFuY2UgPT4gaW5zdGFuY2UuaWQgPT09IGRpYWxvZy5pZClcblx0ICAvLyAgIGlmIChpbmRleCA8IDApIHtcblx0ICAvLyAgICAgcmV0dXJuXG5cdCAgLy8gICB9XG5cdCAgLy8gICB0aGlzLl9pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKVxuXHQgIC8vICAgLy8gY29uc29sZS5sb2coJ2luc3RhbmNlcycsIHRoaXMuX2luc3RhbmNlcylcblx0ICAvLyAgIGNvbnN0IGxlbiA9IHRoaXMuX2luc3RhbmNlcy5sZW5ndGhcblx0ICAvLyAgIGNvbnN0IHBvc2l0aW9uID0gZGlhbG9nLnZtLnBvc2l0aW9uXG5cdCAgLy8gICBpZiAoIWxlbikgcmV0dXJuXG5cdCAgLy8gICBsZXQgdmVydGljYWxPZmZzZXQgPSBub3RpZmljYXRpb25HYXBcblx0ICAvLyAgIHRoaXMuX2luc3RhbmNlcy5maWx0ZXIoaXRlbSA9PiBpdGVtLnZtLnBvc2l0aW9uID09PSBwb3NpdGlvbikuZm9yRWFjaChpdGVtID0+IHtcblx0ICAvLyAgICAgaXRlbS52bS52ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsT2Zmc2V0XG5cdCAgLy8gICAgIHZlcnRpY2FsT2Zmc2V0ICs9IGl0ZW0uZWxlbWVudC5vZmZzZXRIZWlnaHQgKyBub3RpZmljYXRpb25HYXBcblx0ICAvLyAgIH0pXG5cdCAgLy8gfSlcblx0ICAvLyB9XG5cblxuXHQgIHByb3RvdHlwZUFjY2Vzc29ycyQxLmNvbnRleHQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdCAgfTtcblxuXHQgIERpYWxvZ01hbmFnZXIucHJvdG90eXBlLmxheW91dCA9IGZ1bmN0aW9uIGxheW91dCAobmFtZSwgY29tcG9uZW50LCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgICB0aGlzLl9sYXlvdXRzW25hbWVdID0ge1xuXHQgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcblx0ICAgICAgb3B0aW9uczogb3B0aW9uc1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gZ2V0TGF5b3V0IChsYXlvdXQpIHtcblx0ICAgIGlmICh0eXBlb2YgbGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgIHZhciBvcHRpb25zID0gbGF5b3V0LmNhbGwodGhpcyk7XG5cdCAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dHNbb3B0aW9ucy5uYW1lIHx8ICdkZWZhdWx0J107XG5cdCAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBsYXlvdXQsIHtcblx0ICAgICAgICBvcHRpb25zOiBvcHRpb25zXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodHlwZW9mIGxheW91dCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGxheW91dC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBjb21wb25lbnQ6IGxheW91dFxuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShsYXlvdXQpKSB7XG5cdCAgICAgIHZhciBuYW1lVG1wID0gbGF5b3V0WzBdO1xuXHQgICAgICB2YXIgb3B0aW9uc1RtcCA9IGxheW91dFsxXSB8fCB7fTtcblx0ICAgICAgdmFyIGluc3RhbmNlID0gdHlwZW9mIG5hbWVUbXAgPT09ICdvYmplY3QnICYmIHR5cGVvZiBuYW1lVG1wLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyA/IHtcblx0ICAgICAgICBjb21wb25lbnQ6IG5hbWVUbXBcblx0ICAgICAgfSA6IHRoaXMuX2xheW91dHNbbmFtZVRtcF07XG5cdCAgICAgIHJldHVybiBpbnN0YW5jZSAmJiB7XG5cdCAgICAgICAgY29tcG9uZW50OiBpbnN0YW5jZS5jb21wb25lbnQsXG5cdCAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2Uub3B0aW9ucywgb3B0aW9uc1RtcClcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuX2xheW91dHNbbGF5b3V0XTtcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUub3ZlcmxheSA9IGZ1bmN0aW9uIG92ZXJsYXkgKG5hbWUsIGNvbXBvbmVudCkge1xuXHQgICAgaWYgKGNvbXBvbmVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgIGlmICh0aGlzLl9vdmVybGF5c1tuYW1lXSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5c1tuYW1lXTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiT3ZlcmxheSBcXFwiXCIgKyBuYW1lICsgXCIgbm90IGZvdW5kXFxuICAgICAgICAgIFBsZWFzZSByZWdpc3RlciBpdCBieSBjYWxsaW5nIGRpYWxvZy5vdmVybGF5KCdcIiArIG5hbWUgKyBcIicsIGNvbXBvbmVudClcIikpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuX292ZXJsYXlzW25hbWVdID0gbmV3IE92ZXJsYXkoY29tcG9uZW50KTtcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0Q29tcG9uZW50IChuYW1lKSB7XG5cdCAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHNbbmFtZV0pIHtcblx0ICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkNvbXBvbmVudCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIHdhcyBub3QgZm91bmQuXFxuICAgICAgICBQbGVhc2UgcmVnaXN0ZXIgaXQgYnkgY2FsbGluZyBkaWFsb2cucmVnaXN0ZXIoJ1wiICsgbmFtZSArIFwiJywgY29tcG9uZW50KVwiKSk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW25hbWVdO1xuXHQgIH07XG5cblx0ICBEaWFsb2dNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnQgPSBmdW5jdGlvbiBjb21wb25lbnQgKG5hbWUsIGNvbXBvbmVudCQxLCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgICBpZiAoY29tcG9uZW50JDEgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tuYW1lXTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5fY29tcG9uZW50c1tuYW1lXSA9IHtcblx0ICAgICAgY29tcG9uZW50OiBjb21wb25lbnQkMSxcblx0ICAgICAgb3B0aW9uczogb3B0aW9uc1xuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChjb21wb25lbnQpIHtcblx0ICAgIGlmICghY29tcG9uZW50KSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignQ29tcG9uZW50IGlzIGluY29ycmVjdCcpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRMYXlvdXQoY29tcG9uZW50LmxheW91dCB8fCAnZGVmYXVsdCcpO1xuXHQgICAgdmFyIGRsZyA9IG5ldyBEaWFsb2coY29tcG9uZW50LCB7XG5cdCAgICAgIGxheW91dDogbGF5b3V0LFxuXHQgICAgICBjb250ZXh0OiB0aGlzLl9jb250ZXh0LFxuXHQgICAgICBjb250YWluZXI6IHRoaXMuX2NvbnRhaW5lclxuXHQgICAgfSk7XG5cblx0ICAgIHRoaXMuX2VtaXR0ZXIuJGVtaXQoJ2NyZWF0ZWQnLCB7XG5cdCAgICAgIGRpYWxvZzogZGxnXG5cdCAgICB9KTtcblxuXHQgICAgcmV0dXJuIGRsZztcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIHNob3cgKGNvbXBvbmVudCwgb3B0aW9ucykge1xuXHQgICAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uICgkcmV0dXJuLCAkZXJyb3IpIHtcblx0ICAgICAgdmFyIGRsZywgb3ZlcmxheU5hbWUsIG92ZXJsYXk7XG5cdCAgICAgIGRsZyA9IHRoaXMuY3JlYXRlKGNvbXBvbmVudCk7XG5cdCAgICAgIG92ZXJsYXlOYW1lID0gZGxnLmhhc0FzeW5jUHJlbG9hZCA/IGNvbXBvbmVudC5vdmVybGF5IHx8ICdkZWZhdWx0JyA6IGZhbHNlO1xuXHQgICAgICBvdmVybGF5ID0gb3ZlcmxheU5hbWUgJiYgdGhpcy5fb3ZlcmxheXNbb3ZlcmxheU5hbWVdICYmIHRoaXMub3ZlcmxheShvdmVybGF5TmFtZSk7XG5cdCAgICAgIG92ZXJsYXkgJiYgb3ZlcmxheS5zaG93KCk7XG5cblx0ICAgICAgdmFyICRUcnlfMV9DYXRjaCA9IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuJGVtaXQoJ2Vycm9yJywge1xuXHQgICAgICAgICAgICBlcnJvcjogZSxcblx0ICAgICAgICAgICAgZGlhbG9nOiBkbGdcblx0ICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICBvdmVybGF5ICYmIG92ZXJsYXkuaGlkZSgpO1xuXHQgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICB9IGNhdGNoICgkYm91bmRFeCkge1xuXHQgICAgICAgICAgcmV0dXJuICRlcnJvcigkYm91bmRFeCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LmJpbmQodGhpcyk7XG5cblx0ICAgICAgdHJ5IHtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRsZy5zaG93KG9wdGlvbnMpKS50aGVuKGZ1bmN0aW9uICgkYXdhaXRfMikge1xuXHQgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdGhpcy5fZW1pdHRlci4kZW1pdCgnc2hvd24nLCB7XG5cdCAgICAgICAgICAgICAgZGlhbG9nOiBkbGdcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgb3ZlcmxheSAmJiBvdmVybGF5LmhpZGUoKTtcblx0ICAgICAgICAgICAgZGxnLm9uRGVzdHJveWVkID0gdGhpcy5vbkRpYWxvZ0Rlc3Ryb3llZC5iaW5kKHRoaXMpO1xuXHQgICAgICAgICAgICByZXR1cm4gJHJldHVybihvcHRpb25zLndhaXRGb3JSZXN1bHQgPyBkbGcud2FpdCgpIDogZGxnKTtcblx0ICAgICAgICAgIH0gY2F0Y2ggKCRib3VuZEV4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAkVHJ5XzFfQ2F0Y2goJGJvdW5kRXgpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSwgJFRyeV8xX0NhdGNoKTtcblx0ICAgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICAgICRUcnlfMV9DYXRjaChlKTtcblx0ICAgICAgfVxuXHQgICAgfS5iaW5kKHRoaXMpKTtcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlRnVuY3Rpb25XcmFwcGVyID0gZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25XcmFwcGVyIChuYW1lKSB7XG5cdCAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdCAgICB2YXIgY21wID0gdGhpcy5nZXRDb21wb25lbnQobmFtZSk7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHsgcmV0dXJuIHRoaXMkMS5zaG93KGNtcC5jb21wb25lbnQsIE9iamVjdC5hc3NpZ24oe30sIGNtcC5vcHRpb25zLCBvcHRpb25zKSk7IH07XG5cdCAgfTtcblxuXHQgIERpYWxvZ01hbmFnZXIucHJvdG90eXBlLnNob3dBbmRXYWl0ID0gZnVuY3Rpb24gc2hvd0FuZFdhaXQgKGNvbXBvbmVudCwgcHJvcHMpIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoJHJldHVybiwgJGVycm9yKSB7XG5cdCAgICAgIHZhciBkbGc7XG5cdCAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zaG93KGNvbXBvbmVudCwgcHJvcHMpKS50aGVuKGZ1bmN0aW9uICgkYXdhaXRfMykge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICBkbGcgPSAkYXdhaXRfMztcblx0ICAgICAgICAgIHJldHVybiAkcmV0dXJuKGRsZy53YWl0KCkpO1xuXHQgICAgICAgIH0gY2F0Y2ggKCRib3VuZEV4KSB7XG5cdCAgICAgICAgICByZXR1cm4gJGVycm9yKCRib3VuZEV4KTtcblx0ICAgICAgICB9XG5cdCAgICAgIH0sICRlcnJvcik7XG5cdCAgICB9LmJpbmQodGhpcykpO1xuXHQgIH07XG5cblx0ICBEaWFsb2dNYW5hZ2VyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uIChldmVudCwgY2FsbGJhY2spIHtcblx0ICAgIHRoaXMuX2VtaXR0ZXIuJG9uKGV2ZW50LCBjYWxsYmFjayk7XG5cdCAgfTtcblxuXHQgIERpYWxvZ01hbmFnZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZiAoZXZlbnQsIGNhbGxiYWNrKSB7XG5cdCAgICB0aGlzLl9lbWl0dGVyLiRvZmYoZXZlbnQsIGNhbGxiYWNrKTtcblx0ICB9O1xuXG5cdCAgRGlhbG9nTWFuYWdlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UgKGV2ZW50LCBjYWxsYmFjaykge1xuXHQgICAgdGhpcy5fZW1pdHRlci4kb25jZShldmVudCwgY2FsbGJhY2spO1xuXHQgIH07XG5cblx0ICBEaWFsb2dNYW5hZ2VyLnByb3RvdHlwZS5vbkRpYWxvZ0Rlc3Ryb3llZCA9IGZ1bmN0aW9uIG9uRGlhbG9nRGVzdHJveWVkIChkaWFsb2cpIHtcblx0ICAgIHRoaXMuX2VtaXR0ZXIuJGVtaXQoJ2Rlc3Ryb3llZCcsIHtcblx0ICAgICAgZGlhbG9nOiBkaWFsb2dcblx0ICAgIH0pO1xuXHQgIH07XG5cblx0ICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggRGlhbG9nTWFuYWdlci5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyQxICk7XG5cblx0ICAvL1xuXHQgIC8vXG5cdCAgLy9cblx0ICAvL1xuXHQgIC8vXG5cdCAgLy9cblx0ICAvL1xuXHQgIC8vXG5cdCAgLy9cblx0ICAvL1xuXHQgIHZhciBzY3JpcHQkMSA9IHtcblx0ICAgIHByb3BzOiB7XG5cdCAgICAgIHdpZHRoOiBOdW1iZXIsXG5cdCAgICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW5cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgICAgdmFyIF9fdnVlX3NjcmlwdF9fJDEgPSBzY3JpcHQkMTtcblx0ICAgICAgICAgICAgICBcblx0ICAvKiB0ZW1wbGF0ZSAqL1xuXHQgIHZhciBfX3Z1ZV9yZW5kZXJfXyQxID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgX3ZtID0gdGhpcztcblx0ICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaDtcblx0ICAgIHJldHVybiBfYyhcInRyYW5zaXRpb25cIiwgeyBhdHRyczogeyBuYW1lOiBcInZkaWFsb2ctbW9kYWxcIiB9IH0sIFtcblx0ICAgICAgX2MoXG5cdCAgICAgICAgXCJkaXZcIixcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBzdGF0aWNDbGFzczogXCJ2ZGlhbG9nLW1vZGFsLW1hc2tcIixcblx0ICAgICAgICAgIG9uOiB7XG5cdCAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcblx0ICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgICAgICAgICAgICByZXR1cm4gX3ZtLmRpc21pc3MoJGV2ZW50KVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBbXG5cdCAgICAgICAgICBfYyhcblx0ICAgICAgICAgICAgXCJkaXZcIixcblx0ICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInZkaWFsb2ctbW9kYWwtY29udGFpbmVyXCIsXG5cdCAgICAgICAgICAgICAgc3R5bGU6IHsgXCJtYXgtd2lkdGhcIjogKF92bS53aWR0aCB8fCA1MDApICsgXCJweFwiIH1cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgW1xuXHQgICAgICAgICAgICAgIF9jKFxuXHQgICAgICAgICAgICAgICAgXCJkaWFsb2ctY2hpbGRcIixcblx0ICAgICAgICAgICAgICAgIF92bS5fYih7fSwgXCJkaWFsb2ctY2hpbGRcIiwgX3ZtLiRvcHRpb25zLnByb3BzRGF0YSwgZmFsc2UpXG5cdCAgICAgICAgICAgICAgKVxuXHQgICAgICAgICAgICBdLFxuXHQgICAgICAgICAgICAxXG5cdCAgICAgICAgICApXG5cdCAgICAgICAgXVxuXHQgICAgICApXG5cdCAgICBdKVxuXHQgIH07XG5cdCAgdmFyIF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDEgPSBbXTtcblx0ICBfX3Z1ZV9yZW5kZXJfXyQxLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuXG5cdCAgICAvKiBzdHlsZSAqL1xuXHQgICAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyQxID0gZnVuY3Rpb24gKGluamVjdCkge1xuXHQgICAgICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuXHQgICAgICBpbmplY3QoXCJkYXRhLXYtNWMyMjRjMDRfMFwiLCB7IHNvdXJjZTogXCJcXG4udmRpYWxvZy1tb2RhbC1tYXNrIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBsZWZ0OiAwO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgdHJhbnNpdGlvbjogMC4ycyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgei1pbmRleDogNjtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIC41KTtcXG59XFxuLnZkaWFsb2ctbW9kYWwtY29udGFpbmVyIHtcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxuICBtYXgtaGVpZ2h0OiA5NSU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgYm94LXNoYWRvdzogMHB4IDExcHggMTVweCAtN3B4IHJnYmEoMCwwLDAsMC4yKSwgMHB4IDI0cHggMzhweCAzcHggcmdiYSgwLDAsMCwwLjE0KSwgMHB4IDlweCA0NnB4IDhweCByZ2JhKDAsMCwwLDAuMTIpO1xcbiAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgbWFyZ2luOiAxMnB4O1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbiAgdHJhbnNpdGlvbjogMC4zcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgei1pbmRleDogaW5oZXJpdDtcXG59XFxuXFxuLypcXG4qIFRoZSBmb2xsb3dpbmcgc3R5bGVzIGFyZSBhdXRvLWFwcGxpZWQgdG8gZWxlbWVudHMgd2l0aFxcbiogdHJhbnNpdGlvbj1cXFwibW9kYWxcXFwiIHdoZW4gdGhlaXIgdmlzaWJpbGl0eSBpcyB0b2dnbGVkXFxuKiBieSBWdWUuanMuXFxuKlxcbiogWW91IGNhbiBlYXNpbHkgcGxheSB3aXRoIHRoZSBtb2RhbCB0cmFuc2l0aW9uIGJ5IGVkaXRpbmdcXG4qIHRoZXNlIHN0eWxlcy5cXG4qL1xcbi52ZGlhbG9nLW1vZGFsLWVudGVyIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcbi52ZGlhbG9nLW1vZGFsLWxlYXZlLWFjdGl2ZSB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4udmRpYWxvZy1tb2RhbC1lbnRlciAubW9kYWwtY29udGFpbmVyLFxcbi52ZGlhbG9nLW1vZGFsLWxlYXZlLWFjdGl2ZSAubW9kYWwtY29udGFpbmVyIHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbn1cXG5cIiwgbWFwOiB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL3Z1ZWRsL3NyYy9jb21wb25lbnRzL0RpYWxvZ0xheW91dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXFCQTtFQUNBLG9CQUFBO0VBQ0EsY0FBQTtFQUNBLGFBQUE7RUFDQSx3QkFBQTtFQUNBLFFBQUE7RUFDQSxnQkFBQTtFQUNBLE9BQUE7RUFDQSxrREFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0VBQ0EsY0FBQTtFQUNBLG9DQUFBO0NBQ0E7QUFFQTtFQUNBLGlCQUFBO0VBQ0EsZ0JBQUE7RUFDQSx1QkFBQTtFQUNBLHNIQUFBO0VBQ0EsbUJBQUE7RUFDQSxhQUFBO0VBQ0EsaUJBQUE7RUFDQSxxQkFBQTtFQUNBLGtEQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0NBQ0E7O0FBRUE7Ozs7Ozs7RUFPQTtBQUVBO0VBQ0EsV0FBQTtDQUNBO0FBRUE7RUFDQSxXQUFBO0NBQ0E7QUFFQTs7RUFFQSw4QkFBQTtFQUNBLHNCQUFBO0NBQ0FcIixcImZpbGVcIjpcIkRpYWxvZ0xheW91dC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPHRyYW5zaXRpb24gbmFtZT1cXFwidmRpYWxvZy1tb2RhbFxcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcInZkaWFsb2ctbW9kYWwtbWFza1xcXCIgQGNsaWNrLnNlbGYucHJldmVudC5zdG9wPVxcXCJkaXNtaXNzXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInZkaWFsb2ctbW9kYWwtY29udGFpbmVyXFxcIiA6c3R5bGU9XFxcInsgJ21heC13aWR0aCc6ICh3aWR0aCB8fCA1MDApICsncHgnIH1cXFwiPlxcbiAgICAgICAgICA8ZGlhbG9nLWNoaWxkIHYtYmluZD1cXFwiJG9wdGlvbnMucHJvcHNEYXRhXFxcIi8+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L3RyYW5zaXRpb24+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIHByb3BzOiB7XFxuICAgIHdpZHRoOiBOdW1iZXIsXFxuICAgIHBlcnNpc3RlbnQ6IEJvb2xlYW5cXG4gIH1cXG59XFxuPC9zY3JpcHQ+XFxuXFxuPHN0eWxlPlxcbiAgLnZkaWFsb2ctbW9kYWwtbWFzayB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICB0cmFuc2l0aW9uOiAwLjJzIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogNjtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAuNSk7XFxuICB9XFxuXFxuICAudmRpYWxvZy1tb2RhbC1jb250YWluZXIge1xcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICBtYXgtaGVpZ2h0OiA5NSU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgIGJveC1zaGFkb3c6IDBweCAxMXB4IDE1cHggLTdweCByZ2JhKDAsMCwwLDAuMiksIDBweCAyNHB4IDM4cHggM3B4IHJnYmEoMCwwLDAsMC4xNCksIDBweCA5cHggNDZweCA4cHggcmdiYSgwLDAsMCwwLjEyKTtcXG4gICAgYm9yZGVyLXJhZGl1czogMnB4O1xcbiAgICBtYXJnaW46IDEycHg7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xcbiAgICB0cmFuc2l0aW9uOiAwLjNzIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogaW5oZXJpdDtcXG4gIH1cXG5cXG4gIC8qXFxuICAqIFRoZSBmb2xsb3dpbmcgc3R5bGVzIGFyZSBhdXRvLWFwcGxpZWQgdG8gZWxlbWVudHMgd2l0aFxcbiAgKiB0cmFuc2l0aW9uPVxcXCJtb2RhbFxcXCIgd2hlbiB0aGVpciB2aXNpYmlsaXR5IGlzIHRvZ2dsZWRcXG4gICogYnkgVnVlLmpzLlxcbiAgKlxcbiAgKiBZb3UgY2FuIGVhc2lseSBwbGF5IHdpdGggdGhlIG1vZGFsIHRyYW5zaXRpb24gYnkgZWRpdGluZ1xcbiAgKiB0aGVzZSBzdHlsZXMuXFxuICAqL1xcblxcbiAgLnZkaWFsb2ctbW9kYWwtZW50ZXIge1xcbiAgICBvcGFjaXR5OiAwO1xcbiAgfVxcblxcbiAgLnZkaWFsb2ctbW9kYWwtbGVhdmUtYWN0aXZlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gIH1cXG5cXG4gIC52ZGlhbG9nLW1vZGFsLWVudGVyIC5tb2RhbC1jb250YWluZXIsXFxuICAudmRpYWxvZy1tb2RhbC1sZWF2ZS1hY3RpdmUgLm1vZGFsLWNvbnRhaW5lciB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuPC9zdHlsZT5cXG5cIl19LCBtZWRpYTogdW5kZWZpbmVkIH0pO1xuXG5cdCAgICB9O1xuXHQgICAgLyogc2NvcGVkICovXG5cdCAgICB2YXIgX192dWVfc2NvcGVfaWRfXyQxID0gdW5kZWZpbmVkO1xuXHQgICAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cblx0ICAgIHZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDEgPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG5cdCAgICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDEgPSBmYWxzZTtcblx0ICAgIC8qIGNvbXBvbmVudCBub3JtYWxpemVyICovXG5cdCAgICBmdW5jdGlvbiBfX3Z1ZV9ub3JtYWxpemVfXyQxKFxuXHQgICAgICB0ZW1wbGF0ZSwgc3R5bGUsIHNjcmlwdCxcblx0ICAgICAgc2NvcGUsIGZ1bmN0aW9uYWwsIG1vZHVsZUlkZW50aWZpZXIsXG5cdCAgICAgIGNyZWF0ZUluamVjdG9yLCBjcmVhdGVJbmplY3RvclNTUlxuXHQgICAgKSB7XG5cdCAgICAgIHZhciBjb21wb25lbnQgPSAodHlwZW9mIHNjcmlwdCA9PT0gJ2Z1bmN0aW9uJyA/IHNjcmlwdC5vcHRpb25zIDogc2NyaXB0KSB8fCB7fTtcblxuXHQgICAgICAvLyBGb3Igc2VjdXJpdHkgY29uY2VybnMsIHdlIHVzZSBvbmx5IGJhc2UgbmFtZSBpbiBwcm9kdWN0aW9uIG1vZGUuXG5cdCAgICAgIGNvbXBvbmVudC5fX2ZpbGUgPSBcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvdnVlZGwvc3JjL2NvbXBvbmVudHMvRGlhbG9nTGF5b3V0LnZ1ZVwiO1xuXG5cdCAgICAgIGlmICghY29tcG9uZW50LnJlbmRlcikge1xuXHQgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgICAgY29tcG9uZW50LnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICAgICAgICBjb21wb25lbnQuX2NvbXBpbGVkID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgICB9XG5cblx0ICAgICAgY29tcG9uZW50Ll9zY29wZUlkID0gc2NvcGU7XG5cblx0ICAgICAge1xuXHQgICAgICAgIHZhciBob29rO1xuXHQgICAgICAgIGlmIChzdHlsZSkge1xuXHQgICAgICAgICAgaG9vayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3Rvcihjb250ZXh0KSk7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIGlmIChjb21wb25lbnQuZnVuY3Rpb25hbCkge1xuXHQgICAgICAgICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcblx0ICAgICAgICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gY29tcG9uZW50LnJlbmRlcjtcblx0ICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbihoLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpO1xuXHQgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcblx0ICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gY29tcG9uZW50LmJlZm9yZUNyZWF0ZTtcblx0ICAgICAgICAgICAgY29tcG9uZW50LmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKSA6IFtob29rXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gY29tcG9uZW50XG5cdCAgICB9XG5cdCAgICAvKiBzdHlsZSBpbmplY3QgKi9cblx0ICAgIGZ1bmN0aW9uIF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDEoKSB7XG5cdCAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHQgICAgICB2YXIgc3R5bGVzID0gX192dWVfY3JlYXRlX2luamVjdG9yX18kMS5zdHlsZXMgfHwgKF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDEuc3R5bGVzID0ge30pO1xuXHQgICAgICB2YXIgaXNPbGRJRSA9XG5cdCAgICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgICAvbXNpZSBbNi05XVxcXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFkZFN0eWxlKGlkLCBjc3MpIHtcblx0ICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBpZCArICdcIl0nKSkgeyByZXR1cm4gfSAvLyBTU1Igc3R5bGVzIGFyZSBwcmVzZW50LlxuXG5cdCAgICAgICAgdmFyIGdyb3VwID0gaXNPbGRJRSA/IGNzcy5tZWRpYSB8fCAnZGVmYXVsdCcgOiBpZDtcblx0ICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbZ3JvdXBdIHx8IChzdHlsZXNbZ3JvdXBdID0geyBpZHM6IFtdLCBwYXJ0czogW10sIGVsZW1lbnQ6IHVuZGVmaW5lZCB9KTtcblxuXHQgICAgICAgIGlmICghc3R5bGUuaWRzLmluY2x1ZGVzKGlkKSkge1xuXHQgICAgICAgICAgdmFyIGNvZGUgPSBjc3Muc291cmNlO1xuXHQgICAgICAgICAgdmFyIGluZGV4ID0gc3R5bGUuaWRzLmxlbmd0aDtcblxuXHQgICAgICAgICAgc3R5bGUuaWRzLnB1c2goaWQpO1xuXG5cdCAgICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgICBzdHlsZS5lbGVtZW50ID0gc3R5bGUuZWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWdyb3VwPScgKyBncm91cCArICddJyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICghc3R5bGUuZWxlbWVudCkge1xuXHQgICAgICAgICAgICB2YXIgZWwgPSBzdHlsZS5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0ICAgICAgICAgICAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cblx0ICAgICAgICAgICAgaWYgKGNzcy5tZWRpYSkgeyBlbC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgY3NzLm1lZGlhKTsgfVxuXHQgICAgICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcsIGdyb3VwKTtcblx0ICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsICcwJyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGVsKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChzdHlsZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JykpO1xuXHQgICAgICAgICAgICBzdHlsZS5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JywgaW5kZXggKyAxKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHN0eWxlLmVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHQgICAgICAgICAgICBzdHlsZS5wYXJ0cy5wdXNoKGNvZGUpO1xuXHQgICAgICAgICAgICBzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHN0eWxlLnBhcnRzXG5cdCAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuXHQgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUpO1xuXHQgICAgICAgICAgICB2YXIgbm9kZXMgPSBzdHlsZS5lbGVtZW50LmNoaWxkTm9kZXM7XG5cdCAgICAgICAgICAgIGlmIChub2Rlc1tpbmRleF0pIHsgc3R5bGUuZWxlbWVudC5yZW1vdmVDaGlsZChub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHsgc3R5bGUuZWxlbWVudC5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGVzW2luZGV4XSk7IH1cblx0ICAgICAgICAgICAgZWxzZSB7IHN0eWxlLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpOyB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKiBzdHlsZSBpbmplY3QgU1NSICovXG5cdCAgICBcblxuXHQgICAgXG5cdCAgICB2YXIgRGlhbG9nTGF5b3V0ID0gX192dWVfbm9ybWFsaXplX18kMShcblx0ICAgICAgeyByZW5kZXI6IF9fdnVlX3JlbmRlcl9fJDEsIHN0YXRpY1JlbmRlckZuczogX192dWVfc3RhdGljUmVuZGVyRm5zX18kMSB9LFxuXHQgICAgICBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kMSxcblx0ICAgICAgX192dWVfc2NyaXB0X18kMSxcblx0ICAgICAgX192dWVfc2NvcGVfaWRfXyQxLFxuXHQgICAgICBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kMSxcblx0ICAgICAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQxLFxuXHQgICAgICBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQxLFxuXHQgICAgICB1bmRlZmluZWRcblx0ICAgICk7XG5cblx0ICB2YXIgbm90aWZpY2F0aW9ucyA9IFtdO1xuXHQgIHZhciBnYXAgPSAxMDtcblxuXHQgIHZhciBpbnNlcnROb3RpZmljYXRpb24gPSBmdW5jdGlvbiAodm0pIHtcblx0ICAgIHZhciBwb3NpdGlvbiA9IHZtLnBvc2l0aW9uO1xuXHQgICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gZ2FwO1xuXHQgICAgbm90aWZpY2F0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ucG9zaXRpb24gPT09IHBvc2l0aW9uOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHZlcnRpY2FsT2Zmc2V0ICs9IGl0ZW0uJGVsLm9mZnNldEhlaWdodCArIGdhcDtcblx0ICAgIH0pO1xuXHQgICAgbm90aWZpY2F0aW9ucy5wdXNoKHZtKTtcblx0ICAgIHZtLnZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxPZmZzZXQ7XG5cdCAgfTtcblxuXHQgIHZhciBkZWxldGVOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAodm0pIHtcblx0ICAgIHZhciBpbmRleCA9IG5vdGlmaWNhdGlvbnMuZmluZEluZGV4KGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gaW5zdGFuY2UgPT09IHZtOyB9KTtcblxuXHQgICAgaWYgKGluZGV4IDwgMCkge1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIG5vdGlmaWNhdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcblx0ICAgIHZhciBsZW4gPSBub3RpZmljYXRpb25zLmxlbmd0aDtcblx0ICAgIHZhciBwb3NpdGlvbiA9IHZtLnBvc2l0aW9uO1xuXHQgICAgaWYgKCFsZW4pIHsgcmV0dXJuOyB9XG5cdCAgICB2YXIgdmVydGljYWxPZmZzZXQgPSBnYXA7XG5cdCAgICBub3RpZmljYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5wb3NpdGlvbiA9PT0gcG9zaXRpb247IH0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgICAgaXRlbS52ZXJ0aWNhbE9mZnNldCA9IHZlcnRpY2FsT2Zmc2V0O1xuXHQgICAgICB2ZXJ0aWNhbE9mZnNldCArPSBpdGVtLiRlbC5vZmZzZXRIZWlnaHQgKyBnYXA7XG5cdCAgICB9KTtcblx0ICB9O1xuXG5cdCAgdmFyIE5vdGlmaWFibGUgPSB7XG5cdCAgICBwcm9wczoge1xuXHQgICAgICB2ZXJ0aWNhbE9mZnNldDogTnVtYmVyLFxuXHQgICAgICBzaG93Q2xvc2U6IHtcblx0ICAgICAgICB0eXBlOiBCb29sZWFuLFxuXHQgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cblx0ICAgICAgfSxcblx0ICAgICAgcG9zaXRpb246IHtcblx0ICAgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ3RvcC1yaWdodCc7IH1cblx0ICAgICAgfSxcblx0ICAgICAgdGltZW91dDoge1xuXHQgICAgICAgIHR5cGU6IE51bWJlcixcblx0ICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA0NTAwOyB9XG5cdCAgICAgIH0sXG5cdCAgICAgIHdpZHRoOiB7XG5cdCAgICAgICAgdHlwZTogTnVtYmVyLFxuXHQgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMzMDsgfVxuXHQgICAgICB9LFxuXHQgICAgICB6SW5kZXg6IHtcblx0ICAgICAgICB0eXBlOiBOdW1iZXIsXG5cdCAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMjAwMDsgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgY29tcHV0ZWQ6IHtcblx0ICAgICAgaG9yaXpvbnRhbENsYXNzOiBmdW5jdGlvbiBob3Jpem9udGFsQ2xhc3MoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24uaW5kZXhPZigncmlnaHQnKSA+IC0xID8gJ3JpZ2h0JyA6ICdsZWZ0Jztcblx0ICAgICAgfSxcblxuXHQgICAgICB2ZXJ0aWNhbFByb3BlcnR5OiBmdW5jdGlvbiB2ZXJ0aWNhbFByb3BlcnR5KCkge1xuXHQgICAgICAgIHJldHVybiAvXnRvcC0vLnRlc3QodGhpcy5wb3NpdGlvbikgPyAndG9wJyA6ICdib3R0b20nO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIGdldFN0eWxlOiBmdW5jdGlvbiBnZXRTdHlsZSgpIHtcblx0ICAgICAgICB2YXIgb2JqO1xuXG5cdCAgICAgICAgcmV0dXJuICggb2JqID0ge30sIG9ialt0aGlzLnZlcnRpY2FsUHJvcGVydHldID0gKCh0aGlzLnZlcnRpY2FsT2Zmc2V0KSArIFwicHhcIiksIG9ialsnbWF4LXdpZHRoJ10gPSAgKCh0aGlzLndpZHRoKSArIFwicHhcIiksIG9ialsnei1pbmRleCddID0gIHRoaXMuekluZGV4LCBvYmopO1xuXHQgICAgICB9XG5cblx0ICAgIH0sXG5cdCAgICBtZXRob2RzOiB7XG5cdCAgICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHtcblx0ICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmQpO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIG9uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKCkge1xuXHQgICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZCk7XG5cdCAgICAgICAgdGhpcy4kZGVzdHJveSgpO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIGNsZWFyVGltZXI6IGZ1bmN0aW9uIGNsZWFyVGltZXIoKSB7XG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIHN0YXJ0VGltZXI6IGZ1bmN0aW9uIHN0YXJ0VGltZXIoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMudGltZW91dCA+IDApIHtcblx0ICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2xvc2UsIHRoaXMudGltZW91dCk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXG5cdCAgICAgIGtleWRvd246IGZ1bmN0aW9uIGtleWRvd24oZSkge1xuXHQgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDQ2IHx8IGUua2V5Q29kZSA9PT0gOCkge1xuXHQgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKCk7IC8vIGRldGVsZSBrZXlcblx0ICAgICAgICB9IGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0ICAgICAgICAgIC8vIGVzYyBrZXlcblx0ICAgICAgICAgIHRoaXMuY2xvc2UoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKCk7IC8vIGFueSBrZXlcblx0ICAgICAgICB9XG5cdCAgICAgIH0sXG5cblx0ICAgICAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuXHQgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcblx0ICAgICAgfVxuXG5cdCAgICB9LFxuXHQgICAgd2F0Y2g6IHtcblx0ICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKHZhbCkge1xuXHQgICAgICAgIGlmICh2YWwpIHtcblx0ICAgICAgICAgIGluc2VydE5vdGlmaWNhdGlvbih0aGlzKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgZGVsZXRlTm90aWZpY2F0aW9uKHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICB9LFxuXG5cdCAgICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuXHQgICAgICB0aGlzLnN0YXJ0VGltZXIoKTtcblx0ICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bik7XG5cdCAgICB9LFxuXG5cdCAgICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuXHQgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duKTtcblx0ICAgIH1cblxuXHQgIH07XG5cblx0ICAvL1xuXHQgIHZhciBzY3JpcHQkMiA9IHtcblx0ICAgIG1peGluczogW05vdGlmaWFibGVdLFxuXHQgICAgcHJvcHM6IHtcblx0ICAgICAgLy8gICBzaG93Q2xvc2U6IHtcblx0ICAgICAgLy8gICAgIHR5cGU6IEJvb2xlYW4sXG5cdCAgICAgIC8vICAgICBkZWZhdWx0OiAoKSA9PiB0cnVlXG5cdCAgICAgIC8vICAgfSxcblx0ICAgICAgd2lkdGg6IHtcblx0ICAgICAgICB0eXBlOiBOdW1iZXIsXG5cdCAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMzMwOyB9XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBjb21wdXRlZDoge1xuXHQgICAgICBnZXRTdHlsZTogZnVuY3Rpb24gZ2V0U3R5bGUoKSB7XG5cdCAgICAgICAgdmFyIG9iajtcblxuXHQgICAgICAgIHJldHVybiAoIG9iaiA9IHt9LCBvYmpbdGhpcy52ZXJ0aWNhbFByb3BlcnR5XSA9ICgodGhpcy52ZXJ0aWNhbE9mZnNldCkgKyBcInB4XCIpLCBvYmpbJ21heC13aWR0aCddID0gICgodGhpcy53aWR0aCkgKyBcInB4XCIpLCBvYmpbJ3otaW5kZXgnXSA9ICB0aGlzLnpJbmRleCwgb2JqKTtcblx0ICAgICAgfVxuXG5cdCAgICB9IC8vIG1ldGhvZHM6IHtcblx0ICAgIC8vICAgX2Rlc3Ryb3kgKCkge1xuXHQgICAgLy8gICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZClcblx0ICAgIC8vICAgfSxcblx0ICAgIC8vICAgb25UcmFuc2l0aW9uRW5kICgpIHtcblx0ICAgIC8vICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmQpXG5cdCAgICAvLyAgICAgdGhpcy4kZGVzdHJveSgpXG5cdCAgICAvLyAgIH1cblx0ICAgIC8vIH1cblxuXHQgIH07XG5cblx0ICAvKiBzY3JpcHQgKi9cblx0ICAgICAgICAgICAgICB2YXIgX192dWVfc2NyaXB0X18kMiA9IHNjcmlwdCQyO1xuXHQgICAgICAgICAgICAgIFxuXHQgIC8qIHRlbXBsYXRlICovXG5cdCAgdmFyIF9fdnVlX3JlbmRlcl9fJDIgPSBmdW5jdGlvbigpIHtcblx0ICAgIHZhciBfdm0gPSB0aGlzO1xuXHQgICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50O1xuXHQgICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oO1xuXHQgICAgcmV0dXJuIF9jKFwidHJhbnNpdGlvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwidnVlZGwtbm90aWZpY2F0aW9uLWZhZGVcIiB9IH0sIFtcblx0ICAgICAgX2MoXG5cdCAgICAgICAgXCJkaXZcIixcblx0ICAgICAgICB7XG5cdCAgICAgICAgICBkaXJlY3RpdmVzOiBbXG5cdCAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcblx0ICAgICAgICAgICAgICByYXdOYW1lOiBcInYtc2hvd1wiLFxuXHQgICAgICAgICAgICAgIHZhbHVlOiBfdm0uaXNBY3RpdmUsXG5cdCAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJpc0FjdGl2ZVwiXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIF0sXG5cdCAgICAgICAgICBjbGFzczogW1widnVlZGwtbm90aWZpY2F0aW9uXCIsIF92bS5ob3Jpem9udGFsQ2xhc3NdLFxuXHQgICAgICAgICAgc3R5bGU6IF92bS5nZXRTdHlsZSxcblx0ICAgICAgICAgIGF0dHJzOiB7IHJvbGU6IFwiYWxlcnRcIiB9LFxuXHQgICAgICAgICAgb246IHsgbW91c2VlbnRlcjogX3ZtLmNsZWFyVGltZXIsIG1vdXNlbGVhdmU6IF92bS5zdGFydFRpbWVyIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIFtcblx0ICAgICAgICAgIF92bS5fdChcImRlZmF1bHRcIiksXG5cdCAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuXHQgICAgICAgICAgX3ZtLnNob3dDbG9zZVxuXHQgICAgICAgICAgICA/IF9jKFxuXHQgICAgICAgICAgICAgICAgXCJkaXZcIixcblx0ICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidnVlZGwtbm90aWZpY2F0aW9uX19jbG9zZUJ0blwiLFxuXHQgICAgICAgICAgICAgICAgICBvbjoge1xuXHQgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdm0uY2xvc2UoJGV2ZW50KVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIFtfdm0uX3YoXCLDl1wiKV1cblx0ICAgICAgICAgICAgICApXG5cdCAgICAgICAgICAgIDogX3ZtLl9lKClcblx0ICAgICAgICBdLFxuXHQgICAgICAgIDJcblx0ICAgICAgKVxuXHQgICAgXSlcblx0ICB9O1xuXHQgIHZhciBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQyID0gW107XG5cdCAgX192dWVfcmVuZGVyX18kMi5fd2l0aFN0cmlwcGVkID0gdHJ1ZTtcblxuXHQgICAgLyogc3R5bGUgKi9cblx0ICAgIHZhciBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kMiA9IGZ1bmN0aW9uIChpbmplY3QpIHtcblx0ICAgICAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cblx0ICAgICAgaW5qZWN0KFwiZGF0YS12LWYwNzkyNjUyXzBcIiwgeyBzb3VyY2U6IFwiXFxuLnZ1ZWRsLW5vdGlmaWNhdGlvbiB7XFxuICAgZGlzcGxheTotd2Via2l0LWJveDtcXG4gICBkaXNwbGF5Oi1tcy1mbGV4Ym94O1xcbiAgIGRpc3BsYXk6ZmxleDtcXG4gICAtd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcXG4gICBib3gtc2l6aW5nOmJvcmRlci1ib3g7XFxuICAgcG9zaXRpb246Zml4ZWQ7XFxuICAgLXdlYmtpdC1ib3gtc2hhZG93OjAgMnB4IDEycHggMCByZ2JhKDAsMCwwLC4xKTtcXG4gICBib3gtc2hhZG93OjAgMnB4IDEycHggMCByZ2JhKDAsMCwwLC4xKTtcXG4gICAtd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuM3MsbGVmdCAuM3MscmlnaHQgLjNzLHRvcCAuNHMsYm90dG9tIC4zcywtd2Via2l0LXRyYW5zZm9ybSAuM3M7XFxuICAgdHJhbnNpdGlvbjpvcGFjaXR5IC4zcyxsZWZ0IC4zcyxyaWdodCAuM3MsdG9wIC40cyxib3R0b20gLjNzLC13ZWJraXQtdHJhbnNmb3JtIC4zcztcXG4gICB0cmFuc2l0aW9uOm9wYWNpdHkgLjNzLHRyYW5zZm9ybSAuM3MsbGVmdCAuM3MscmlnaHQgLjNzLHRvcCAuNHMsYm90dG9tIC4zcztcXG4gICB0cmFuc2l0aW9uOm9wYWNpdHkgLjNzLHRyYW5zZm9ybSAuM3MsbGVmdCAuM3MscmlnaHQgLjNzLHRvcCAuNHMsYm90dG9tIC4zcywtd2Via2l0LXRyYW5zZm9ybSAuM3M7XFxuICAgb3ZlcmZsb3c6aGlkZGVuXFxufVxcbi52dWVkbC1ub3RpZmljYXRpb24+ZGl2OmZpcnN0LWNoaWxkIHtcXG4gICB3aWR0aDogMTAwJVxcbn1cXG4udnVlZGwtbm90aWZpY2F0aW9uLnJpZ2h0IHtcXG4gICByaWdodDoxNnB4XFxufVxcbi52dWVkbC1ub3RpZmljYXRpb24ubGVmdCB7XFxuICAgbGVmdDoxNnB4XFxufVxcbi52dWVkbC1ub3RpZmljYXRpb25fX2Nsb3NlQnRuIHtcXG4gICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gICB0b3A6IDlweDtcXG4gICByaWdodDogMTVweDtcXG4gICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgY29sb3I6ICM5MDkzOTk7XFxuICAgZm9udC1zaXplOiAyMnB4O1xcbn1cXG4udnVlZGwtbm90aWZpY2F0aW9uX19jbG9zZUJ0bjpob3ZlciB7XFxuICAgY29sb3I6IzYwNjI2Nlxcbn1cXG4udnVlZGwtbm90aWZpY2F0aW9uLWZhZGUtZW50ZXIucmlnaHR7XFxuICAgcmlnaHQ6MDtcXG4gICAtd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpO1xcbiAgIHRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpXFxufVxcbi52dWVkbC1ub3RpZmljYXRpb24tZmFkZS1lbnRlci5sZWZ0e1xcbiAgIGxlZnQ6MDtcXG4gICAtd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTtcXG4gICB0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSlcXG59XFxuLnZ1ZWRsLW5vdGlmaWNhdGlvbi1mYWRlLWxlYXZlLWFjdGl2ZSB7XFxuICAgb3BhY2l0eTowXFxufVxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ1MHB4KSB7XFxuLnZ1ZWRsLW5vdGlmaWNhdGlvbiB7XFxuICAgICBsZWZ0OjhweCFpbXBvcnRhbnQ7XFxuICAgICByaWdodDo4cHghaW1wb3J0YW50O1xcbiAgICAgbWF4LXdpZHRoOiBpbmhlcml0IWltcG9ydGFudDtcXG59XFxufVxcblxcbi8qIC5lbC1ub3RpZmljYXRpb24tZmFkZS1lbnRlciB7XFxuICAgJi5yaWdodCB7XFxuICAgICByaWdodDogMDtcXG4gICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMDAlKTtcXG4gICB9XFxuXFxuICAgJi5sZWZ0IHtcXG4gICAgIGxlZnQ6IDA7XFxuICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwMCUpO1xcbiAgIH1cXG4gfVxcblxcbiAuZWwtbm90aWZpY2F0aW9uLWZhZGUtbGVhdmUtYWN0aXZlIHtcXG4gICBvcGFjaXR5OiAwO1xcbiB9Ki9cXG5cIiwgbWFwOiB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL3Z1ZWRsL3NyYy9jb21wb25lbnRzL05vdGlmaWNhdGlvbkxheW91dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXdEQTtHQUNBLG9CQUFBO0dBQ0Esb0JBQUE7R0FDQSxhQUFBO0dBQ0EsOEJBQUE7R0FDQSxzQkFBQTtHQUNBLGVBQUE7R0FDQSwrQ0FBQTtHQUNBLHVDQUFBO0dBQ0EsMkZBQUE7R0FDQSxtRkFBQTtHQUNBLDJFQUFBO0dBQ0EsaUdBQUE7R0FDQSxlQUFBO0NBQ0E7QUFDQTtHQUNBLFdBQUE7Q0FDQTtBQUNBO0dBQ0EsVUFBQTtDQUNBO0FBQ0E7R0FDQSxTQUFBO0NBQ0E7QUFDQTtHQUNBLGtCQUFBO0dBQ0EsU0FBQTtHQUNBLFlBQUE7R0FDQSxnQkFBQTtHQUNBLGVBQUE7R0FDQSxnQkFBQTtDQUNBO0FBQ0E7R0FDQSxhQUFBO0NBQ0E7QUFDQTtHQUNBLFFBQUE7R0FDQSxtQ0FBQTtHQUNBLDBCQUFBO0NBQ0E7QUFDQTtHQUNBLE9BQUE7R0FDQSxvQ0FBQTtHQUNBLDJCQUFBO0NBQ0E7QUFDQTtHQUNBLFNBQUE7Q0FDQTtBQUNBO0FBQ0E7S0FDQSxtQkFBQTtLQUNBLG9CQUFBO0tBQ0EsNkJBQUE7Q0FDQTtDQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7OztJQWNBXCIsXCJmaWxlXCI6XCJOb3RpZmljYXRpb25MYXlvdXQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDx0cmFuc2l0aW9uIG5hbWU9XFxcInZ1ZWRsLW5vdGlmaWNhdGlvbi1mYWRlXFxcIj5cXG4gICAgPGRpdlxcbiAgICAgIDpjbGFzcz1cXFwiWyd2dWVkbC1ub3RpZmljYXRpb24nLCBob3Jpem9udGFsQ2xhc3NdXFxcIlxcbiAgICAgIHYtc2hvdz1cXFwiaXNBY3RpdmVcXFwiXFxuICAgICAgOnN0eWxlPVxcXCJnZXRTdHlsZVxcXCJcXG4gICAgICBAbW91c2VlbnRlcj1cXFwiY2xlYXJUaW1lclxcXCJcXG4gICAgICBAbW91c2VsZWF2ZT1cXFwic3RhcnRUaW1lclxcXCJcXG4gICAgICByb2xlPVxcXCJhbGVydFxcXCJcXG4gICAgPlxcbiAgICAgIDxzbG90Lz5cXG4gICAgICA8ZGl2XFxuICAgICAgICBjbGFzcz1cXFwidnVlZGwtbm90aWZpY2F0aW9uX19jbG9zZUJ0blxcXCJcXG4gICAgICAgIHYtaWY9XFxcInNob3dDbG9zZVxcXCJcXG4gICAgICAgIEBjbGljay5zdG9wPVxcXCJjbG9zZVxcXCI+w5c8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L3RyYW5zaXRpb24+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcblxcbmltcG9ydCBOb3RpZmlhYmxlIGZyb20gJy4uL21peGlucy9ub3RpZmlhYmxlJ1xcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIG1peGluczogWyBOb3RpZmlhYmxlIF0sXFxuICBwcm9wczoge1xcbiAgLy8gICBzaG93Q2xvc2U6IHtcXG4gIC8vICAgICB0eXBlOiBCb29sZWFuLFxcbiAgLy8gICAgIGRlZmF1bHQ6ICgpID0+IHRydWVcXG4gIC8vICAgfSxcXG4gICAgd2lkdGg6IHtcXG4gICAgICB0eXBlOiBOdW1iZXIsXFxuICAgICAgZGVmYXVsdDogKCkgPT4gMzMwXFxuICAgIH1cXG4gIH0sXFxuICBjb21wdXRlZDoge1xcbiAgICBnZXRTdHlsZSAoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIFt0aGlzLnZlcnRpY2FsUHJvcGVydHldOiBgJHt0aGlzLnZlcnRpY2FsT2Zmc2V0fXB4YCxcXG4gICAgICAgICdtYXgtd2lkdGgnOiBgJHt0aGlzLndpZHRofXB4YCxcXG4gICAgICAgICd6LWluZGV4JzogdGhpcy56SW5kZXhcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG4gIC8vIG1ldGhvZHM6IHtcXG4gIC8vICAgX2Rlc3Ryb3kgKCkge1xcbiAgLy8gICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZClcXG4gIC8vICAgfSxcXG4gIC8vICAgb25UcmFuc2l0aW9uRW5kICgpIHtcXG4gIC8vICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5vblRyYW5zaXRpb25FbmQpXFxuICAvLyAgICAgdGhpcy4kZGVzdHJveSgpXFxuICAvLyAgIH1cXG4gIC8vIH1cXG59XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbiAgLnZ1ZWRsLW5vdGlmaWNhdGlvbiB7XFxuICAgIGRpc3BsYXk6LXdlYmtpdC1ib3g7XFxuICAgIGRpc3BsYXk6LW1zLWZsZXhib3g7XFxuICAgIGRpc3BsYXk6ZmxleDtcXG4gICAgLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7XFxuICAgIGJveC1zaXppbmc6Ym9yZGVyLWJveDtcXG4gICAgcG9zaXRpb246Zml4ZWQ7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzowIDJweCAxMnB4IDAgcmdiYSgwLDAsMCwuMSk7XFxuICAgIGJveC1zaGFkb3c6MCAycHggMTJweCAwIHJnYmEoMCwwLDAsLjEpO1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246b3BhY2l0eSAuM3MsbGVmdCAuM3MscmlnaHQgLjNzLHRvcCAuNHMsYm90dG9tIC4zcywtd2Via2l0LXRyYW5zZm9ybSAuM3M7XFxuICAgIHRyYW5zaXRpb246b3BhY2l0eSAuM3MsbGVmdCAuM3MscmlnaHQgLjNzLHRvcCAuNHMsYm90dG9tIC4zcywtd2Via2l0LXRyYW5zZm9ybSAuM3M7XFxuICAgIHRyYW5zaXRpb246b3BhY2l0eSAuM3MsdHJhbnNmb3JtIC4zcyxsZWZ0IC4zcyxyaWdodCAuM3MsdG9wIC40cyxib3R0b20gLjNzO1xcbiAgICB0cmFuc2l0aW9uOm9wYWNpdHkgLjNzLHRyYW5zZm9ybSAuM3MsbGVmdCAuM3MscmlnaHQgLjNzLHRvcCAuNHMsYm90dG9tIC4zcywtd2Via2l0LXRyYW5zZm9ybSAuM3M7XFxuICAgIG92ZXJmbG93OmhpZGRlblxcbiAgfVxcbiAgLnZ1ZWRsLW5vdGlmaWNhdGlvbj5kaXY6Zmlyc3QtY2hpbGQge1xcbiAgICB3aWR0aDogMTAwJVxcbiAgfVxcbiAgLnZ1ZWRsLW5vdGlmaWNhdGlvbi5yaWdodCB7XFxuICAgIHJpZ2h0OjE2cHhcXG4gIH1cXG4gIC52dWVkbC1ub3RpZmljYXRpb24ubGVmdCB7XFxuICAgIGxlZnQ6MTZweFxcbiAgfVxcbiAgLnZ1ZWRsLW5vdGlmaWNhdGlvbl9fY2xvc2VCdG4ge1xcbiAgICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gICAgdG9wOiA5cHg7XFxuICAgIHJpZ2h0OiAxNXB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGNvbG9yOiAjOTA5Mzk5O1xcbiAgICBmb250LXNpemU6IDIycHg7XFxuICB9XFxuICAudnVlZGwtbm90aWZpY2F0aW9uX19jbG9zZUJ0bjpob3ZlciB7XFxuICAgIGNvbG9yOiM2MDYyNjZcXG4gIH1cXG4gIC52dWVkbC1ub3RpZmljYXRpb24tZmFkZS1lbnRlci5yaWdodHtcXG4gICAgcmlnaHQ6MDtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKTtcXG4gICAgdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTAwJSlcXG4gIH1cXG4gIC52dWVkbC1ub3RpZmljYXRpb24tZmFkZS1lbnRlci5sZWZ0e1xcbiAgICBsZWZ0OjA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwMCUpO1xcbiAgICB0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSlcXG4gIH1cXG4gIC52dWVkbC1ub3RpZmljYXRpb24tZmFkZS1sZWF2ZS1hY3RpdmUge1xcbiAgICBvcGFjaXR5OjBcXG4gIH1cXG4gIEBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQ1MHB4KSB7XFxuICAgIC52dWVkbC1ub3RpZmljYXRpb24ge1xcbiAgICAgIGxlZnQ6OHB4IWltcG9ydGFudDtcXG4gICAgICByaWdodDo4cHghaW1wb3J0YW50O1xcbiAgICAgIG1heC13aWR0aDogaW5oZXJpdCFpbXBvcnRhbnQ7XFxuICAgIH1cXG4gIH1cXG5cXG4gLyogLmVsLW5vdGlmaWNhdGlvbi1mYWRlLWVudGVyIHtcXG4gICAgJi5yaWdodCB7XFxuICAgICAgcmlnaHQ6IDA7XFxuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwMCUpO1xcbiAgICB9XFxuXFxuICAgICYubGVmdCB7XFxuICAgICAgbGVmdDogMDtcXG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwMCUpO1xcbiAgICB9XFxuICB9XFxuXFxuICAuZWwtbm90aWZpY2F0aW9uLWZhZGUtbGVhdmUtYWN0aXZlIHtcXG4gICAgb3BhY2l0eTogMDtcXG4gIH0qL1xcbjwvc3R5bGU+XFxuXCJdfSwgbWVkaWE6IHVuZGVmaW5lZCB9KTtcblxuXHQgICAgfTtcblx0ICAgIC8qIHNjb3BlZCAqL1xuXHQgICAgdmFyIF9fdnVlX3Njb3BlX2lkX18kMiA9IHVuZGVmaW5lZDtcblx0ICAgIC8qIG1vZHVsZSBpZGVudGlmaWVyICovXG5cdCAgICB2YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQyID0gdW5kZWZpbmVkO1xuXHQgICAgLyogZnVuY3Rpb25hbCB0ZW1wbGF0ZSAqL1xuXHQgICAgdmFyIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQyID0gZmFsc2U7XG5cdCAgICAvKiBjb21wb25lbnQgbm9ybWFsaXplciAqL1xuXHQgICAgZnVuY3Rpb24gX192dWVfbm9ybWFsaXplX18kMihcblx0ICAgICAgdGVtcGxhdGUsIHN0eWxlLCBzY3JpcHQsXG5cdCAgICAgIHNjb3BlLCBmdW5jdGlvbmFsLCBtb2R1bGVJZGVudGlmaWVyLFxuXHQgICAgICBjcmVhdGVJbmplY3RvciwgY3JlYXRlSW5qZWN0b3JTU1Jcblx0ICAgICkge1xuXHQgICAgICB2YXIgY29tcG9uZW50ID0gKHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicgPyBzY3JpcHQub3B0aW9ucyA6IHNjcmlwdCkgfHwge307XG5cblx0ICAgICAgLy8gRm9yIHNlY3VyaXR5IGNvbmNlcm5zLCB3ZSB1c2Ugb25seSBiYXNlIG5hbWUgaW4gcHJvZHVjdGlvbiBtb2RlLlxuXHQgICAgICBjb21wb25lbnQuX19maWxlID0gXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL3Z1ZWRsL3NyYy9jb21wb25lbnRzL05vdGlmaWNhdGlvbkxheW91dC52dWVcIjtcblxuXHQgICAgICBpZiAoIWNvbXBvbmVudC5yZW5kZXIpIHtcblx0ICAgICAgICBjb21wb25lbnQucmVuZGVyID0gdGVtcGxhdGUucmVuZGVyO1xuXHQgICAgICAgIGNvbXBvbmVudC5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG5cdCAgICAgICAgY29tcG9uZW50Ll9jb21waWxlZCA9IHRydWU7XG5cblx0ICAgICAgICBpZiAoZnVuY3Rpb25hbCkgeyBjb21wb25lbnQuZnVuY3Rpb25hbCA9IHRydWU7IH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbXBvbmVudC5fc2NvcGVJZCA9IHNjb3BlO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgaG9vaztcblx0ICAgICAgICBpZiAoc3R5bGUpIHtcblx0ICAgICAgICAgIGhvb2sgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHN0eWxlLmNhbGwodGhpcywgY3JlYXRlSW5qZWN0b3IoY29udGV4dCkpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBpZiAoY29tcG9uZW50LmZ1bmN0aW9uYWwpIHtcblx0ICAgICAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG5cdCAgICAgICAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IGNvbXBvbmVudC5yZW5kZXI7XG5cdCAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuXHQgICAgICAgICAgICAgIGhvb2suY2FsbChjb250ZXh0KTtcblx0ICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG5cdCAgICAgICAgICAgIHZhciBleGlzdGluZyA9IGNvbXBvbmVudC5iZWZvcmVDcmVhdGU7XG5cdCAgICAgICAgICAgIGNvbXBvbmVudC5iZWZvcmVDcmVhdGUgPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaykgOiBbaG9va107XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGNvbXBvbmVudFxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgICBmdW5jdGlvbiBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQyKCkge1xuXHQgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0ICAgICAgdmFyIHN0eWxlcyA9IF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDIuc3R5bGVzIHx8IChfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQyLnN0eWxlcyA9IHt9KTtcblx0ICAgICAgdmFyIGlzT2xkSUUgPVxuXHQgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgICAgL21zaWUgWzYtOV1cXFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBhZGRTdHlsZShpZCwgY3NzKSB7XG5cdCAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgaWQgKyAnXCJdJykpIHsgcmV0dXJuIH0gLy8gU1NSIHN0eWxlcyBhcmUgcHJlc2VudC5cblxuXHQgICAgICAgIHZhciBncm91cCA9IGlzT2xkSUUgPyBjc3MubWVkaWEgfHwgJ2RlZmF1bHQnIDogaWQ7XG5cdCAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2dyb3VwXSB8fCAoc3R5bGVzW2dyb3VwXSA9IHsgaWRzOiBbXSwgcGFydHM6IFtdLCBlbGVtZW50OiB1bmRlZmluZWQgfSk7XG5cblx0ICAgICAgICBpZiAoIXN0eWxlLmlkcy5pbmNsdWRlcyhpZCkpIHtcblx0ICAgICAgICAgIHZhciBjb2RlID0gY3NzLnNvdXJjZTtcblx0ICAgICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmlkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgIHN0eWxlLmlkcy5wdXNoKGlkKTtcblxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudCA9IHN0eWxlLmVsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1ncm91cD0nICsgZ3JvdXAgKyAnXScpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoIXN0eWxlLmVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGVsID0gc3R5bGUuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICAgICAgICAgIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuXG5cdCAgICAgICAgICAgIGlmIChjc3MubWVkaWEpIHsgZWwuc2V0QXR0cmlidXRlKCdtZWRpYScsIGNzcy5tZWRpYSk7IH1cblx0ICAgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnLCBncm91cCk7XG5cdCAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnLCAnMCcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoc3R5bGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcpKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsIGluZGV4ICsgMSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0ICAgICAgICAgICAgc3R5bGUucGFydHMucHVzaChjb2RlKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZS5wYXJ0c1xuXHQgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcblx0ICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb2RlKTtcblx0ICAgICAgICAgICAgdmFyIG5vZGVzID0gc3R5bGUuZWxlbWVudC5jaGlsZE5vZGVzO1xuXHQgICAgICAgICAgICBpZiAobm9kZXNbaW5kZXhdKSB7IHN0eWxlLmVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZXNbaW5kZXhdKTsgfVxuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7IHN0eWxlLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICAgIGVsc2UgeyBzdHlsZS5lbGVtZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTsgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgICAgXG5cblx0ICAgIFxuXHQgICAgdmFyIE5vdGlmaWNhdGlvbkxheW91dCA9IF9fdnVlX25vcm1hbGl6ZV9fJDIoXG5cdCAgICAgIHsgcmVuZGVyOiBfX3Z1ZV9yZW5kZXJfXyQyLCBzdGF0aWNSZW5kZXJGbnM6IF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDIgfSxcblx0ICAgICAgX192dWVfaW5qZWN0X3N0eWxlc19fJDIsXG5cdCAgICAgIF9fdnVlX3NjcmlwdF9fJDIsXG5cdCAgICAgIF9fdnVlX3Njb3BlX2lkX18kMixcblx0ICAgICAgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDIsXG5cdCAgICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kMixcblx0ICAgICAgX192dWVfY3JlYXRlX2luamVjdG9yX18kMixcblx0ICAgICAgdW5kZWZpbmVkXG5cdCAgICApO1xuXG5cdCAgLy9cblx0ICAvL1xuXHQgIC8vXG5cdCAgLy9cblx0ICAvL1xuXHQgIHZhciBzY3JpcHQkMyA9IHtcblx0ICAgIG5hbWU6ICdWRGlhbG9nT3ZlcmxheScsXG5cdCAgICBwcm9wczoge1xuXHQgICAgICB6SW5kZXg6IHtcblx0ICAgICAgICB0eXBlOiBOdW1iZXIsXG5cdCAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTI1MDsgfVxuXHQgICAgICB9LFxuXHQgICAgICB2aXNpYmxlOiB7XG5cdCAgICAgICAgdHlwZTogQm9vbGVhbixcblx0ICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIC8qIHNjcmlwdCAqL1xuXHQgICAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQzID0gc2NyaXB0JDM7XG5cdCAgICAgICAgICAgICAgXG5cdCAgLyogdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfcmVuZGVyX18kMyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIF92bSA9IHRoaXM7XG5cdCAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnQ7XG5cdCAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgICByZXR1cm4gX2MoXCJ0cmFuc2l0aW9uXCIsIHsgYXR0cnM6IHsgbmFtZTogXCJvcGFjaXR5XCIgfSB9LCBbXG5cdCAgICAgIF92bS52aXNpYmxlXG5cdCAgICAgICAgPyBfYyhcblx0ICAgICAgICAgICAgXCJkaXZcIixcblx0ICAgICAgICAgICAge1xuXHQgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImRpYWxvZy1vdmVybGF5LWxvYWRpbmdcIixcblx0ICAgICAgICAgICAgICBzdHlsZTogeyB6SW5kZXg6IF92bS56SW5kZXggfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBbX3ZtLl92KFwiTG9hZGluZ+KAplwiKV1cblx0ICAgICAgICAgIClcblx0ICAgICAgICA6IF92bS5fZSgpXG5cdCAgICBdKVxuXHQgIH07XG5cdCAgdmFyIF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDMgPSBbXTtcblx0ICBfX3Z1ZV9yZW5kZXJfXyQzLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuXG5cdCAgICAvKiBzdHlsZSAqL1xuXHQgICAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyQzID0gZnVuY3Rpb24gKGluamVjdCkge1xuXHQgICAgICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuXHQgICAgICBpbmplY3QoXCJkYXRhLXYtMDVkMzUzZTJfMFwiLCB7IHNvdXJjZTogXCJcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vKiBBYnNvbHV0ZSBDZW50ZXIgU3Bpbm5lciAqL1xcbi5kaWFsb2ctb3ZlcmxheS1sb2FkaW5nIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIGhlaWdodDogMmVtO1xcbiAgd2lkdGg6IDJlbTtcXG4gIG92ZXJmbG93OiBzaG93O1xcbiAgbWFyZ2luOiBhdXRvO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIHJpZ2h0OiAwO1xcbiAgLyogYmFja2dyb3VuZDogcmdiYSgxMTIsIDExMiwgMTEyLCAwLjQpOyAqL1xcbiAgY3Vyc29yOiB3YWl0O1xcbn1cXG5cXG4vKiBUcmFuc3BhcmVudCBPdmVybGF5ICovXFxuLmRpYWxvZy1vdmVybGF5LWxvYWRpbmc6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQocmdiYSgxMTIsIDExMiwgMTEyLCAwLjQpLCByZ2JhKDUwLCA1MCwgNTAsIC44KSk7XFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LXJhZGlhbC1ncmFkaWVudChyZ2JhKDExMiwgMTEyLCAxMTIsIDAuNCksIHJnYmEoNTAsIDUwLCA1MCwgLjgpKTtcXG59XFxuXFxuLyogOm5vdCg6cmVxdWlyZWQpIGhpZGVzIHRoZXNlIHJ1bGVzIGZyb20gSUU5IGFuZCBiZWxvdyAqL1xcbi5kaWFsb2ctb3ZlcmxheS1sb2FkaW5nOm5vdCg6cmVxdWlyZWQpIHtcXG4gIC8qIGhpZGUgXFxcImxvYWRpbmcuLi5cXFwiIHRleHQgKi9cXG4gIGZvbnQ6IDAvMCBhO1xcbiAgY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgdGV4dC1zaGFkb3c6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlcjogMDtcXG59XFxuLmRpYWxvZy1vdmVybGF5LWxvYWRpbmc6bm90KDpyZXF1aXJlZCk6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIHdpZHRoOiAxZW07XFxuICBoZWlnaHQ6IDFlbTtcXG4gIG1hcmdpbi10b3A6IC0wLjVlbTtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBzcGlubmVyIDE1MDBtcyBpbmZpbml0ZSBsaW5lYXI7XFxuICAtbW96LWFuaW1hdGlvbjogc3Bpbm5lciAxNTAwbXMgaW5maW5pdGUgbGluZWFyO1xcbiAgLW1zLWFuaW1hdGlvbjogc3Bpbm5lciAxNTAwbXMgaW5maW5pdGUgbGluZWFyO1xcbiAgLW8tYW5pbWF0aW9uOiBzcGlubmVyIDE1MDBtcyBpbmZpbml0ZSBsaW5lYXI7XFxuICBhbmltYXRpb246IHNwaW5uZXIgMTUwMG1zIGluZmluaXRlIGxpbmVhcjtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNWVtO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAxLjVlbSAwIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMS4xZW0gMS4xZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAwIDEuNWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgLTEuMWVtIDEuMWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgLTEuNWVtIDAgMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAtMS4xZW0gLTEuMWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMCAtMS41ZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAxLjFlbSAtMS4xZW0gMCAwO1xcbmJveC1zaGFkb3c6IHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIDEuNWVtIDAgMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAxLjFlbSAxLjFlbSAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIDAgMS41ZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAtMS4xZW0gMS4xZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAtMS41ZW0gMCAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIC0xLjFlbSAtMS4xZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAwIC0xLjVlbSAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIDEuMWVtIC0xLjFlbSAwIDA7XFxufVxcblxcbi8qIEFuaW1hdGlvbiAqL1xcbkAtd2Via2l0LWtleWZyYW1lcyBzcGlubmVyIHtcXG4wJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW8tdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbn1cXG4xMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbW96LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbn1cXG59XFxuQC1tb3ota2V5ZnJhbWVzIHNwaW5uZXIge1xcbjAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1vLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxufVxcbn1cXG5ALW8ta2V5ZnJhbWVzIHNwaW5uZXIge1xcbjAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1vLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxufVxcbn1cXG5Aa2V5ZnJhbWVzIHNwaW5uZXIge1xcbjAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1vLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxufVxcbn1cXG5cIiwgbWFwOiB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL3Z1ZWRsL3NyYy9jb21wb25lbnRzL0RpYWxvZ092ZXJsYXkudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQSw2QkFBQTtBQUNBO0VBQ0EsZ0JBQUE7RUFDQSxhQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSxlQUFBO0VBQ0EsYUFBQTtFQUNBLE9BQUE7RUFDQSxRQUFBO0VBQ0EsVUFBQTtFQUNBLFNBQUE7RUFDQSwyQ0FBQTtFQUNBLGFBQUE7Q0FDQTs7QUFFQSx5QkFBQTtBQUNBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLE9BQUE7RUFDQSxRQUFBO0VBQ0EsWUFBQTtFQUNBLGFBQUE7RUFDQSw0RUFBQTtFQUNBLG9GQUFBO0NBQ0E7O0FBRUEsMERBQUE7QUFDQTtFQUNBLDRCQUFBO0VBQ0EsWUFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSw4QkFBQTtFQUNBLFVBQUE7Q0FDQTtBQUVBO0VBQ0EsWUFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsbUJBQUE7RUFDQSxrREFBQTtFQUNBLCtDQUFBO0VBQ0EsOENBQUE7RUFDQSw2Q0FBQTtFQUNBLDBDQUFBO0VBQ0EscUJBQUE7RUFDQSxpVkFBQTtBQUNBLHlVQUFBO0NBQ0E7O0FBRUEsZUFBQTtBQUVBO0FBQ0E7SUFDQSxnQ0FBQTtJQUNBLDZCQUFBO0lBQ0EsNEJBQUE7SUFDQSwyQkFBQTtJQUNBLHdCQUFBO0NBQ0E7QUFDQTtJQUNBLGtDQUFBO0lBQ0EsK0JBQUE7SUFDQSw4QkFBQTtJQUNBLDZCQUFBO0lBQ0EsMEJBQUE7Q0FDQTtDQUNBO0FBQ0E7QUFDQTtJQUNBLGdDQUFBO0lBQ0EsNkJBQUE7SUFDQSw0QkFBQTtJQUNBLDJCQUFBO0lBQ0Esd0JBQUE7Q0FDQTtBQUNBO0lBQ0Esa0NBQUE7SUFDQSwrQkFBQTtJQUNBLDhCQUFBO0lBQ0EsNkJBQUE7SUFDQSwwQkFBQTtDQUNBO0NBQ0E7QUFDQTtBQUNBO0lBQ0EsZ0NBQUE7SUFDQSw2QkFBQTtJQUNBLDRCQUFBO0lBQ0EsMkJBQUE7SUFDQSx3QkFBQTtDQUNBO0FBQ0E7SUFDQSxrQ0FBQTtJQUNBLCtCQUFBO0lBQ0EsOEJBQUE7SUFDQSw2QkFBQTtJQUNBLDBCQUFBO0NBQ0E7Q0FDQTtBQUNBO0FBQ0E7SUFDQSxnQ0FBQTtJQUNBLDZCQUFBO0lBQ0EsNEJBQUE7SUFDQSwyQkFBQTtJQUNBLHdCQUFBO0NBQ0E7QUFDQTtJQUNBLGtDQUFBO0lBQ0EsK0JBQUE7SUFDQSw4QkFBQTtJQUNBLDZCQUFBO0lBQ0EsMEJBQUE7Q0FDQTtDQUNBXCIsXCJmaWxlXCI6XCJEaWFsb2dPdmVybGF5LnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8dHJhbnNpdGlvbiBuYW1lPVxcXCJvcGFjaXR5XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZGlhbG9nLW92ZXJsYXktbG9hZGluZ1xcXCIgOnN0eWxlPVxcXCJ7ekluZGV4OiB6SW5kZXh9XFxcIiB2LWlmPVxcXCJ2aXNpYmxlXFxcIj5Mb2FkaW5nJiM4MjMwOzwvZGl2PlxcbiAgPC90cmFuc2l0aW9uPlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBuYW1lOiAnVkRpYWxvZ092ZXJsYXknLFxcbiAgcHJvcHM6IHtcXG4gICAgekluZGV4OiB7XFxuICAgICAgdHlwZTogTnVtYmVyLFxcbiAgICAgIGRlZmF1bHQ6ICgpID0+IDEyNTBcXG4gICAgfSxcXG4gICAgdmlzaWJsZToge1xcbiAgICAgIHR5cGU6IEJvb2xlYW4sXFxuICAgICAgZGVmYXVsdDogKCkgPT4gZmFsc2VcXG4gICAgfVxcbiAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuLyogQWJzb2x1dGUgQ2VudGVyIFNwaW5uZXIgKi9cXG4uZGlhbG9nLW92ZXJsYXktbG9hZGluZyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB6LWluZGV4OiA5OTk7XFxuICBoZWlnaHQ6IDJlbTtcXG4gIHdpZHRoOiAyZW07XFxuICBvdmVyZmxvdzogc2hvdztcXG4gIG1hcmdpbjogYXV0bztcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBib3R0b206IDA7XFxuICByaWdodDogMDtcXG4gIC8qIGJhY2tncm91bmQ6IHJnYmEoMTEyLCAxMTIsIDExMiwgMC40KTsgKi9cXG4gIGN1cnNvcjogd2FpdDtcXG59XFxuXFxuLyogVHJhbnNwYXJlbnQgT3ZlcmxheSAqL1xcbi5kaWFsb2ctb3ZlcmxheS1sb2FkaW5nOmJlZm9yZSB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbiAgbGVmdDogMDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KHJnYmEoMTEyLCAxMTIsIDExMiwgMC40KSwgcmdiYSg1MCwgNTAsIDUwLCAuOCkpO1xcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1yYWRpYWwtZ3JhZGllbnQocmdiYSgxMTIsIDExMiwgMTEyLCAwLjQpLCByZ2JhKDUwLCA1MCwgNTAsIC44KSk7XFxufVxcblxcbi8qIDpub3QoOnJlcXVpcmVkKSBoaWRlcyB0aGVzZSBydWxlcyBmcm9tIElFOSBhbmQgYmVsb3cgKi9cXG4uZGlhbG9nLW92ZXJsYXktbG9hZGluZzpub3QoOnJlcXVpcmVkKSB7XFxuICAvKiBoaWRlIFxcXCJsb2FkaW5nLi4uXFxcIiB0ZXh0ICovXFxuICBmb250OiAwLzAgYTtcXG4gIGNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIHRleHQtc2hhZG93OiBub25lO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICBib3JkZXI6IDA7XFxufVxcblxcbi5kaWFsb2ctb3ZlcmxheS1sb2FkaW5nOm5vdCg6cmVxdWlyZWQpOmFmdGVyIHtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmb250LXNpemU6IDEwcHg7XFxuICB3aWR0aDogMWVtO1xcbiAgaGVpZ2h0OiAxZW07XFxuICBtYXJnaW4tdG9wOiAtMC41ZW07XFxuICAtd2Via2l0LWFuaW1hdGlvbjogc3Bpbm5lciAxNTAwbXMgaW5maW5pdGUgbGluZWFyO1xcbiAgLW1vei1hbmltYXRpb246IHNwaW5uZXIgMTUwMG1zIGluZmluaXRlIGxpbmVhcjtcXG4gIC1tcy1hbmltYXRpb246IHNwaW5uZXIgMTUwMG1zIGluZmluaXRlIGxpbmVhcjtcXG4gIC1vLWFuaW1hdGlvbjogc3Bpbm5lciAxNTAwbXMgaW5maW5pdGUgbGluZWFyO1xcbiAgYW5pbWF0aW9uOiBzcGlubmVyIDE1MDBtcyBpbmZpbml0ZSBsaW5lYXI7XFxuICBib3JkZXItcmFkaXVzOiAwLjVlbTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMS41ZW0gMCAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIDEuMWVtIDEuMWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMCAxLjVlbSAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIC0xLjFlbSAxLjFlbSAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIC0xLjVlbSAwIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgLTEuMWVtIC0xLjFlbSAwIDAsIHJnYmEoMjU1LDI1NSwyNTUsIDAuNzUpIDAgLTEuNWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMS4xZW0gLTEuMWVtIDAgMDtcXG5ib3gtc2hhZG93OiByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAxLjVlbSAwIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMS4xZW0gMS4xZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAwIDEuNWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgLTEuMWVtIDEuMWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgLTEuNWVtIDAgMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAtMS4xZW0gLTEuMWVtIDAgMCwgcmdiYSgyNTUsMjU1LDI1NSwgMC43NSkgMCAtMS41ZW0gMCAwLCByZ2JhKDI1NSwyNTUsMjU1LCAwLjc1KSAxLjFlbSAtMS4xZW0gMCAwO1xcbn1cXG5cXG4vKiBBbmltYXRpb24gKi9cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgc3Bpbm5lciB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW8tdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW8tdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuQC1tb3ota2V5ZnJhbWVzIHNwaW5uZXIge1xcbiAgMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtbW96LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1vLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG4gIDEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1vLXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcbkAtby1rZXlmcmFtZXMgc3Bpbm5lciB7XFxuICAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tb3otdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW8tdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbXMtdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgLW8tdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBzcGlubmVyIHtcXG4gIDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1vei10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgLW1zLXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtbW96LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgIC1tcy10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAtby10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbn1cXG48L3N0eWxlPlxcblwiXX0sIG1lZGlhOiB1bmRlZmluZWQgfSk7XG5cblx0ICAgIH07XG5cdCAgICAvKiBzY29wZWQgKi9cblx0ICAgIHZhciBfX3Z1ZV9zY29wZV9pZF9fJDMgPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuXHQgICAgdmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kMyA9IHVuZGVmaW5lZDtcblx0ICAgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICAgIHZhciBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kMyA9IGZhbHNlO1xuXHQgICAgLyogY29tcG9uZW50IG5vcm1hbGl6ZXIgKi9cblx0ICAgIGZ1bmN0aW9uIF9fdnVlX25vcm1hbGl6ZV9fJDMoXG5cdCAgICAgIHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0LFxuXHQgICAgICBzY29wZSwgZnVuY3Rpb25hbCwgbW9kdWxlSWRlbnRpZmllcixcblx0ICAgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgICApIHtcblx0ICAgICAgdmFyIGNvbXBvbmVudCA9ICh0eXBlb2Ygc2NyaXB0ID09PSAnZnVuY3Rpb24nID8gc2NyaXB0Lm9wdGlvbnMgOiBzY3JpcHQpIHx8IHt9O1xuXG5cdCAgICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgICAgY29tcG9uZW50Ll9fZmlsZSA9IFwiL1VzZXJzL3lhcmlrL1Byb2plY3RzL2Nsb25lcy92dWVkbC9zcmMvY29tcG9uZW50cy9EaWFsb2dPdmVybGF5LnZ1ZVwiO1xuXG5cdCAgICAgIGlmICghY29tcG9uZW50LnJlbmRlcikge1xuXHQgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgICAgY29tcG9uZW50LnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICAgICAgICBjb21wb25lbnQuX2NvbXBpbGVkID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgICB9XG5cblx0ICAgICAgY29tcG9uZW50Ll9zY29wZUlkID0gc2NvcGU7XG5cblx0ICAgICAge1xuXHQgICAgICAgIHZhciBob29rO1xuXHQgICAgICAgIGlmIChzdHlsZSkge1xuXHQgICAgICAgICAgaG9vayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3Rvcihjb250ZXh0KSk7XG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgIGlmIChjb21wb25lbnQuZnVuY3Rpb25hbCkge1xuXHQgICAgICAgICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcblx0ICAgICAgICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gY29tcG9uZW50LnJlbmRlcjtcblx0ICAgICAgICAgICAgY29tcG9uZW50LnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbihoLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpO1xuXHQgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcblx0ICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gY29tcG9uZW50LmJlZm9yZUNyZWF0ZTtcblx0ICAgICAgICAgICAgY29tcG9uZW50LmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKSA6IFtob29rXTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gY29tcG9uZW50XG5cdCAgICB9XG5cdCAgICAvKiBzdHlsZSBpbmplY3QgKi9cblx0ICAgIGZ1bmN0aW9uIF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDMoKSB7XG5cdCAgICAgIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHQgICAgICB2YXIgc3R5bGVzID0gX192dWVfY3JlYXRlX2luamVjdG9yX18kMy5zdHlsZXMgfHwgKF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDMuc3R5bGVzID0ge30pO1xuXHQgICAgICB2YXIgaXNPbGRJRSA9XG5cdCAgICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgICAvbXNpZSBbNi05XVxcXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cblx0ICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFkZFN0eWxlKGlkLCBjc3MpIHtcblx0ICAgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBpZCArICdcIl0nKSkgeyByZXR1cm4gfSAvLyBTU1Igc3R5bGVzIGFyZSBwcmVzZW50LlxuXG5cdCAgICAgICAgdmFyIGdyb3VwID0gaXNPbGRJRSA/IGNzcy5tZWRpYSB8fCAnZGVmYXVsdCcgOiBpZDtcblx0ICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbZ3JvdXBdIHx8IChzdHlsZXNbZ3JvdXBdID0geyBpZHM6IFtdLCBwYXJ0czogW10sIGVsZW1lbnQ6IHVuZGVmaW5lZCB9KTtcblxuXHQgICAgICAgIGlmICghc3R5bGUuaWRzLmluY2x1ZGVzKGlkKSkge1xuXHQgICAgICAgICAgdmFyIGNvZGUgPSBjc3Muc291cmNlO1xuXHQgICAgICAgICAgdmFyIGluZGV4ID0gc3R5bGUuaWRzLmxlbmd0aDtcblxuXHQgICAgICAgICAgc3R5bGUuaWRzLnB1c2goaWQpO1xuXG5cdCAgICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgICBzdHlsZS5lbGVtZW50ID0gc3R5bGUuZWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWdyb3VwPScgKyBncm91cCArICddJyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmICghc3R5bGUuZWxlbWVudCkge1xuXHQgICAgICAgICAgICB2YXIgZWwgPSBzdHlsZS5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0ICAgICAgICAgICAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cblx0ICAgICAgICAgICAgaWYgKGNzcy5tZWRpYSkgeyBlbC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgY3NzLm1lZGlhKTsgfVxuXHQgICAgICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcsIGdyb3VwKTtcblx0ICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsICcwJyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGVsKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChzdHlsZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JykpO1xuXHQgICAgICAgICAgICBzdHlsZS5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JywgaW5kZXggKyAxKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKHN0eWxlLmVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHQgICAgICAgICAgICBzdHlsZS5wYXJ0cy5wdXNoKGNvZGUpO1xuXHQgICAgICAgICAgICBzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHN0eWxlLnBhcnRzXG5cdCAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuXHQgICAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUpO1xuXHQgICAgICAgICAgICB2YXIgbm9kZXMgPSBzdHlsZS5lbGVtZW50LmNoaWxkTm9kZXM7XG5cdCAgICAgICAgICAgIGlmIChub2Rlc1tpbmRleF0pIHsgc3R5bGUuZWxlbWVudC5yZW1vdmVDaGlsZChub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHsgc3R5bGUuZWxlbWVudC5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGVzW2luZGV4XSk7IH1cblx0ICAgICAgICAgICAgZWxzZSB7IHN0eWxlLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpOyB9XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICAvKiBzdHlsZSBpbmplY3QgU1NSICovXG5cdCAgICBcblxuXHQgICAgXG5cdCAgICB2YXIgRGlhbG9nT3ZlcmxheSA9IF9fdnVlX25vcm1hbGl6ZV9fJDMoXG5cdCAgICAgIHsgcmVuZGVyOiBfX3Z1ZV9yZW5kZXJfXyQzLCBzdGF0aWNSZW5kZXJGbnM6IF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDMgfSxcblx0ICAgICAgX192dWVfaW5qZWN0X3N0eWxlc19fJDMsXG5cdCAgICAgIF9fdnVlX3NjcmlwdF9fJDMsXG5cdCAgICAgIF9fdnVlX3Njb3BlX2lkX18kMyxcblx0ICAgICAgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDMsXG5cdCAgICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kMyxcblx0ICAgICAgX192dWVfY3JlYXRlX2luamVjdG9yX18kMyxcblx0ICAgICAgdW5kZWZpbmVkXG5cdCAgICApO1xuXG5cdCAgdmFyIENvbmZpcm1hYmxlID0ge1xuXHQgICAgbmFtZTogJ0NvbmZpcm1hYmxlJyxcblx0ICAgIHByb3BzOiB7XG5cdCAgICAgIHR5cGU6IHtcblx0ICAgICAgICB0eXBlOiBTdHJpbmdcblx0ICAgICAgfSxcblx0ICAgICAgdGV4dDoge1xuXHQgICAgICAgIHR5cGU6IFN0cmluZyxcblx0ICAgICAgICByZXFpdXJlZDogdHJ1ZVxuXHQgICAgICB9LFxuXHQgICAgICB0aXRsZToge1xuXHQgICAgICAgIHR5cGU6IFN0cmluZ1xuXHQgICAgICB9LFxuXHQgICAgICBhY3Rpb25zOiB7XG5cdCAgICAgICAgdHlwZTogW0FycmF5LCBPYmplY3RdXG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgLyogQHZ1ZS9jb21wb25lbnQgKi9cblx0ICB2YXIgUmV0dXJuYWJsZSA9IHtcblx0ICAgIG5hbWU6ICdSZXR1cm5hYmxlJyxcblx0ICAgIHByb3BzOiB7XG5cdCAgICAgIHJldHVyblZhbHVlOiBudWxsXG5cdCAgICB9LFxuXG5cdCAgICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIG9yaWdpbmFsVmFsdWU6IHRoaXMucmV0dXJuVmFsdWUsXG5cdCAgICAgICAgcmV0dXJuUmVzb3ZlcnM6IFtdXG5cdCAgICAgIH07XG5cdCAgICB9LFxuXG5cdCAgICAvLyB3YXRjaDoge1xuXHQgICAgLy8gICAnd3JhcHBlci5pc0FjdGl2ZScgKHZhbCkge1xuXHQgICAgLy8gICAgIGNvbnNvbGUubG9nKCd3YXRjaC5pc0FjdGl2ZScsIHZhbClcblx0ICAgIC8vICAgICBpZiAodmFsKSB7XG5cdCAgICAvLyAgICAgICB0aGlzLm9yaWdpbmFsVmFsdWUgPSB0aGlzLnJldHVyblZhbHVlXG5cdCAgICAvLyAgICAgfSBlbHNlIHtcblx0ICAgIC8vICAgICAgIC8vIGNvbnNvbGUubG9nKCdlbWl0JywgdGhpcy5vcmlnaW5hbFZhbHVlKVxuXHQgICAgLy8gICAgICAgLy8gdGhpcy4kZW1pdCgnc3VibWl0JywgdGhpcy5vcmlnaW5hbFZhbHVlKVxuXHQgICAgLy8gICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnJldHVyblZhbHVlJywgdGhpcy5vcmlnaW5hbFZhbHVlKVxuXHQgICAgLy8gICAgIH1cblx0ICAgIC8vICAgfVxuXHQgICAgLy8gfSxcblx0ICAgIG1ldGhvZHM6IHtcblx0ICAgICAgcmV0dXJuOiBmdW5jdGlvbiByZXR1cm4kMSh2YWx1ZSkge1xuXHQgICAgICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IHZhbHVlO1xuXHQgICAgICAgIHRoaXMuJHJvb3QuJGVtaXQoJ3N1Ym1pdCcsIHRoaXMub3JpZ2luYWxWYWx1ZSk7XG5cdCAgICAgICAgdGhpcy4kZW1pdCgnc3VibWl0JywgdGhpcy5vcmlnaW5hbFZhbHVlKTtcblx0ICAgICAgfVxuXG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIHZhciBBY3Rpb25hYmxlID0ge1xuXHQgICAgbmFtZTogJ0FjdGlvbmFibGUnLFxuXHQgICAgbWl4aW5zOiBbUmV0dXJuYWJsZV0sXG5cblx0ICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgbG9hZGluZ0FjdGlvbjogbnVsbFxuXHQgICAgICB9O1xuXHQgICAgfSxcblxuXHQgICAgcHJvcHM6IHtcblx0ICAgICAgYWN0aW9uczoge1xuXHQgICAgICAgIHR5cGU6IFtBcnJheSwgT2JqZWN0XSxcblx0ICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgY29tcHV0ZWQ6IHtcblx0ICAgICAgYWN0aW9ubGlzdDogZnVuY3Rpb24gYWN0aW9ubGlzdCgpIHtcblx0ICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuXHQgICAgICAgIHZhciBhY3Rpb25zID0gW107XG5cblx0ICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmFjdGlvbnMpIHtcblx0ICAgICAgICAgIHZhciBhY3Rpb24gPSB0aGlzJDEuYWN0aW9uc1trZXldO1xuXG5cdCAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgYWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgIHRleHQ6IGFjdGlvblxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB0aGlzJDEuJHNldChhY3Rpb24sICdsb2FkaW5nJywgZmFsc2UpO1xuXG5cdCAgICAgICAgICBpZiAoIWFjdGlvbi5rZXkpIHtcblx0ICAgICAgICAgICAgYWN0aW9uLmtleSA9IGlzTmFOKGtleSkgPyBrZXkgOiBhY3Rpb24udGV4dDtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaWYgKFsndHJ1ZScsICdmYWxzZSddLmluZGV4T2YoYWN0aW9uLmtleSkgPj0gMCkge1xuXHQgICAgICAgICAgICBhY3Rpb24ua2V5ID0gSlNPTi5wYXJzZShhY3Rpb24ua2V5KTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG5cdCAgICAgIH1cblxuXHQgICAgfSxcblx0ICAgIG1ldGhvZHM6IHtcblx0ICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihuYW1lKSB7XG5cdCAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9ubGlzdC5maW5kKGZ1bmN0aW9uIChhY3Rpb24pIHsgcmV0dXJuIGFjdGlvbi5rZXkgPT09IG5hbWU7IH0pO1xuXG5cdCAgICAgICAgaWYgKGFjdGlvbiAmJiAhdGhpcy5pc0FjdGlvbkRpc2FibGVkKGFjdGlvbikgJiYgdGhpcy5pc0FjdGlvblZpc2libGUoYWN0aW9uKSkge1xuXHQgICAgICAgICAgdGhpcy5vbkFjdGlvbkNsaWNrKGFjdGlvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXG5cdCAgICAgIHNldExvYWRpbmdUb0luc3RhbmNlOiBmdW5jdGlvbiBzZXRMb2FkaW5nVG9JbnN0YW5jZSh2bSwgdmFsdWUpIHtcblx0ICAgICAgICBpZiAodm0gJiYgdm0ubG9hZGluZyAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICB2bS5sb2FkaW5nID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICB9LFxuXG5cdCAgICAgIHNldExvYWRpbmdTdGF0ZTogZnVuY3Rpb24gc2V0TG9hZGluZ1N0YXRlKHZhbHVlKSB7XG5cdCAgICAgICAgdGhpcy4kZW1pdCgnbG9hZGluZycsIHZhbHVlKTtcblx0ICAgICAgICAhdmFsdWUgJiYgKHRoaXMubG9hZGluZ0FjdGlvbiA9IG51bGwpO1xuXHQgICAgICAgIHRoaXMuc2V0TG9hZGluZ1RvSW5zdGFuY2UodGhpcy4kcm9vdCwgdmFsdWUpO1xuXHQgICAgICAgIHRoaXMuc2V0TG9hZGluZ1RvSW5zdGFuY2UodGhpcy4kcm9vdC5fZGlhbG9nSW5zdGFuY2UsIHZhbHVlKTtcblx0ICAgICAgfSxcblxuXHQgICAgICBpc0FjdGlvbkRpc2FibGVkOiBmdW5jdGlvbiBpc0FjdGlvbkRpc2FibGVkKGFjdGlvbikge1xuXHQgICAgICAgIGlmIChhY3Rpb24uZGlzYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uLmRpc2FibGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgICByZXR1cm4gYWN0aW9uLmRpc2FibGVkKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGFjdGlvbi5kaXNhYmxlZDtcblx0ICAgICAgfSxcblxuXHQgICAgICBpc0FjdGlvblZpc2libGU6IGZ1bmN0aW9uIGlzQWN0aW9uVmlzaWJsZShhY3Rpb24pIHtcblx0ICAgICAgICBpZiAoYWN0aW9uLnZpc2libGUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24udmlzaWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgcmV0dXJuIGFjdGlvbi52aXNpYmxlKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGFjdGlvbi52aXNpYmxlO1xuXHQgICAgICB9LFxuXG5cdCAgICAgIG9uQWN0aW9uQ2xpY2s6IGZ1bmN0aW9uIG9uQWN0aW9uQ2xpY2soYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uICgkcmV0dXJuLCAkZXJyb3IpIHtcblx0ICAgICAgICAgIHZhciBjbG9zYWJsZTtcblx0ICAgICAgICAgIGNsb3NhYmxlID0gYWN0aW9uLmNsb3NhYmxlID09PSB1bmRlZmluZWQgfHwgYWN0aW9uLmNsb3NhYmxlID09PSB0cnVlO1xuXG5cdCAgICAgICAgICBpZiAoYWN0aW9uLmhhbmRsZSkge1xuXHQgICAgICAgICAgICB0aGlzLmxvYWRpbmdBY3Rpb24gPSBhY3Rpb24ua2V5O1xuXHQgICAgICAgICAgICB0aGlzLnNldExvYWRpbmdTdGF0ZSh0cnVlKTtcblxuXHQgICAgICAgICAgICB2YXIgJFRyeV8xX1Bvc3QgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAkSWZfMi5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICAgIH0gY2F0Y2ggKCRib3VuZEV4KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJGVycm9yKCRib3VuZEV4KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuXHQgICAgICAgICAgICB2YXIgJFRyeV8xX0NhdGNoID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXRMb2FkaW5nU3RhdGUoZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yJywgZSk7IC8vIFRPRE9cblxuXHQgICAgICAgICAgICAgICAgdGhyb3cgZTtcblx0ICAgICAgICAgICAgICB9IGNhdGNoICgkYm91bmRFeCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICRlcnJvcigkYm91bmRFeCk7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LmJpbmQodGhpcyk7XG5cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICB2YXIgcmV0O1xuXHQgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWN0aW9uLmhhbmRsZSgpKS50aGVuKGZ1bmN0aW9uICgkYXdhaXRfMykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgcmV0ID0gJGF3YWl0XzM7XG5cdCAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9hZGluZ1N0YXRlKGZhbHNlKTtcblxuXHQgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSAmJiBjbG9zYWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuKHJldCB8fCBhY3Rpb24ua2V5KTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgIHJldHVybiAkVHJ5XzFfUG9zdCgpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoJGJvdW5kRXgpIHtcblx0ICAgICAgICAgICAgICAgICAgcmV0dXJuICRUcnlfMV9DYXRjaCgkYm91bmRFeCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAkVHJ5XzFfQ2F0Y2gpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgJFRyeV8xX0NhdGNoKGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBjbG9zYWJsZSAmJiB0aGlzLnJldHVybihhY3Rpb24ua2V5KTtcblx0ICAgICAgICAgICAgcmV0dXJuICRJZl8yLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGZ1bmN0aW9uICRJZl8yKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJHJldHVybigpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdCAgICAgIH1cblxuXHQgICAgfVxuXHQgIH07XG5cblx0ICAvL1xuXHQgIHZhciBzY3JpcHQkNCA9IHtcblx0ICAgIG1peGluczogW0FjdGlvbmFibGVdXG5cdCAgfTtcblxuXHQgIC8qIHNjcmlwdCAqL1xuXHQgICAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQ0ID0gc2NyaXB0JDQ7XG5cdCAgICAgICAgICAgICAgXG5cdCAgLyogdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfcmVuZGVyX18kNCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIF92bSA9IHRoaXM7XG5cdCAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnQ7XG5cdCAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgICByZXR1cm4gX2MoXG5cdCAgICAgIFwic3BhblwiLFxuXHQgICAgICBfdm0uX2woX3ZtLmFjdGlvbmxpc3QsIGZ1bmN0aW9uKGFjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfYyhcblx0ICAgICAgICAgIFwiYnV0dG9uXCIsXG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIGtleTogYWN0aW9uLmtleSxcblx0ICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYnV0dG9uXCIsXG5cdCAgICAgICAgICAgIGNsYXNzOiB7IGxvYWRpbmc6IF92bS5sb2FkaW5nQWN0aW9uID09PSBhY3Rpb24ua2V5IH0sXG5cdCAgICAgICAgICAgIGF0dHJzOiB7XG5cdCAgICAgICAgICAgICAgXCJhY3Rpb24ta2V5XCI6IFwiXCIgKyBhY3Rpb24ua2V5LFxuXHQgICAgICAgICAgICAgIGRpc2FibGVkOiBfdm0uaXNBY3Rpb25EaXNhYmxlZChhY3Rpb24pIHx8ICEhX3ZtLmxvYWRpbmdBY3Rpb25cblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgb246IHtcblx0ICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBfdm0ub25BY3Rpb25DbGljayhhY3Rpb24pO1xuXHQgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIFtfdm0uX3YoXCJcXG4gICAgXCIgKyBfdm0uX3MoYWN0aW9uLnRleHQpICsgXCJcXG4gIFwiKV1cblx0ICAgICAgICApXG5cdCAgICAgIH0pXG5cdCAgICApXG5cdCAgfTtcblx0ICB2YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18kNCA9IFtdO1xuXHQgIF9fdnVlX3JlbmRlcl9fJDQuX3dpdGhTdHJpcHBlZCA9IHRydWU7XG5cblx0ICAgIC8qIHN0eWxlICovXG5cdCAgICB2YXIgX192dWVfaW5qZWN0X3N0eWxlc19fJDQgPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBzY29wZWQgKi9cblx0ICAgIHZhciBfX3Z1ZV9zY29wZV9pZF9fJDQgPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuXHQgICAgdmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kNCA9IHVuZGVmaW5lZDtcblx0ICAgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICAgIHZhciBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kNCA9IGZhbHNlO1xuXHQgICAgLyogY29tcG9uZW50IG5vcm1hbGl6ZXIgKi9cblx0ICAgIGZ1bmN0aW9uIF9fdnVlX25vcm1hbGl6ZV9fJDQoXG5cdCAgICAgIHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0LFxuXHQgICAgICBzY29wZSwgZnVuY3Rpb25hbCwgbW9kdWxlSWRlbnRpZmllcixcblx0ICAgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgICApIHtcblx0ICAgICAgdmFyIGNvbXBvbmVudCA9ICh0eXBlb2Ygc2NyaXB0ID09PSAnZnVuY3Rpb24nID8gc2NyaXB0Lm9wdGlvbnMgOiBzY3JpcHQpIHx8IHt9O1xuXG5cdCAgICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgICAgY29tcG9uZW50Ll9fZmlsZSA9IFwiL1VzZXJzL3lhcmlrL1Byb2plY3RzL2Nsb25lcy92dWVkbC9zcmMvY29tcG9uZW50cy9EaWFsb2dBY3Rpb25zLnZ1ZVwiO1xuXG5cdCAgICAgIGlmICghY29tcG9uZW50LnJlbmRlcikge1xuXHQgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgICAgY29tcG9uZW50LnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICAgICAgICBjb21wb25lbnQuX2NvbXBpbGVkID0gdHJ1ZTtcblxuXHQgICAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgICB9XG5cblx0ICAgICAgY29tcG9uZW50Ll9zY29wZUlkID0gc2NvcGU7XG5cblx0ICAgICAgXG5cblx0ICAgICAgcmV0dXJuIGNvbXBvbmVudFxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgICBmdW5jdGlvbiBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQ0KCkge1xuXHQgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0ICAgICAgdmFyIHN0eWxlcyA9IF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDQuc3R5bGVzIHx8IChfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQ0LnN0eWxlcyA9IHt9KTtcblx0ICAgICAgdmFyIGlzT2xkSUUgPVxuXHQgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgICAgL21zaWUgWzYtOV1cXFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBhZGRTdHlsZShpZCwgY3NzKSB7XG5cdCAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgaWQgKyAnXCJdJykpIHsgcmV0dXJuIH0gLy8gU1NSIHN0eWxlcyBhcmUgcHJlc2VudC5cblxuXHQgICAgICAgIHZhciBncm91cCA9IGlzT2xkSUUgPyBjc3MubWVkaWEgfHwgJ2RlZmF1bHQnIDogaWQ7XG5cdCAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2dyb3VwXSB8fCAoc3R5bGVzW2dyb3VwXSA9IHsgaWRzOiBbXSwgcGFydHM6IFtdLCBlbGVtZW50OiB1bmRlZmluZWQgfSk7XG5cblx0ICAgICAgICBpZiAoIXN0eWxlLmlkcy5pbmNsdWRlcyhpZCkpIHtcblx0ICAgICAgICAgIHZhciBjb2RlID0gY3NzLnNvdXJjZTtcblx0ICAgICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmlkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgIHN0eWxlLmlkcy5wdXNoKGlkKTtcblxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudCA9IHN0eWxlLmVsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1ncm91cD0nICsgZ3JvdXAgKyAnXScpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoIXN0eWxlLmVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGVsID0gc3R5bGUuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICAgICAgICAgIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuXG5cdCAgICAgICAgICAgIGlmIChjc3MubWVkaWEpIHsgZWwuc2V0QXR0cmlidXRlKCdtZWRpYScsIGNzcy5tZWRpYSk7IH1cblx0ICAgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnLCBncm91cCk7XG5cdCAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnLCAnMCcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoc3R5bGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcpKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsIGluZGV4ICsgMSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0ICAgICAgICAgICAgc3R5bGUucGFydHMucHVzaChjb2RlKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZS5wYXJ0c1xuXHQgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcblx0ICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb2RlKTtcblx0ICAgICAgICAgICAgdmFyIG5vZGVzID0gc3R5bGUuZWxlbWVudC5jaGlsZE5vZGVzO1xuXHQgICAgICAgICAgICBpZiAobm9kZXNbaW5kZXhdKSB7IHN0eWxlLmVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZXNbaW5kZXhdKTsgfVxuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7IHN0eWxlLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICAgIGVsc2UgeyBzdHlsZS5lbGVtZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTsgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgICAgXG5cblx0ICAgIFxuXHQgICAgdmFyIERpYWxvZ0FjdGlvbnMgPSBfX3Z1ZV9ub3JtYWxpemVfXyQ0KFxuXHQgICAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kNCwgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQ0IH0sXG5cdCAgICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyQ0LFxuXHQgICAgICBfX3Z1ZV9zY3JpcHRfXyQ0LFxuXHQgICAgICBfX3Z1ZV9zY29wZV9pZF9fJDQsXG5cdCAgICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQ0LFxuXHQgICAgICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDQsXG5cdCAgICAgIF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDQsXG5cdCAgICAgIHVuZGVmaW5lZFxuXHQgICAgKTtcblxuXHQgIC8vXG5cdCAgdmFyIHNjcmlwdCQ1ID0ge1xuXHQgICAgY29tcG9uZW50czoge1xuXHQgICAgICBEaWFsb2dBY3Rpb25zOiBEaWFsb2dBY3Rpb25zXG5cdCAgICB9LFxuXHQgICAgbGF5b3V0OiAnZGVmYXVsdCcsXG5cdCAgICBtaXhpbnM6IFtDb25maXJtYWJsZV1cblx0ICB9O1xuXG5cdCAgLyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgICAgdmFyIF9fdnVlX3NjcmlwdF9fJDUgPSBzY3JpcHQkNTtcblx0ICAgICAgICAgICAgICBcblx0ICAvKiB0ZW1wbGF0ZSAqL1xuXHQgIHZhciBfX3Z1ZV9yZW5kZXJfXyQ1ID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgX3ZtID0gdGhpcztcblx0ICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaDtcblx0ICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbmZpcm0tYm94XCIgfSwgW1xuXHQgICAgICAhIV92bS50aXRsZVxuXHQgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb25maXJtLXRpdGxlXCIgfSwgW1xuXHQgICAgICAgICAgICBfYyhcImgxXCIsIHsgc3RhdGljQ2xhc3M6IFwidGl0bGVcIiB9LCBbX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKV0pXG5cdCAgICAgICAgICBdKVxuXHQgICAgICAgIDogX3ZtLl9lKCksXG5cdCAgICAgIF92bS5fdihcIiBcIiksXG5cdCAgICAgIF9jKFwiZGl2XCIsIHtcblx0ICAgICAgICBzdGF0aWNDbGFzczogXCJjb25maXJtLW1lc3NhZ2VcIixcblx0ICAgICAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IF92bS5fcyhfdm0ubWVzc2FnZSkgfVxuXHQgICAgICB9KSxcblx0ICAgICAgX3ZtLl92KFwiIFwiKSxcblx0ICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb25maXJtLWJ1dHRvbnNcIiB9LCBbXG5cdCAgICAgICAgX2MoXG5cdCAgICAgICAgICBcImRpdlwiLFxuXHQgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJjb2x1bW5cIiB9LFxuXHQgICAgICAgICAgW19jKFwiRGlhbG9nQWN0aW9uc1wiLCB7IGF0dHJzOiB7IGFjdGlvbnM6IF92bS5hY3Rpb25zIH0gfSldLFxuXHQgICAgICAgICAgMVxuXHQgICAgICAgIClcblx0ICAgICAgXSlcblx0ICAgIF0pXG5cdCAgfTtcblx0ICB2YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18kNSA9IFtdO1xuXHQgIF9fdnVlX3JlbmRlcl9fJDUuX3dpdGhTdHJpcHBlZCA9IHRydWU7XG5cblx0ICAgIC8qIHN0eWxlICovXG5cdCAgICB2YXIgX192dWVfaW5qZWN0X3N0eWxlc19fJDUgPSBmdW5jdGlvbiAoaW5qZWN0KSB7XG5cdCAgICAgIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG5cdCAgICAgIGluamVjdChcImRhdGEtdi04YTg3NjUxY18wXCIsIHsgc291cmNlOiBcIlxcbi5jb25maXJtLWJveCB7XFxuICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xcbn1cXG4uY29uZmlybS1ib3ggLmNvbmZpcm0tdGl0bGUge1xcbiAgcGFkZGluZzogMjBweFxcbn1cXG4uY29uZmlybS1ib3ggLmNvbmZpcm0tbWVzc2FnZSB7XFxuICBwYWRkaW5nOiAwIDIwcHg7XFxufVxcbi5jb25maXJtLWJveCAuY29uZmlybS1idXR0b25zIHtcXG4gIHRleHQtYWxpZ246ICByaWdodDtcXG4gIHBhZGRpbmc6IDEwcHggMjBweDtcXG59XFxuLmNvbmZpcm0tYm94IC5jb25maXJtLWJ1dHRvbnMgLmJ1dHRvbiB7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxufVxcblwiLCBtYXA6IHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvdnVlZGwvc3JjL2NvbXBvbmVudHMvQ29uZmlybS52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTZCQTtFQUNBLG9CQUFBO0NBQ0E7QUFDQTtFQUNBLGFBQUE7Q0FDQTtBQUNBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUNBO0VBQ0EsbUJBQUE7RUFDQSxtQkFBQTtDQUNBO0FBQ0E7RUFDQSxnQkFBQTtFQUNBLG1CQUFBO0NBQ0FcIixcImZpbGVcIjpcIkNvbmZpcm0udnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxkaXYgY2xhc3M9XFxcImNvbmZpcm0tYm94XFxcIj5cXG4gICAgPGRpdiB2LWlmPVxcXCIhIXRpdGxlXFxcIiBjbGFzcz1cXFwiY29uZmlybS10aXRsZVxcXCI+XFxuICAgICAgPGgxIGNsYXNzPVxcXCJ0aXRsZVxcXCI+e3sgdGl0bGUgfX08L2gxPlxcbiAgICA8L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29uZmlybS1tZXNzYWdlXFxcIiB2LWh0bWw9XFxcIm1lc3NhZ2VcXFwiIC8+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbmZpcm0tYnV0dG9uc1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sdW1uXFxcIj5cXG4gICAgICAgIDxEaWFsb2dBY3Rpb25zIDphY3Rpb25zPVxcXCJhY3Rpb25zXFxcIi8+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcblxcbmltcG9ydCBDb25maXJtYWJsZSBmcm9tICcuLi9taXhpbnMvY29uZmlybWFibGUnXFxuaW1wb3J0IERpYWxvZ0FjdGlvbnMgZnJvbSAnLi9EaWFsb2dBY3Rpb25zLnZ1ZSdcXG5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBjb21wb25lbnRzOiB7XFxuICAgIERpYWxvZ0FjdGlvbnNcXG4gIH0sXFxuICBsYXlvdXQ6ICdkZWZhdWx0JyxcXG4gIG1peGluczogWyBDb25maXJtYWJsZSBdXFxufVxcblxcbjwvc2NyaXB0PlxcblxcbjxzdHlsZT5cXG4gIC5jb25maXJtLWJveCB7XFxuICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxuICB9XFxuICAuY29uZmlybS1ib3ggLmNvbmZpcm0tdGl0bGUge1xcbiAgICBwYWRkaW5nOiAyMHB4XFxuICB9XFxuICAuY29uZmlybS1ib3ggLmNvbmZpcm0tbWVzc2FnZSB7XFxuICAgIHBhZGRpbmc6IDAgMjBweDtcXG4gIH1cXG4gIC5jb25maXJtLWJveCAuY29uZmlybS1idXR0b25zIHtcXG4gICAgdGV4dC1hbGlnbjogIHJpZ2h0O1xcbiAgICBwYWRkaW5nOiAxMHB4IDIwcHg7XFxuICB9XFxuICAuY29uZmlybS1ib3ggLmNvbmZpcm0tYnV0dG9ucyAuYnV0dG9uIHtcXG4gICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICB9XFxuPC9zdHlsZT5cXG5cIl19LCBtZWRpYTogdW5kZWZpbmVkIH0pO1xuXG5cdCAgICB9O1xuXHQgICAgLyogc2NvcGVkICovXG5cdCAgICB2YXIgX192dWVfc2NvcGVfaWRfXyQ1ID0gdW5kZWZpbmVkO1xuXHQgICAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cblx0ICAgIHZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDUgPSB1bmRlZmluZWQ7XG5cdCAgICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG5cdCAgICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDUgPSBmYWxzZTtcblx0ICAgIC8qIGNvbXBvbmVudCBub3JtYWxpemVyICovXG5cdCAgICBmdW5jdGlvbiBfX3Z1ZV9ub3JtYWxpemVfXyQ1KFxuXHQgICAgICB0ZW1wbGF0ZSwgc3R5bGUsIHNjcmlwdCxcblx0ICAgICAgc2NvcGUsIGZ1bmN0aW9uYWwsIG1vZHVsZUlkZW50aWZpZXIsXG5cdCAgICAgIGNyZWF0ZUluamVjdG9yLCBjcmVhdGVJbmplY3RvclNTUlxuXHQgICAgKSB7XG5cdCAgICAgIHZhciBjb21wb25lbnQgPSAodHlwZW9mIHNjcmlwdCA9PT0gJ2Z1bmN0aW9uJyA/IHNjcmlwdC5vcHRpb25zIDogc2NyaXB0KSB8fCB7fTtcblxuXHQgICAgICAvLyBGb3Igc2VjdXJpdHkgY29uY2VybnMsIHdlIHVzZSBvbmx5IGJhc2UgbmFtZSBpbiBwcm9kdWN0aW9uIG1vZGUuXG5cdCAgICAgIGNvbXBvbmVudC5fX2ZpbGUgPSBcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvdnVlZGwvc3JjL2NvbXBvbmVudHMvQ29uZmlybS52dWVcIjtcblxuXHQgICAgICBpZiAoIWNvbXBvbmVudC5yZW5kZXIpIHtcblx0ICAgICAgICBjb21wb25lbnQucmVuZGVyID0gdGVtcGxhdGUucmVuZGVyO1xuXHQgICAgICAgIGNvbXBvbmVudC5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG5cdCAgICAgICAgY29tcG9uZW50Ll9jb21waWxlZCA9IHRydWU7XG5cblx0ICAgICAgICBpZiAoZnVuY3Rpb25hbCkgeyBjb21wb25lbnQuZnVuY3Rpb25hbCA9IHRydWU7IH1cblx0ICAgICAgfVxuXG5cdCAgICAgIGNvbXBvbmVudC5fc2NvcGVJZCA9IHNjb3BlO1xuXG5cdCAgICAgIHtcblx0ICAgICAgICB2YXIgaG9vaztcblx0ICAgICAgICBpZiAoc3R5bGUpIHtcblx0ICAgICAgICAgIGhvb2sgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIHN0eWxlLmNhbGwodGhpcywgY3JlYXRlSW5qZWN0b3IoY29udGV4dCkpO1xuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICBpZiAoY29tcG9uZW50LmZ1bmN0aW9uYWwpIHtcblx0ICAgICAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG5cdCAgICAgICAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IGNvbXBvbmVudC5yZW5kZXI7XG5cdCAgICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuXHQgICAgICAgICAgICAgIGhvb2suY2FsbChjb250ZXh0KTtcblx0ICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG5cdCAgICAgICAgICAgIHZhciBleGlzdGluZyA9IGNvbXBvbmVudC5iZWZvcmVDcmVhdGU7XG5cdCAgICAgICAgICAgIGNvbXBvbmVudC5iZWZvcmVDcmVhdGUgPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaykgOiBbaG9va107XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIGNvbXBvbmVudFxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgICBmdW5jdGlvbiBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQ1KCkge1xuXHQgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0ICAgICAgdmFyIHN0eWxlcyA9IF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDUuc3R5bGVzIHx8IChfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQ1LnN0eWxlcyA9IHt9KTtcblx0ICAgICAgdmFyIGlzT2xkSUUgPVxuXHQgICAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgICAgL21zaWUgWzYtOV1cXFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICAgIHJldHVybiBmdW5jdGlvbiBhZGRTdHlsZShpZCwgY3NzKSB7XG5cdCAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgaWQgKyAnXCJdJykpIHsgcmV0dXJuIH0gLy8gU1NSIHN0eWxlcyBhcmUgcHJlc2VudC5cblxuXHQgICAgICAgIHZhciBncm91cCA9IGlzT2xkSUUgPyBjc3MubWVkaWEgfHwgJ2RlZmF1bHQnIDogaWQ7XG5cdCAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2dyb3VwXSB8fCAoc3R5bGVzW2dyb3VwXSA9IHsgaWRzOiBbXSwgcGFydHM6IFtdLCBlbGVtZW50OiB1bmRlZmluZWQgfSk7XG5cblx0ICAgICAgICBpZiAoIXN0eWxlLmlkcy5pbmNsdWRlcyhpZCkpIHtcblx0ICAgICAgICAgIHZhciBjb2RlID0gY3NzLnNvdXJjZTtcblx0ICAgICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmlkcy5sZW5ndGg7XG5cblx0ICAgICAgICAgIHN0eWxlLmlkcy5wdXNoKGlkKTtcblxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudCA9IHN0eWxlLmVsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1ncm91cD0nICsgZ3JvdXAgKyAnXScpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBpZiAoIXN0eWxlLmVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGVsID0gc3R5bGUuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICAgICAgICAgIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuXG5cdCAgICAgICAgICAgIGlmIChjc3MubWVkaWEpIHsgZWwuc2V0QXR0cmlidXRlKCdtZWRpYScsIGNzcy5tZWRpYSk7IH1cblx0ICAgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnLCBncm91cCk7XG5cdCAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnLCAnMCcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoc3R5bGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcpKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsIGluZGV4ICsgMSk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGlmIChzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0ICAgICAgICAgICAgc3R5bGUucGFydHMucHVzaChjb2RlKTtcblx0ICAgICAgICAgICAgc3R5bGUuZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZS5wYXJ0c1xuXHQgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcblx0ICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG5cdCAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb2RlKTtcblx0ICAgICAgICAgICAgdmFyIG5vZGVzID0gc3R5bGUuZWxlbWVudC5jaGlsZE5vZGVzO1xuXHQgICAgICAgICAgICBpZiAobm9kZXNbaW5kZXhdKSB7IHN0eWxlLmVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZXNbaW5kZXhdKTsgfVxuXHQgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7IHN0eWxlLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICAgIGVsc2UgeyBzdHlsZS5lbGVtZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTsgfVxuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgICAgXG5cblx0ICAgIFxuXHQgICAgdmFyIENvbmZpcm0gPSBfX3Z1ZV9ub3JtYWxpemVfXyQ1KFxuXHQgICAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kNSwgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQ1IH0sXG5cdCAgICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyQ1LFxuXHQgICAgICBfX3Z1ZV9zY3JpcHRfXyQ1LFxuXHQgICAgICBfX3Z1ZV9zY29wZV9pZF9fJDUsXG5cdCAgICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQ1LFxuXHQgICAgICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDUsXG5cdCAgICAgIF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDUsXG5cdCAgICAgIHVuZGVmaW5lZFxuXHQgICAgKTtcblxuXHQgIC8qXG5cdCAgICogdnVlZGxcblx0ICAgKlxuXHQgICAqIChjKSBTYXZhcnluIFlhcm9zbGF2IDx5YXJpa3NhdkBnbWFpbC5jb20+XG5cdCAgICpcblx0ICAgKiBGb3IgdGhlIGZ1bGwgY29weXJpZ2h0IGFuZCBsaWNlbnNlIGluZm9ybWF0aW9uLCBwbGVhc2UgdmlldyB0aGUgTElDRU5TRVxuXHQgICAqIGZpbGUgdGhhdCB3YXMgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHNvdXJjZSBjb2RlLlxuXHQgICovXG5cdCAgdmFyIFBsdWdpbiA9IHtcblx0ICAgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlJCQxLCBvcHRpb25zKSB7XG5cdCAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG5cdCAgICAgIHZhciBwcm9wZXJ0eSA9IG9wdGlvbnMucHJvcGVydHkgfHwgJyRkaWFsb2cnO1xuXHQgICAgICB2YXIgbWFuYWdlciA9IG5ldyBEaWFsb2dNYW5hZ2VyKG9wdGlvbnMpOyAvLyBjb25zdCBubyA9IG5ldyBOb3RpZmljYXRvcihtYW5hZ2VyKVxuXG5cdCAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkJDEucHJvdG90eXBlLCBwcm9wZXJ0eSwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuXHQgICAgICAgICAgcmV0dXJuIG1hbmFnZXI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgIH0pO1xuXHQgICAgICBtYW5hZ2VyLmxheW91dCgnZGVmYXVsdCcsIERpYWxvZ0xheW91dCk7XG5cdCAgICAgIG1hbmFnZXIubGF5b3V0KCdub3RpZmljYXRpb24nLCBOb3RpZmljYXRpb25MYXlvdXQpO1xuXHQgICAgICBtYW5hZ2VyLm92ZXJsYXkoJ2RlZmF1bHQnLCBEaWFsb2dPdmVybGF5KTtcblx0ICAgICAgbWFuYWdlci5jb21wb25lbnQoJ2NvbmZpcm0nLCBDb25maXJtLCB7XG5cdCAgICAgICAgd2FpdEZvclJlc3VsdDogdHJ1ZSxcblx0ICAgICAgICBhY3Rpb25zOiB7XG5cdCAgICAgICAgICAnZmFsc2UnOiAnQ2FuY2VsJyxcblx0ICAgICAgICAgICd0cnVlJzogJ09LJ1xuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICAgIG1hbmFnZXIuY29tcG9uZW50KCd3YXJuaW5nJywgQ29uZmlybSwge1xuXHQgICAgICAgIHR5cGU6ICd3YXJuaW5nJyxcblx0ICAgICAgICB3YWl0Rm9yUmVzdWx0OiB0cnVlLFxuXHQgICAgICAgIGFjdGlvbnM6IHtcblx0ICAgICAgICAgICdmYWxzZSc6ICdDYW5jZWwnLFxuXHQgICAgICAgICAgJ3RydWUnOiAnT0snXG5cdCAgICAgICAgfVxuXHQgICAgICB9KTtcblx0ICAgICAgbWFuYWdlci5jb21wb25lbnQoJ2Vycm9yJywgQ29uZmlybSwge1xuXHQgICAgICAgIHR5cGU6ICdlcnJvcicsXG5cdCAgICAgICAgd2FpdEZvclJlc3VsdDogdHJ1ZSxcblx0ICAgICAgICBhY3Rpb25zOiBbJ09LJ11cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICB9O1xuXG5cdCAgcmV0dXJuIFBsdWdpbjtcblxuXHR9KSkpO1xuXHR9KTtcblxuXHQvKiBAdnVlL2NvbXBvbmVudCAqL1xuXHR2YXIgUmV0dXJuYWJsZSA9IHtcblx0ICBuYW1lOiAnUmV0dXJuYWJsZScsXG5cblx0ICBwcm9wczoge1xuXHQgICAgcmV0dXJuVmFsdWU6IG51bGxcblx0ICB9LFxuXG5cdCAgZGF0YSAoKSB7XG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBvcmlnaW5hbFZhbHVlOiB0aGlzLnJldHVyblZhbHVlLFxuXHQgICAgICByZXR1cm5SZXNvdmVyczogW11cblx0ICAgIH1cblx0ICB9LFxuXG5cdCAgLy8gd2F0Y2g6IHtcblx0ICAvLyAgICd3cmFwcGVyLmlzQWN0aXZlJyAodmFsKSB7XG5cdCAgLy8gICAgIGNvbnNvbGUubG9nKCd3YXRjaC5pc0FjdGl2ZScsIHZhbClcblx0ICAvLyAgICAgaWYgKHZhbCkge1xuXHQgIC8vICAgICAgIHRoaXMub3JpZ2luYWxWYWx1ZSA9IHRoaXMucmV0dXJuVmFsdWVcblx0ICAvLyAgICAgfSBlbHNlIHtcblx0ICAvLyAgICAgICAvLyBjb25zb2xlLmxvZygnZW1pdCcsIHRoaXMub3JpZ2luYWxWYWx1ZSlcblx0ICAvLyAgICAgICAvLyB0aGlzLiRlbWl0KCdzdWJtaXQnLCB0aGlzLm9yaWdpbmFsVmFsdWUpXG5cdCAgLy8gICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOnJldHVyblZhbHVlJywgdGhpcy5vcmlnaW5hbFZhbHVlKVxuXHQgIC8vICAgICB9XG5cdCAgLy8gICB9XG5cdCAgLy8gfSxcblxuXHQgIG1ldGhvZHM6IHtcblx0ICAgIHJldHVybiAodmFsdWUpIHtcblx0ICAgICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gdmFsdWU7XG5cdCAgICAgIHRoaXMuJHJvb3QuJGVtaXQoJ3N1Ym1pdCcsIHRoaXMub3JpZ2luYWxWYWx1ZSk7XG5cdCAgICAgIHRoaXMuJGVtaXQoJ3N1Ym1pdCcsIHRoaXMub3JpZ2luYWxWYWx1ZSk7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cblx0dmFyIEFjdGlvbmFibGUgPSB7XG5cdCAgbmFtZTogJ0FjdGlvbmFibGUnLFxuXG5cdCAgbWl4aW5zOiBbIFJldHVybmFibGUgXSxcblxuXHQgIGRhdGEgKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgbG9hZGluZ0FjdGlvbjogbnVsbFxuXHQgICAgfVxuXHQgIH0sXG5cblx0ICBwcm9wczoge1xuXHQgICAgYWN0aW9uczoge1xuXHQgICAgICB0eXBlOiBbQXJyYXksIE9iamVjdF0sXG5cdCAgICAgIGRlZmF1bHQ6ICgpID0+IFtdXG5cdCAgICB9XG5cdCAgfSxcblxuXHQgIGNvbXB1dGVkOiB7XG5cdCAgICBhY3Rpb25saXN0ICgpIHtcblx0ICAgICAgY29uc3QgYWN0aW9ucyA9IFtdO1xuXHQgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5hY3Rpb25zKSB7XG5cdCAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuYWN0aW9uc1trZXldO1xuXHQgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgYWN0aW9uID0ge3RleHQ6IGFjdGlvbn07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuJHNldChhY3Rpb24sICdsb2FkaW5nJywgZmFsc2UpO1xuXHQgICAgICAgIGlmICghYWN0aW9uLmtleSkge1xuXHQgICAgICAgICAgYWN0aW9uLmtleSA9IGlzTmFOKGtleSkgPyBrZXkgOiBhY3Rpb24udGV4dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKFsndHJ1ZScsICdmYWxzZSddLmluZGV4T2YoYWN0aW9uLmtleSkgPj0gMCkge1xuXHQgICAgICAgICAgYWN0aW9uLmtleSA9IEpTT04ucGFyc2UoYWN0aW9uLmtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBhY3Rpb25zXG5cdCAgICB9XG5cdCAgfSxcblxuXHQgIG1ldGhvZHM6IHtcblx0ICAgIHRyaWdnZXIgKG5hbWUpIHtcblx0ICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25saXN0LmZpbmQoYWN0aW9uID0+IGFjdGlvbi5rZXkgPT09IG5hbWUpO1xuXHQgICAgICBpZiAoYWN0aW9uICYmICF0aGlzLmlzQWN0aW9uRGlzYWJsZWQoYWN0aW9uKSAmJiB0aGlzLmlzQWN0aW9uVmlzaWJsZShhY3Rpb24pKSB7XG5cdCAgICAgICAgdGhpcy5vbkFjdGlvbkNsaWNrKGFjdGlvbik7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBzZXRMb2FkaW5nVG9JbnN0YW5jZSAodm0sIHZhbHVlKSB7XG5cdCAgICAgIGlmICh2bSAmJiB2bS5sb2FkaW5nICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICB2bS5sb2FkaW5nID0gdmFsdWU7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBzZXRMb2FkaW5nU3RhdGUgKHZhbHVlKSB7XG5cdCAgICAgIHRoaXMuJGVtaXQoJ2xvYWRpbmcnLCB2YWx1ZSk7XG5cdCAgICAgICF2YWx1ZSAmJiAodGhpcy5sb2FkaW5nQWN0aW9uID0gbnVsbCk7XG5cdCAgICAgIHRoaXMuc2V0TG9hZGluZ1RvSW5zdGFuY2UodGhpcy4kcm9vdCwgdmFsdWUpO1xuXHQgICAgICB0aGlzLnNldExvYWRpbmdUb0luc3RhbmNlKHRoaXMuJHJvb3QuX2RpYWxvZ0luc3RhbmNlLCB2YWx1ZSk7XG5cdCAgICB9LFxuXHQgICAgaXNBY3Rpb25EaXNhYmxlZCAoYWN0aW9uKSB7XG5cdCAgICAgIGlmIChhY3Rpb24uZGlzYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZVxuXHQgICAgICB9XG5cdCAgICAgIGlmICh0eXBlb2YgYWN0aW9uLmRpc2FibGVkID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIGFjdGlvbi5kaXNhYmxlZCgpXG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIGFjdGlvbi5kaXNhYmxlZFxuXHQgICAgfSxcblx0ICAgIGlzQWN0aW9uVmlzaWJsZSAoYWN0aW9uKSB7XG5cdCAgICAgIGlmIChhY3Rpb24udmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWVcblx0ICAgICAgfVxuXHQgICAgICBpZiAodHlwZW9mIGFjdGlvbi52aXNpYmxlID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgcmV0dXJuIGFjdGlvbi52aXNpYmxlKClcblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gYWN0aW9uLnZpc2libGVcblx0ICAgIH0sXG5cdCAgICBhc3luYyBvbkFjdGlvbkNsaWNrIChhY3Rpb24pIHtcblx0ICAgICAgY29uc3QgY2xvc2FibGUgPSBhY3Rpb24uY2xvc2FibGUgPT09IHVuZGVmaW5lZCB8fCBhY3Rpb24uY2xvc2FibGUgPT09IHRydWU7XG5cdCAgICAgIGlmIChhY3Rpb24uaGFuZGxlKSB7XG5cdCAgICAgICAgdGhpcy5sb2FkaW5nQWN0aW9uID0gYWN0aW9uLmtleTtcblx0ICAgICAgICB0aGlzLnNldExvYWRpbmdTdGF0ZSh0cnVlKTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgbGV0IHJldCA9IGF3YWl0IGFjdGlvbi5oYW5kbGUoKTtcblx0ICAgICAgICAgIHRoaXMuc2V0TG9hZGluZ1N0YXRlKGZhbHNlKTtcblx0ICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlICYmIGNsb3NhYmxlKSB7XG5cdCAgICAgICAgICAgIHRoaXMucmV0dXJuKHJldCB8fCBhY3Rpb24ua2V5KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICB0aGlzLnNldExvYWRpbmdTdGF0ZShmYWxzZSk7XG5cdCAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InLCBlKTsgLy8gVE9ET1xuXHQgICAgICAgICAgdGhyb3cgZVxuXHQgICAgICAgIH1cblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjbG9zYWJsZSAmJiB0aGlzLnJldHVybihhY3Rpb24ua2V5KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdC8vXG5cdC8vXG5cdC8vXG5cdC8vXG5cdC8vXG5cdC8vXG5cdC8vXG5cdC8vXG5cdHZhciBzY3JpcHQgPSB7XG5cdCAgbmFtZTogJ0JlYXRMb2FkZXInLFxuXHQgIHByb3BzOiB7XG5cdCAgICBsb2FkaW5nOiB7XG5cdCAgICAgIHR5cGU6IEJvb2xlYW4sXG5cdCAgICAgIGRlZmF1bHQ6IHRydWVcblx0ICAgIH0sXG5cdCAgICBjb2xvcjoge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIGRlZmF1bHQ6ICcjNWRjNTk2J1xuXHQgICAgfSxcblx0ICAgIHNpemU6IHtcblx0ICAgICAgdHlwZTogU3RyaW5nLFxuXHQgICAgICBkZWZhdWx0OiAnMTVweCdcblx0ICAgIH0sXG5cdCAgICBtYXJnaW46IHtcblx0ICAgICAgdHlwZTogU3RyaW5nLFxuXHQgICAgICBkZWZhdWx0OiAnMnB4J1xuXHQgICAgfSxcblx0ICAgIHJhZGl1czoge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIGRlZmF1bHQ6ICcxMDAlJ1xuXHQgICAgfVxuXHQgIH0sXG5cblx0ICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgc3Bpbm5lclN0eWxlOiB7XG5cdCAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmNvbG9yLFxuXHQgICAgICAgIGhlaWdodDogdGhpcy5zaXplLFxuXHQgICAgICAgIHdpZHRoOiB0aGlzLnNpemUsXG5cdCAgICAgICAgbWFyZ2luOiB0aGlzLm1hcmdpbixcblx0ICAgICAgICBib3JkZXJSYWRpdXM6IHRoaXMucmFkaXVzXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXG5cdH07XG5cblx0Lyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyA9IHNjcmlwdDtcblx0ICAgICAgICAgICAgXG5cdC8qIHRlbXBsYXRlICovXG5cdHZhciBfX3Z1ZV9yZW5kZXJfXyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBfdm0gPSB0aGlzO1xuXHQgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgcmV0dXJuIF9jKFxuXHQgICAgXCJkaXZcIixcblx0ICAgIHtcblx0ICAgICAgZGlyZWN0aXZlczogW1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuXHQgICAgICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcblx0ICAgICAgICAgIHZhbHVlOiBfdm0ubG9hZGluZyxcblx0ICAgICAgICAgIGV4cHJlc3Npb246IFwibG9hZGluZ1wiXG5cdCAgICAgICAgfVxuXHQgICAgICBdLFxuXHQgICAgICBzdGF0aWNDbGFzczogXCJ2LXNwaW5uZXJcIlxuXHQgICAgfSxcblx0ICAgIFtcblx0ICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ2LWJlYXQgdi1iZWF0LW9kZFwiLCBzdHlsZTogX3ZtLnNwaW5uZXJTdHlsZSB9KSxcblx0ICAgICAgX3ZtLl92KFwiIFwiKSxcblx0ICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ2LWJlYXQgdi1iZWF0LWV2ZW5cIiwgc3R5bGU6IF92bS5zcGlubmVyU3R5bGUgfSksXG5cdCAgICAgIF92bS5fdihcIiBcIiksXG5cdCAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidi1iZWF0IHYtYmVhdC1vZGRcIiwgc3R5bGU6IF92bS5zcGlubmVyU3R5bGUgfSlcblx0ICAgIF1cblx0ICApXG5cdH07XG5cdHZhciBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyA9IFtdO1xuXHRfX3Z1ZV9yZW5kZXJfXy5fd2l0aFN0cmlwcGVkID0gdHJ1ZTtcblxuXHQgIC8qIHN0eWxlICovXG5cdCAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyA9IGZ1bmN0aW9uIChpbmplY3QpIHtcblx0ICAgIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG5cdCAgICBpbmplY3QoXCJkYXRhLXYtNzkyOWFhNzJfMFwiLCB7IHNvdXJjZTogXCJcXG4udi1zcGlubmVyIC52LWJlYXRcXG57XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uOiB2LWJlYXRTdHJldGNoRGVsYXkgMC43cyBpbmZpbml0ZSBsaW5lYXI7XFxuICAgICAgICAgICAgYW5pbWF0aW9uOiB2LWJlYXRTdHJldGNoRGVsYXkgMC43cyBpbmZpbml0ZSBsaW5lYXI7XFxuICAgIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gICAgICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoO1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi52LXNwaW5uZXIgLnYtYmVhdC1vZGRcXG57XFxuICBhbmltYXRpb24tZGVsYXk6IDBzO1xcbn1cXG4udi1zcGlubmVyIC52LWJlYXQtZXZlblxcbntcXG4gIGFuaW1hdGlvbi1kZWxheTogMC4zNXM7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyB2LWJlYXRTdHJldGNoRGVsYXlcXG57XFxuNTAlXFxuICAgIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcXG4gICAgICAgIC13ZWJraXQtb3BhY2l0eTogMC4yO1xcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjI7XFxufVxcbjEwMCVcXG4gICAge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgLXdlYmtpdC1vcGFjaXR5OiAxO1xcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xcbn1cXG59XFxuQGtleWZyYW1lcyB2LWJlYXRTdHJldGNoRGVsYXlcXG57XFxuNTAlXFxuICAgIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcXG4gICAgICAgIC13ZWJraXQtb3BhY2l0eTogMC4yO1xcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjI7XFxufVxcbjEwMCVcXG4gICAge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEpO1xcbiAgICAgICAgLXdlYmtpdC1vcGFjaXR5OiAxO1xcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxO1xcbn1cXG59XFxuXCIsIG1hcDoge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL1VzZXJzL3lhcmlrL1Byb2plY3RzL2Nsb25lcy9ib290c3RyYXAtdnVlLWRpYWxvZy9zcmMvY29tcG9uZW50cy9Mb2FkZXIudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFtREE7O0lBRUEsMkRBQUE7WUFDQSxtREFBQTtJQUNBLGtDQUFBO1lBQ0EsMEJBQUE7SUFDQSxzQkFBQTtDQUNBO0FBRUE7O0VBRUEsb0JBQUE7Q0FDQTtBQUNBOztFQUVBLHVCQUFBO0NBQ0E7QUFFQTs7QUFFQTs7UUFFQSwrQkFBQTtnQkFDQSx1QkFBQTtRQUNBLHFCQUFBO2dCQUNBLGFBQUE7Q0FDQTtBQUNBOztRQUVBLDRCQUFBO2dCQUNBLG9CQUFBO1FBQ0EsbUJBQUE7Z0JBQ0EsV0FBQTtDQUNBO0NBQ0E7QUFFQTs7QUFFQTs7UUFFQSwrQkFBQTtnQkFDQSx1QkFBQTtRQUNBLHFCQUFBO2dCQUNBLGFBQUE7Q0FDQTtBQUNBOztRQUVBLDRCQUFBO2dCQUNBLG9CQUFBO1FBQ0EsbUJBQUE7Z0JBQ0EsV0FBQTtDQUNBO0NBQ0FcIixcImZpbGVcIjpcIkxvYWRlci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwidi1zcGlubmVyXFxcIiB2LXNob3c9XFxcImxvYWRpbmdcXFwiPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ2LWJlYXQgdi1iZWF0LW9kZFxcXCIgOnN0eWxlPVxcXCJzcGlubmVyU3R5bGVcXFwiLz5cXG4gICAgPGRpdiBjbGFzcz1cXFwidi1iZWF0IHYtYmVhdC1ldmVuXFxcIiA6c3R5bGU9XFxcInNwaW5uZXJTdHlsZVxcXCIvPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ2LWJlYXQgdi1iZWF0LW9kZFxcXCIgOnN0eWxlPVxcXCJzcGlubmVyU3R5bGVcXFwiLz5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICBuYW1lOiAnQmVhdExvYWRlcicsXFxuXFxuICBwcm9wczoge1xcbiAgICBsb2FkaW5nOiB7XFxuICAgICAgdHlwZTogQm9vbGVhbixcXG4gICAgICBkZWZhdWx0OiB0cnVlXFxuICAgIH0sXFxuICAgIGNvbG9yOiB7XFxuICAgICAgdHlwZTogU3RyaW5nLFxcbiAgICAgIGRlZmF1bHQ6ICcjNWRjNTk2J1xcbiAgICB9LFxcbiAgICBzaXplOiB7XFxuICAgICAgdHlwZTogU3RyaW5nLFxcbiAgICAgIGRlZmF1bHQ6ICcxNXB4J1xcbiAgICB9LFxcbiAgICBtYXJnaW46IHtcXG4gICAgICB0eXBlOiBTdHJpbmcsXFxuICAgICAgZGVmYXVsdDogJzJweCdcXG4gICAgfSxcXG4gICAgcmFkaXVzOiB7XFxuICAgICAgdHlwZTogU3RyaW5nLFxcbiAgICAgIGRlZmF1bHQ6ICcxMDAlJ1xcbiAgICB9XFxuICB9LFxcbiAgZGF0YSAoKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgc3Bpbm5lclN0eWxlOiB7XFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY29sb3IsXFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZSxcXG4gICAgICAgIHdpZHRoOiB0aGlzLnNpemUsXFxuICAgICAgICBtYXJnaW46IHRoaXMubWFyZ2luLFxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiB0aGlzLnJhZGl1c1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbn1cXG48L3NjcmlwdD5cXG5cXG48c3R5bGU+XFxuXFxuLnYtc3Bpbm5lciAudi1iZWF0XFxue1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbjogdi1iZWF0U3RyZXRjaERlbGF5IDAuN3MgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICAgIGFuaW1hdGlvbjogdi1iZWF0U3RyZXRjaERlbGF5IDAuN3MgaW5maW5pdGUgbGluZWFyO1xcbiAgICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxuICAgICAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4udi1zcGlubmVyIC52LWJlYXQtb2RkXFxue1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAwcztcXG59XFxuLnYtc3Bpbm5lciAudi1iZWF0LWV2ZW5cXG57XFxuICBhbmltYXRpb24tZGVsYXk6IDAuMzVzO1xcbn1cXG5cXG5ALXdlYmtpdC1rZXlmcmFtZXMgdi1iZWF0U3RyZXRjaERlbGF5XFxue1xcbiAgICA1MCVcXG4gICAge1xcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDAuNzUpO1xcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuNzUpO1xcbiAgICAgICAgLXdlYmtpdC1vcGFjaXR5OiAwLjI7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMjtcXG4gICAgfVxcbiAgICAxMDAlXFxuICAgIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcXG4gICAgICAgIC13ZWJraXQtb3BhY2l0eTogMTtcXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgfVxcbn1cXG5cXG5Aa2V5ZnJhbWVzIHYtYmVhdFN0cmV0Y2hEZWxheVxcbntcXG4gICAgNTAlXFxuICAgIHtcXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjc1KTtcXG4gICAgICAgIC13ZWJraXQtb3BhY2l0eTogMC4yO1xcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjI7XFxuICAgIH1cXG4gICAgMTAwJVxcbiAgICB7XFxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSk7XFxuICAgICAgICAtd2Via2l0LW9wYWNpdHk6IDE7XFxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDE7XFxuICAgIH1cXG59XFxuPC9zdHlsZT5cXG5cIl19LCBtZWRpYTogdW5kZWZpbmVkIH0pO1xuXG5cdCAgfTtcblx0ICAvKiBzY29wZWQgKi9cblx0ICB2YXIgX192dWVfc2NvcGVfaWRfXyA9IHVuZGVmaW5lZDtcblx0ICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuXHQgIHZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gdW5kZWZpbmVkO1xuXHQgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fID0gZmFsc2U7XG5cdCAgLyogY29tcG9uZW50IG5vcm1hbGl6ZXIgKi9cblx0ICBmdW5jdGlvbiBfX3Z1ZV9ub3JtYWxpemVfXyhcblx0ICAgIHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0JCQxLFxuXHQgICAgc2NvcGUsIGZ1bmN0aW9uYWwsIG1vZHVsZUlkZW50aWZpZXIsXG5cdCAgICBjcmVhdGVJbmplY3RvciwgY3JlYXRlSW5qZWN0b3JTU1Jcblx0ICApIHtcblx0ICAgIHZhciBjb21wb25lbnQgPSAodHlwZW9mIHNjcmlwdCQkMSA9PT0gJ2Z1bmN0aW9uJyA/IHNjcmlwdCQkMS5vcHRpb25zIDogc2NyaXB0JCQxKSB8fCB7fTtcblxuXHQgICAgLy8gRm9yIHNlY3VyaXR5IGNvbmNlcm5zLCB3ZSB1c2Ugb25seSBiYXNlIG5hbWUgaW4gcHJvZHVjdGlvbiBtb2RlLlxuXHQgICAgY29tcG9uZW50Ll9fZmlsZSA9IFwiL1VzZXJzL3lhcmlrL1Byb2plY3RzL2Nsb25lcy9ib290c3RyYXAtdnVlLWRpYWxvZy9zcmMvY29tcG9uZW50cy9Mb2FkZXIudnVlXCI7XG5cblx0ICAgIGlmICghY29tcG9uZW50LnJlbmRlcikge1xuXHQgICAgICBjb21wb25lbnQucmVuZGVyID0gdGVtcGxhdGUucmVuZGVyO1xuXHQgICAgICBjb21wb25lbnQuc3RhdGljUmVuZGVyRm5zID0gdGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuXHQgICAgICBjb21wb25lbnQuX2NvbXBpbGVkID0gdHJ1ZTtcblxuXHQgICAgICBpZiAoZnVuY3Rpb25hbCkgeyBjb21wb25lbnQuZnVuY3Rpb25hbCA9IHRydWU7IH1cblx0ICAgIH1cblxuXHQgICAgY29tcG9uZW50Ll9zY29wZUlkID0gc2NvcGU7XG5cblx0ICAgIHtcblx0ICAgICAgdmFyIGhvb2s7XG5cdCAgICAgIGlmIChzdHlsZSkge1xuXHQgICAgICAgIGhvb2sgPSBmdW5jdGlvbihjb250ZXh0KSB7XG5cdCAgICAgICAgICBzdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yKGNvbnRleHQpKTtcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGhvb2sgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIGlmIChjb21wb25lbnQuZnVuY3Rpb25hbCkge1xuXHQgICAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG5cdCAgICAgICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBjb21wb25lbnQucmVuZGVyO1xuXHQgICAgICAgICAgY29tcG9uZW50LnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbihoLCBjb250ZXh0KSB7XG5cdCAgICAgICAgICAgIGhvb2suY2FsbChjb250ZXh0KTtcblx0ICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG5cdCAgICAgICAgICB9O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuXHQgICAgICAgICAgdmFyIGV4aXN0aW5nID0gY29tcG9uZW50LmJlZm9yZUNyZWF0ZTtcblx0ICAgICAgICAgIGNvbXBvbmVudC5iZWZvcmVDcmVhdGUgPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaykgOiBbaG9va107XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBjb21wb25lbnRcblx0ICB9XG5cdCAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgZnVuY3Rpb24gX192dWVfY3JlYXRlX2luamVjdG9yX18oKSB7XG5cdCAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0ICAgIHZhciBzdHlsZXMgPSBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXy5zdHlsZXMgfHwgKF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fLnN0eWxlcyA9IHt9KTtcblx0ICAgIHZhciBpc09sZElFID1cblx0ICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICAgICAgL21zaWUgWzYtOV1cXFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXG5cdCAgICByZXR1cm4gZnVuY3Rpb24gYWRkU3R5bGUoaWQsIGNzcykge1xuXHQgICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBpZCArICdcIl0nKSkgeyByZXR1cm4gfSAvLyBTU1Igc3R5bGVzIGFyZSBwcmVzZW50LlxuXG5cdCAgICAgIHZhciBncm91cCA9IGlzT2xkSUUgPyBjc3MubWVkaWEgfHwgJ2RlZmF1bHQnIDogaWQ7XG5cdCAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tncm91cF0gfHwgKHN0eWxlc1tncm91cF0gPSB7IGlkczogW10sIHBhcnRzOiBbXSwgZWxlbWVudDogdW5kZWZpbmVkIH0pO1xuXG5cdCAgICAgIGlmICghc3R5bGUuaWRzLmluY2x1ZGVzKGlkKSkge1xuXHQgICAgICAgIHZhciBjb2RlID0gY3NzLnNvdXJjZTtcblx0ICAgICAgICB2YXIgaW5kZXggPSBzdHlsZS5pZHMubGVuZ3RoO1xuXG5cdCAgICAgICAgc3R5bGUuaWRzLnB1c2goaWQpO1xuXG5cdCAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgIHN0eWxlLmVsZW1lbnQgPSBzdHlsZS5lbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtZ3JvdXA9JyArIGdyb3VwICsgJ10nKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXN0eWxlLmVsZW1lbnQpIHtcblx0ICAgICAgICAgIHZhciBlbCA9IHN0eWxlLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHQgICAgICAgICAgZWwudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cblx0ICAgICAgICAgIGlmIChjc3MubWVkaWEpIHsgZWwuc2V0QXR0cmlidXRlKCdtZWRpYScsIGNzcy5tZWRpYSk7IH1cblx0ICAgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1ncm91cCcsIGdyb3VwKTtcblx0ICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnLCAnMCcpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKGVsKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgaW5kZXggPSBwYXJzZUludChzdHlsZS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JykpO1xuXHQgICAgICAgICAgc3R5bGUuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsIGluZGV4ICsgMSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHN0eWxlLmVsZW1lbnQuc3R5bGVTaGVldCkge1xuXHQgICAgICAgICAgc3R5bGUucGFydHMucHVzaChjb2RlKTtcblx0ICAgICAgICAgIHN0eWxlLmVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gc3R5bGUucGFydHNcblx0ICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuXHQgICAgICAgICAgICAuam9pbignXFxuJyk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvZGUpO1xuXHQgICAgICAgICAgdmFyIG5vZGVzID0gc3R5bGUuZWxlbWVudC5jaGlsZE5vZGVzO1xuXHQgICAgICAgICAgaWYgKG5vZGVzW2luZGV4XSkgeyBzdHlsZS5lbGVtZW50LnJlbW92ZUNoaWxkKG5vZGVzW2luZGV4XSk7IH1cblx0ICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGgpIHsgc3R5bGUuZWxlbWVudC5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGVzW2luZGV4XSk7IH1cblx0ICAgICAgICAgIGVsc2UgeyBzdHlsZS5lbGVtZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH1cblx0ICAvKiBzdHlsZSBpbmplY3QgU1NSICovXG5cdCAgXG5cblx0ICBcblx0ICB2YXIgTG9hZGVyID0gX192dWVfbm9ybWFsaXplX18oXG5cdCAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18sIHN0YXRpY1JlbmRlckZuczogX192dWVfc3RhdGljUmVuZGVyRm5zX18gfSxcblx0ICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyxcblx0ICAgIF9fdnVlX3NjcmlwdF9fLFxuXHQgICAgX192dWVfc2NvcGVfaWRfXyxcblx0ICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyxcblx0ICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18sXG5cdCAgICBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyxcblx0ICAgIHVuZGVmaW5lZFxuXHQgIClcblxuXHQvL1xuXHR2YXIgc2NyaXB0JDEgPSB7XG5cdCAgY29tcG9uZW50czoge1xuXHQgICAgTG9hZGVyOiBMb2FkZXJcblx0ICB9LFxuXHQgIG1peGluczogW0FjdGlvbmFibGVdLFxuXHQgIHByb3BzOiB7XG5cdCAgICB2YXJpYW50OiB7XG5cdCAgICAgIHR5cGU6IFN0cmluZyxcblx0ICAgICAgZGVmYXVsdDogJ291dGxpbmUtcHJpbWFyeSdcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0Lyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQxID0gc2NyaXB0JDE7XG5cdCAgICAgICAgICAgIFxuXHQvKiB0ZW1wbGF0ZSAqL1xuXHR2YXIgX192dWVfcmVuZGVyX18kMSA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBfdm0gPSB0aGlzO1xuXHQgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgcmV0dXJuIF9jKFxuXHQgICAgXCJzcGFuXCIsXG5cdCAgICB7IHN0YXRpY0NsYXNzOiBcImRpYWxvZy1hY3Rpb25zXCIgfSxcblx0ICAgIF92bS5fbChfdm0uYWN0aW9ubGlzdCwgZnVuY3Rpb24oYWN0aW9uKSB7XG5cdCAgICAgIHJldHVybiBfYyhcblx0ICAgICAgICBcImItYnRuXCIsXG5cdCAgICAgICAge1xuXHQgICAgICAgICAga2V5OiBhY3Rpb24ua2V5LFxuXHQgICAgICAgICAgYXR0cnM6IHtcblx0ICAgICAgICAgICAgdmFyaWFudDogYWN0aW9uLnZhcmlhbnQgfHwgX3ZtLnZhcmlhbnQsXG5cdCAgICAgICAgICAgIGxvYWRpbmc6IF92bS5sb2FkaW5nQWN0aW9uID09PSBhY3Rpb24ua2V5LFxuXHQgICAgICAgICAgICBkaXNhYmxlZDogX3ZtLmlzQWN0aW9uRGlzYWJsZWQoYWN0aW9uKSB8fCAhIV92bS5sb2FkaW5nQWN0aW9uXG5cdCAgICAgICAgICB9LFxuXHQgICAgICAgICAgb246IHtcblx0ICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuXHQgICAgICAgICAgICAgIF92bS5vbkFjdGlvbkNsaWNrKGFjdGlvbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIFtcblx0ICAgICAgICAgIF92bS5sb2FkaW5nQWN0aW9uID09PSBhY3Rpb24ua2V5XG5cdCAgICAgICAgICAgID8gX2MoXCJMb2FkZXJcIiwgeyBhdHRyczogeyBzaXplOiBcIjhweFwiIH0gfSlcblx0ICAgICAgICAgICAgOiBbX3ZtLl92KF92bS5fcyhhY3Rpb24udGV4dCkpXVxuXHQgICAgICAgIF0sXG5cdCAgICAgICAgMlxuXHQgICAgICApXG5cdCAgICB9KVxuXHQgIClcblx0fTtcblx0dmFyIF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDEgPSBbXTtcblx0X192dWVfcmVuZGVyX18kMS5fd2l0aFN0cmlwcGVkID0gdHJ1ZTtcblxuXHQgIC8qIHN0eWxlICovXG5cdCAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyQxID0gZnVuY3Rpb24gKGluamVjdCkge1xuXHQgICAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cblx0ICAgIGluamVjdChcImRhdGEtdi1iMDcyNTAxOF8wXCIsIHsgc291cmNlOiBcIlxcbi5kaWFsb2ctYWN0aW9ucyBidXR0b24ge1xcbiAgIG1hcmdpbi1yaWdodDogNHB4O1xcbiAgIG1hcmdpbi1yaWdodDogLjI1cmVtO1xcbn1cXG5cIiwgbWFwOiB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL2Jvb3RzdHJhcC12dWUtZGlhbG9nL3NyYy9jb21wb25lbnRzL0RpYWxvZ0FjdGlvbnMudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUErQkE7R0FDQSxrQkFBQTtHQUNBLHFCQUFBO0NBQ0FcIixcImZpbGVcIjpcIkRpYWxvZ0FjdGlvbnMudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxzcGFuIGNsYXNzPVxcXCJkaWFsb2ctYWN0aW9uc1xcXCI+XFxuICAgIDxiLWJ0biB2LWZvcj1cXFwiYWN0aW9uIGluIGFjdGlvbmxpc3RcXFwiIDprZXk9XFxcImFjdGlvbi5rZXlcXFwiXFxuICAgICAgOnZhcmlhbnQ9XFxcImFjdGlvbi52YXJpYW50IHx8IHZhcmlhbnRcXFwiXFxuICAgICAgOmxvYWRpbmc9XFxcImxvYWRpbmdBY3Rpb24gPT09IGFjdGlvbi5rZXlcXFwiXFxuICAgICAgOmRpc2FibGVkPVxcXCJpc0FjdGlvbkRpc2FibGVkKGFjdGlvbikgfHwgISFsb2FkaW5nQWN0aW9uXFxcIlxcbiAgICAgIEBjbGljaz1cXFwib25BY3Rpb25DbGljayhhY3Rpb24pXFxcIj5cXG4gICAgICA8TG9hZGVyIHYtaWY9XFxcImxvYWRpbmdBY3Rpb24gPT09IGFjdGlvbi5rZXlcXFwiIHNpemU9XFxcIjhweFxcXCIvPlxcbiAgICAgIDx0ZW1wbGF0ZSB2LWVsc2U+e3sgYWN0aW9uLnRleHQgfX08L3RlbXBsYXRlPlxcbiAgICA8L2ItYnRuPlxcbiAgPC9zcGFuPlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5cXG5pbXBvcnQgQWN0aW9uYWJsZSBmcm9tICd2dWVkbC9zcmMvbWl4aW5zL2FjdGlvbmFibGUnXFxuaW1wb3J0IExvYWRlciBmcm9tICcuL0xvYWRlci52dWUnXFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgY29tcG9uZW50czoge1xcbiAgICBMb2FkZXJcXG4gIH0sXFxuICBtaXhpbnM6IFsgQWN0aW9uYWJsZSBdLFxcbiAgcHJvcHM6IHtcXG4gICAgdmFyaWFudDoge1xcbiAgICAgIHR5cGU6IFN0cmluZyxcXG4gICAgICBkZWZhdWx0OiAnb3V0bGluZS1wcmltYXJ5J1xcbiAgICB9XFxuICB9XFxufVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4gIC5kaWFsb2ctYWN0aW9ucyBidXR0b24ge1xcbiAgICAgbWFyZ2luLXJpZ2h0OiA0cHg7XFxuICAgICBtYXJnaW4tcmlnaHQ6IC4yNXJlbTtcXG4gIH1cXG48L3N0eWxlPlxcblwiXX0sIG1lZGlhOiB1bmRlZmluZWQgfSk7XG5cblx0ICB9O1xuXHQgIC8qIHNjb3BlZCAqL1xuXHQgIHZhciBfX3Z1ZV9zY29wZV9pZF9fJDEgPSB1bmRlZmluZWQ7XG5cdCAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cblx0ICB2YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQxID0gdW5kZWZpbmVkO1xuXHQgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDEgPSBmYWxzZTtcblx0ICAvKiBjb21wb25lbnQgbm9ybWFsaXplciAqL1xuXHQgIGZ1bmN0aW9uIF9fdnVlX25vcm1hbGl6ZV9fJDEoXG5cdCAgICB0ZW1wbGF0ZSwgc3R5bGUsIHNjcmlwdCxcblx0ICAgIHNjb3BlLCBmdW5jdGlvbmFsLCBtb2R1bGVJZGVudGlmaWVyLFxuXHQgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgKSB7XG5cdCAgICB2YXIgY29tcG9uZW50ID0gKHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicgPyBzY3JpcHQub3B0aW9ucyA6IHNjcmlwdCkgfHwge307XG5cblx0ICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgIGNvbXBvbmVudC5fX2ZpbGUgPSBcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvYm9vdHN0cmFwLXZ1ZS1kaWFsb2cvc3JjL2NvbXBvbmVudHMvRGlhbG9nQWN0aW9ucy52dWVcIjtcblxuXHQgICAgaWYgKCFjb21wb25lbnQucmVuZGVyKSB7XG5cdCAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgIGNvbXBvbmVudC5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG5cdCAgICAgIGNvbXBvbmVudC5fY29tcGlsZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgfVxuXG5cdCAgICBjb21wb25lbnQuX3Njb3BlSWQgPSBzY29wZTtcblxuXHQgICAge1xuXHQgICAgICB2YXIgaG9vaztcblx0ICAgICAgaWYgKHN0eWxlKSB7XG5cdCAgICAgICAgaG9vayA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcblx0ICAgICAgICAgIHN0eWxlLmNhbGwodGhpcywgY3JlYXRlSW5qZWN0b3IoY29udGV4dCkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgaWYgKGNvbXBvbmVudC5mdW5jdGlvbmFsKSB7XG5cdCAgICAgICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcblx0ICAgICAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IGNvbXBvbmVudC5yZW5kZXI7XG5cdCAgICAgICAgICBjb21wb25lbnQucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uKGgsIGNvbnRleHQpIHtcblx0ICAgICAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpO1xuXHQgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG5cdCAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBjb21wb25lbnQuYmVmb3JlQ3JlYXRlO1xuXHQgICAgICAgICAgY29tcG9uZW50LmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKSA6IFtob29rXTtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGNvbXBvbmVudFxuXHQgIH1cblx0ICAvKiBzdHlsZSBpbmplY3QgKi9cblx0ICBmdW5jdGlvbiBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQxKCkge1xuXHQgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG5cdCAgICB2YXIgc3R5bGVzID0gX192dWVfY3JlYXRlX2luamVjdG9yX18kMS5zdHlsZXMgfHwgKF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDEuc3R5bGVzID0ge30pO1xuXHQgICAgdmFyIGlzT2xkSUUgPVxuXHQgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgICAgICAvbXNpZSBbNi05XVxcXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG5cblx0ICAgIHJldHVybiBmdW5jdGlvbiBhZGRTdHlsZShpZCwgY3NzKSB7XG5cdCAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIGlkICsgJ1wiXScpKSB7IHJldHVybiB9IC8vIFNTUiBzdHlsZXMgYXJlIHByZXNlbnQuXG5cblx0ICAgICAgdmFyIGdyb3VwID0gaXNPbGRJRSA/IGNzcy5tZWRpYSB8fCAnZGVmYXVsdCcgOiBpZDtcblx0ICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW2dyb3VwXSB8fCAoc3R5bGVzW2dyb3VwXSA9IHsgaWRzOiBbXSwgcGFydHM6IFtdLCBlbGVtZW50OiB1bmRlZmluZWQgfSk7XG5cblx0ICAgICAgaWYgKCFzdHlsZS5pZHMuaW5jbHVkZXMoaWQpKSB7XG5cdCAgICAgICAgdmFyIGNvZGUgPSBjc3Muc291cmNlO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHN0eWxlLmlkcy5sZW5ndGg7XG5cblx0ICAgICAgICBzdHlsZS5pZHMucHVzaChpZCk7XG5cblx0ICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgc3R5bGUuZWxlbWVudCA9IHN0eWxlLmVsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1ncm91cD0nICsgZ3JvdXAgKyAnXScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghc3R5bGUuZWxlbWVudCkge1xuXHQgICAgICAgICAgdmFyIGVsID0gc3R5bGUuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cdCAgICAgICAgICBlbC50eXBlID0gJ3RleHQvY3NzJztcblxuXHQgICAgICAgICAgaWYgKGNzcy5tZWRpYSkgeyBlbC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgY3NzLm1lZGlhKTsgfVxuXHQgICAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLWdyb3VwJywgZ3JvdXApO1xuXHQgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcsICcwJyk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoZWwpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KHN0eWxlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnKSk7XG5cdCAgICAgICAgICBzdHlsZS5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JywgaW5kZXggKyAxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc3R5bGUuZWxlbWVudC5zdHlsZVNoZWV0KSB7XG5cdCAgICAgICAgICBzdHlsZS5wYXJ0cy5wdXNoKGNvZGUpO1xuXHQgICAgICAgICAgc3R5bGUuZWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBzdHlsZS5wYXJ0c1xuXHQgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG5cdCAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29kZSk7XG5cdCAgICAgICAgICB2YXIgbm9kZXMgPSBzdHlsZS5lbGVtZW50LmNoaWxkTm9kZXM7XG5cdCAgICAgICAgICBpZiAobm9kZXNbaW5kZXhdKSB7IHN0eWxlLmVsZW1lbnQucmVtb3ZlQ2hpbGQobm9kZXNbaW5kZXhdKTsgfVxuXHQgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCkgeyBzdHlsZS5lbGVtZW50Lmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgbm9kZXNbaW5kZXhdKTsgfVxuXHQgICAgICAgICAgZWxzZSB7IHN0eWxlLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpOyB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfVxuXHQgIC8qIHN0eWxlIGluamVjdCBTU1IgKi9cblx0ICBcblxuXHQgIFxuXHQgIHZhciBEaWFsb2dBY3Rpb25zID0gX192dWVfbm9ybWFsaXplX18kMShcblx0ICAgIHsgcmVuZGVyOiBfX3Z1ZV9yZW5kZXJfXyQxLCBzdGF0aWNSZW5kZXJGbnM6IF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDEgfSxcblx0ICAgIF9fdnVlX2luamVjdF9zdHlsZXNfXyQxLFxuXHQgICAgX192dWVfc2NyaXB0X18kMSxcblx0ICAgIF9fdnVlX3Njb3BlX2lkX18kMSxcblx0ICAgIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQxLFxuXHQgICAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQxLFxuXHQgICAgX192dWVfY3JlYXRlX2luamVjdG9yX18kMSxcblx0ICAgIHVuZGVmaW5lZFxuXHQgIClcblxuXHQvL1xuXHR2YXIgekluZGV4ID0gMTEwMDtcblx0dmFyIHNjcmlwdCQyID0ge1xuXHQgIGNvbXBvbmVudHM6IHtcblx0ICAgIERpYWxvZ0FjdGlvbnM6IERpYWxvZ0FjdGlvbnNcblx0ICB9LFxuXHQgIHByb3BzOiB7XG5cdCAgICBzaXplOiB7XG5cdCAgICAgIHR5cGU6IFN0cmluZyxcblx0ICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICdtZCc7XG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICB0aXRsZTogU3RyaW5nLFxuXHQgICAgYWN0aW9uczogW0FycmF5LCBPYmplY3RdLFxuXHQgICAgaGlkZUJhY2tkcm9wOiBCb29sZWFuLFxuXHQgICAgY2VudGVyZWQ6IEJvb2xlYW5cblx0ICB9LFxuXHQgIG1ldGhvZHM6IHtcblx0ICAgIF9kZXN0cm95OiBmdW5jdGlvbiBfZGVzdHJveSgpIHsvLyBzdHViXG5cdCAgICB9LFxuXG5cdCAgICBvbk1vZGFsSGlkZGVuOiBmdW5jdGlvbiBvbk1vZGFsSGlkZGVuKCkge1xuXHQgICAgICB6SW5kZXggPSB6SW5kZXggLSAyO1xuXHQgICAgICB0aGlzLiRkZXN0cm95KCk7XG5cdCAgICB9LFxuXG5cdCAgICBvbk1vZGFsU2hvd246IGZ1bmN0aW9uIG9uTW9kYWxTaG93bihldikge1xuXHQgICAgICB2YXIgcGFyZW50ID0gZXYudGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG5cdCAgICAgIHZhciBiYWNrZHJvcCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwtYmFja2Ryb3AnKTtcblx0ICAgICAgYmFja2Ryb3AgJiYgYmFja2Ryb3Auc3R5bGUgJiYgKGJhY2tkcm9wLnN0eWxlWyd6LWluZGV4J10gPSArK3pJbmRleCk7XG5cdCAgICAgIHZhciBtb2RhbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKCcubW9kYWwnKTtcblx0ICAgICAgbW9kYWwgJiYgbW9kYWwuc3R5bGUgJiYgKG1vZGFsLnN0eWxlWyd6LWluZGV4J10gPSArK3pJbmRleCk7XG5cdCAgICB9XG5cblx0ICB9XG5cdH07XG5cblx0Lyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQyID0gc2NyaXB0JDI7XG5cdCAgICAgICAgICAgIFxuXHQvKiB0ZW1wbGF0ZSAqL1xuXHR2YXIgX192dWVfcmVuZGVyX18kMiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBfdm0gPSB0aGlzO1xuXHQgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgcmV0dXJuIF9jKFxuXHQgICAgXCJiLW1vZGFsXCIsXG5cdCAgICB7XG5cdCAgICAgIHN0YXRpY0NsYXNzOiBcImRpYWxvZy1sYXlvdXRcIixcblx0ICAgICAgYXR0cnM6IHtcblx0ICAgICAgICBcImhpZGUtaGVhZGVyXCI6IFwiXCIsXG5cdCAgICAgICAgXCJoaWRlLWZvb3RlclwiOiBcIlwiLFxuXHQgICAgICAgIFwiaGlkZS1iYWNrZHJvcFwiOiBfdm0uaGlkZUJhY2tkcm9wLFxuXHQgICAgICAgIGNlbnRlcmVkOiBfdm0uY2VudGVyZWQsXG5cdCAgICAgICAgc2l6ZTogX3ZtLnNpemUsXG5cdCAgICAgICAgXCJib2R5LWNsYXNzXCI6IFwiZGlhbG9nLWxheW91dC1tb2RhbC1ib2R5XCIsXG5cdCAgICAgICAgXCJuby1jbG9zZS1vbi1iYWNrZHJvcFwiOiBfdm0ucGVyc2lzdGVudCB8fCBfdm0ubG9hZGluZyxcblx0ICAgICAgICBcIm5vLWNsb3NlLW9uLWVzY1wiOiBfdm0ucGVyc2lzdGVudCB8fCBfdm0ubG9hZGluZ1xuXHQgICAgICB9LFxuXHQgICAgICBvbjogeyBoaWRkZW46IF92bS5vbk1vZGFsSGlkZGVuLCBzaG93bjogX3ZtLm9uTW9kYWxTaG93biB9LFxuXHQgICAgICBtb2RlbDoge1xuXHQgICAgICAgIHZhbHVlOiBfdm0uaXNBY3RpdmUsXG5cdCAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCQkdikge1xuXHQgICAgICAgICAgX3ZtLmlzQWN0aXZlID0gJCR2O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZXhwcmVzc2lvbjogXCJpc0FjdGl2ZVwiXG5cdCAgICAgIH1cblx0ICAgIH0sXG5cdCAgICBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sXG5cdCAgICAyXG5cdCAgKVxuXHR9O1xuXHR2YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18kMiA9IFtdO1xuXHRfX3Z1ZV9yZW5kZXJfXyQyLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuXG5cdCAgLyogc3R5bGUgKi9cblx0ICB2YXIgX192dWVfaW5qZWN0X3N0eWxlc19fJDIgPSBmdW5jdGlvbiAoaW5qZWN0KSB7XG5cdCAgICBpZiAoIWluamVjdCkgeyByZXR1cm4gfVxuXHQgICAgaW5qZWN0KFwiZGF0YS12LTBmNzY0ODcyXzBcIiwgeyBzb3VyY2U6IFwiXFxuLmRpYWxvZy1sYXlvdXQtbW9kYWwtYm9keSB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cIiwgbWFwOiB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL2Jvb3RzdHJhcC12dWUtZGlhbG9nL3NyYy9jb21wb25lbnRzL0RpYWxvZ0xheW91dC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXdEQTtFQUNBLFdBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiRGlhbG9nTGF5b3V0LnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8Yi1tb2RhbCB2LW1vZGVsPVxcXCJpc0FjdGl2ZVxcXCJcXG4gICAgY2xhc3M9XFxcImRpYWxvZy1sYXlvdXRcXFwiXFxuICAgIGhpZGUtaGVhZGVyXFxuICAgIGhpZGUtZm9vdGVyXFxuICAgIDpoaWRlLWJhY2tkcm9wPVxcXCJoaWRlQmFja2Ryb3BcXFwiXFxuICAgIDpjZW50ZXJlZD1cXFwiY2VudGVyZWRcXFwiXFxuICAgIDpzaXplPVxcXCJzaXplXFxcIlxcbiAgICBib2R5LWNsYXNzPVxcXCJkaWFsb2ctbGF5b3V0LW1vZGFsLWJvZHlcXFwiXFxuICAgIDpuby1jbG9zZS1vbi1iYWNrZHJvcD1cXFwicGVyc2lzdGVudCB8fCBsb2FkaW5nXFxcIlxcbiAgICA6bm8tY2xvc2Utb24tZXNjPVxcXCJwZXJzaXN0ZW50IHx8IGxvYWRpbmdcXFwiXFxuICAgIEBoaWRkZW49XFxcIm9uTW9kYWxIaWRkZW5cXFwiXFxuICAgIEBzaG93bj1cXFwib25Nb2RhbFNob3duXFxcIj5cXG4gICAgPHNsb3QvPlxcbiAgPC9iLW1vZGFsPlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5cXG5pbXBvcnQgRGlhbG9nQWN0aW9ucyBmcm9tICcuL0RpYWxvZ0FjdGlvbnMudnVlJ1xcblxcbmxldCB6SW5kZXggPSAxMTAwXFxuXFxuZXhwb3J0IGRlZmF1bHQge1xcbiAgY29tcG9uZW50czoge1xcbiAgICBEaWFsb2dBY3Rpb25zXFxuICB9LFxcbiAgcHJvcHM6IHtcXG4gICAgc2l6ZToge1xcbiAgICAgIHR5cGU6IFN0cmluZyxcXG4gICAgICBkZWZhdWx0OiAoKSA9PiB7ICdtZCcgfVxcbiAgICB9LFxcbiAgICB0aXRsZTogU3RyaW5nLFxcbiAgICBhY3Rpb25zOiBbQXJyYXksIE9iamVjdF0sXFxuICAgIGhpZGVCYWNrZHJvcDogQm9vbGVhbixcXG4gICAgY2VudGVyZWQ6IEJvb2xlYW5cXG4gIH0sXFxuICBtZXRob2RzOiB7XFxuICAgIF9kZXN0cm95ICgpIHtcXG4gICAgICAvLyBzdHViXFxuICAgIH0sXFxuICAgIG9uTW9kYWxIaWRkZW4gKCkge1xcbiAgICAgIHpJbmRleCA9IHpJbmRleCAtIDJcXG4gICAgICB0aGlzLiRkZXN0cm95KClcXG4gICAgfSxcXG4gICAgb25Nb2RhbFNob3duIChldikge1xcbiAgICAgIGNvbnN0IHBhcmVudCA9IGV2LnRhcmdldC5wYXJlbnRFbGVtZW50XFxuICAgICAgY29uc3QgYmFja2Ryb3AgPSBwYXJlbnQucXVlcnlTZWxlY3RvcignLm1vZGFsLWJhY2tkcm9wJylcXG4gICAgICBiYWNrZHJvcCAmJiBiYWNrZHJvcC5zdHlsZSAmJiAoYmFja2Ryb3Auc3R5bGVbJ3otaW5kZXgnXSA9ICsrekluZGV4KVxcbiAgICAgIGNvbnN0IG1vZGFsID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5tb2RhbCcpXFxuICAgICAgbW9kYWwgJiYgbW9kYWwuc3R5bGUgJiYgKG1vZGFsLnN0eWxlWyd6LWluZGV4J10gPSArK3pJbmRleClcXG4gICAgfVxcbiAgfVxcbn1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuICAuZGlhbG9nLWxheW91dC1tb2RhbC1ib2R5IHtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG48L3N0eWxlPlxcblwiXX0sIG1lZGlhOiB1bmRlZmluZWQgfSk7XG5cblx0ICB9O1xuXHQgIC8qIHNjb3BlZCAqL1xuXHQgIHZhciBfX3Z1ZV9zY29wZV9pZF9fJDIgPSB1bmRlZmluZWQ7XG5cdCAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cblx0ICB2YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQyID0gdW5kZWZpbmVkO1xuXHQgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDIgPSBmYWxzZTtcblx0ICAvKiBjb21wb25lbnQgbm9ybWFsaXplciAqL1xuXHQgIGZ1bmN0aW9uIF9fdnVlX25vcm1hbGl6ZV9fJDIoXG5cdCAgICB0ZW1wbGF0ZSwgc3R5bGUsIHNjcmlwdCxcblx0ICAgIHNjb3BlLCBmdW5jdGlvbmFsLCBtb2R1bGVJZGVudGlmaWVyLFxuXHQgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgKSB7XG5cdCAgICB2YXIgY29tcG9uZW50ID0gKHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicgPyBzY3JpcHQub3B0aW9ucyA6IHNjcmlwdCkgfHwge307XG5cblx0ICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgIGNvbXBvbmVudC5fX2ZpbGUgPSBcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvYm9vdHN0cmFwLXZ1ZS1kaWFsb2cvc3JjL2NvbXBvbmVudHMvRGlhbG9nTGF5b3V0LnZ1ZVwiO1xuXG5cdCAgICBpZiAoIWNvbXBvbmVudC5yZW5kZXIpIHtcblx0ICAgICAgY29tcG9uZW50LnJlbmRlciA9IHRlbXBsYXRlLnJlbmRlcjtcblx0ICAgICAgY29tcG9uZW50LnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICAgICAgY29tcG9uZW50Ll9jb21waWxlZCA9IHRydWU7XG5cblx0ICAgICAgaWYgKGZ1bmN0aW9uYWwpIHsgY29tcG9uZW50LmZ1bmN0aW9uYWwgPSB0cnVlOyB9XG5cdCAgICB9XG5cblx0ICAgIGNvbXBvbmVudC5fc2NvcGVJZCA9IHNjb3BlO1xuXG5cdCAgICB7XG5cdCAgICAgIHZhciBob29rO1xuXHQgICAgICBpZiAoc3R5bGUpIHtcblx0ICAgICAgICBob29rID0gZnVuY3Rpb24oY29udGV4dCkge1xuXHQgICAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3Rvcihjb250ZXh0KSk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICBpZiAoY29tcG9uZW50LmZ1bmN0aW9uYWwpIHtcblx0ICAgICAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvbmFsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuXHQgICAgICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gY29tcG9uZW50LnJlbmRlcjtcblx0ICAgICAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuXHQgICAgICAgICAgICBob29rLmNhbGwoY29udGV4dCk7XG5cdCAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuXHQgICAgICAgICAgfTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcblx0ICAgICAgICAgIHZhciBleGlzdGluZyA9IGNvbXBvbmVudC5iZWZvcmVDcmVhdGU7XG5cdCAgICAgICAgICBjb21wb25lbnQuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spIDogW2hvb2tdO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gY29tcG9uZW50XG5cdCAgfVxuXHQgIC8qIHN0eWxlIGluamVjdCAqL1xuXHQgIGZ1bmN0aW9uIF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDIoKSB7XG5cdCAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0ICAgIHZhciBzdHlsZXMgPSBfX3Z1ZV9jcmVhdGVfaW5qZWN0b3JfXyQyLnN0eWxlcyB8fCAoX192dWVfY3JlYXRlX2luamVjdG9yX18kMi5zdHlsZXMgPSB7fSk7XG5cdCAgICB2YXIgaXNPbGRJRSA9XG5cdCAgICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG5cdCAgICAgIC9tc2llIFs2LTldXFxcXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcblxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIGFkZFN0eWxlKGlkLCBjc3MpIHtcblx0ICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgaWQgKyAnXCJdJykpIHsgcmV0dXJuIH0gLy8gU1NSIHN0eWxlcyBhcmUgcHJlc2VudC5cblxuXHQgICAgICB2YXIgZ3JvdXAgPSBpc09sZElFID8gY3NzLm1lZGlhIHx8ICdkZWZhdWx0JyA6IGlkO1xuXHQgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbZ3JvdXBdIHx8IChzdHlsZXNbZ3JvdXBdID0geyBpZHM6IFtdLCBwYXJ0czogW10sIGVsZW1lbnQ6IHVuZGVmaW5lZCB9KTtcblxuXHQgICAgICBpZiAoIXN0eWxlLmlkcy5pbmNsdWRlcyhpZCkpIHtcblx0ICAgICAgICB2YXIgY29kZSA9IGNzcy5zb3VyY2U7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gc3R5bGUuaWRzLmxlbmd0aDtcblxuXHQgICAgICAgIHN0eWxlLmlkcy5wdXNoKGlkKTtcblxuXHQgICAgICAgIGlmIChpc09sZElFKSB7XG5cdCAgICAgICAgICBzdHlsZS5lbGVtZW50ID0gc3R5bGUuZWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWdyb3VwPScgKyBncm91cCArICddJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFzdHlsZS5lbGVtZW50KSB7XG5cdCAgICAgICAgICB2YXIgZWwgPSBzdHlsZS5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0ICAgICAgICAgIGVsLnR5cGUgPSAndGV4dC9jc3MnO1xuXG5cdCAgICAgICAgICBpZiAoY3NzLm1lZGlhKSB7IGVsLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBjc3MubWVkaWEpOyB9XG5cdCAgICAgICAgICBpZiAoaXNPbGRJRSkge1xuXHQgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZ3JvdXAnLCBncm91cCk7XG5cdCAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1uZXh0LWluZGV4JywgJzAnKTtcblx0ICAgICAgICAgIH1cblxuXHQgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChlbCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGlzT2xkSUUpIHtcblx0ICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoc3R5bGUuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1pbmRleCcpKTtcblx0ICAgICAgICAgIHN0eWxlLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW5leHQtaW5kZXgnLCBpbmRleCArIDEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0ICAgICAgICAgIHN0eWxlLnBhcnRzLnB1c2goY29kZSk7XG5cdCAgICAgICAgICBzdHlsZS5lbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHN0eWxlLnBhcnRzXG5cdCAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcblx0ICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb2RlKTtcblx0ICAgICAgICAgIHZhciBub2RlcyA9IHN0eWxlLmVsZW1lbnQuY2hpbGROb2Rlcztcblx0ICAgICAgICAgIGlmIChub2Rlc1tpbmRleF0pIHsgc3R5bGUuZWxlbWVudC5yZW1vdmVDaGlsZChub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoKSB7IHN0eWxlLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCBub2Rlc1tpbmRleF0pOyB9XG5cdCAgICAgICAgICBlbHNlIHsgc3R5bGUuZWxlbWVudC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSk7IH1cblx0ICAgICAgICB9XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICB9XG5cdCAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgIFxuXG5cdCAgXG5cdCAgdmFyIERpYWxvZ0xheW91dCA9IF9fdnVlX25vcm1hbGl6ZV9fJDIoXG5cdCAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kMiwgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQyIH0sXG5cdCAgICBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kMixcblx0ICAgIF9fdnVlX3NjcmlwdF9fJDIsXG5cdCAgICBfX3Z1ZV9zY29wZV9pZF9fJDIsXG5cdCAgICBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kMixcblx0ICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kMixcblx0ICAgIF9fdnVlX2NyZWF0ZV9pbmplY3Rvcl9fJDIsXG5cdCAgICB1bmRlZmluZWRcblx0ICApXG5cblx0dmFyIENvbmZpcm1hYmxlID0ge1xuXHQgIG5hbWU6ICdDb25maXJtYWJsZScsXG5cblx0ICBwcm9wczoge1xuXHQgICAgdHlwZToge1xuXHQgICAgICB0eXBlOiBTdHJpbmdcblx0ICAgIH0sXG5cdCAgICB0ZXh0OiB7XG5cdCAgICAgIHR5cGU6IFN0cmluZyxcblx0ICAgICAgcmVxaXVyZWQ6IHRydWVcblx0ICAgIH0sXG5cdCAgICB0aXRsZToge1xuXHQgICAgICB0eXBlOiBTdHJpbmdcblx0ICAgIH0sXG5cdCAgICBhY3Rpb25zOiB7XG5cdCAgICAgIHR5cGU6IFtBcnJheSwgT2JqZWN0XVxuXHQgICAgfVxuXHQgIH1cblx0fVxuXG5cdHZhciBDb2xvcmFibGUgPSB7XG5cdCAgcHJvcHM6IHtcblx0ICAgIHR5cGU6IFN0cmluZyxcblx0ICAgIGNvbG9yOiBTdHJpbmdcblx0ICB9LFxuXHQgIGNvbXB1dGVkOiB7XG5cdCAgICBnZXRDb2xvcjogZnVuY3Rpb24gZ2V0Q29sb3IoKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLmNvbG9yIHx8IHRoaXMudHlwZTtcblx0ICAgIH1cblxuXHQgIH1cblx0fTtcblxuXHQvL1xuXHR2YXIgc2NyaXB0JDMgPSB7XG5cdCAgY29tcG9uZW50czoge1xuXHQgICAgRGlhbG9nQWN0aW9uczogRGlhbG9nQWN0aW9uc1xuXHQgIH0sXG5cdCAgbGF5b3V0OiAnZGVmYXVsdCcsXG5cdCAgbWl4aW5zOiBbQ29uZmlybWFibGUsIENvbG9yYWJsZV0sXG5cdCAgY29tcHV0ZWQ6IHtcblx0ICAgIGhlYWRlclRleHRWYXJpYW50OiBmdW5jdGlvbiBoZWFkZXJUZXh0VmFyaWFudCgpIHtcblx0ICAgICAgcmV0dXJuIFsnaW5mbycsICdkYW5nZXInXS5pbmRleE9mKHRoaXMudHlwZSkgPj0gMCA/ICdsaWdodCcgOiAnZGFyayc7XG5cdCAgICB9XG5cblx0ICB9XG5cdH07XG5cblx0Lyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQzID0gc2NyaXB0JDM7XG5cdCAgICAgICAgICAgIFxuXHQvKiB0ZW1wbGF0ZSAqL1xuXHR2YXIgX192dWVfcmVuZGVyX18kMyA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBfdm0gPSB0aGlzO1xuXHQgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgcmV0dXJuIF9jKFxuXHQgICAgXCJkaXZcIixcblx0ICAgIFtcblx0ICAgICAgX2MoXG5cdCAgICAgICAgXCJEaWFsb2dDYXJkXCIsXG5cdCAgICAgICAge1xuXHQgICAgICAgICAgYXR0cnM6IHtcblx0ICAgICAgICAgICAgYWN0aW9uczogX3ZtLmFjdGlvbnMsXG5cdCAgICAgICAgICAgIHRpdGxlOiBfdm0udGl0bGUsXG5cdCAgICAgICAgICAgIFwiaGVhZGVyLWJnLXZhcmlhbnRcIjogX3ZtLnR5cGUsXG5cdCAgICAgICAgICAgIFwiaGVhZGVyLXRleHQtdmFyaWFudFwiOiBfdm0uaGVhZGVyVGV4dFZhcmlhbnRcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIFtcblx0ICAgICAgICAgIF9jKFwiZGl2XCIsIHtcblx0ICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZGlhbG9nLWNvbmZpcm0tdGV4dFwiLFxuXHQgICAgICAgICAgICBkb21Qcm9wczogeyBpbm5lckhUTUw6IF92bS5fcyhfdm0udGV4dCkgfVxuXHQgICAgICAgICAgfSlcblx0ICAgICAgICBdXG5cdCAgICAgIClcblx0ICAgIF0sXG5cdCAgICAxXG5cdCAgKVxuXHR9O1xuXHR2YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18kMyA9IFtdO1xuXHRfX3Z1ZV9yZW5kZXJfXyQzLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuXG5cdCAgLyogc3R5bGUgKi9cblx0ICB2YXIgX192dWVfaW5qZWN0X3N0eWxlc19fJDMgPSB1bmRlZmluZWQ7XG5cdCAgLyogc2NvcGVkICovXG5cdCAgdmFyIF9fdnVlX3Njb3BlX2lkX18kMyA9IHVuZGVmaW5lZDtcblx0ICAvKiBtb2R1bGUgaWRlbnRpZmllciAqL1xuXHQgIHZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDMgPSB1bmRlZmluZWQ7XG5cdCAgLyogZnVuY3Rpb25hbCB0ZW1wbGF0ZSAqL1xuXHQgIHZhciBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kMyA9IGZhbHNlO1xuXHQgIC8qIGNvbXBvbmVudCBub3JtYWxpemVyICovXG5cdCAgZnVuY3Rpb24gX192dWVfbm9ybWFsaXplX18kMyhcblx0ICAgIHRlbXBsYXRlLCBzdHlsZSwgc2NyaXB0LFxuXHQgICAgc2NvcGUsIGZ1bmN0aW9uYWwsIG1vZHVsZUlkZW50aWZpZXIsXG5cdCAgICBjcmVhdGVJbmplY3RvciwgY3JlYXRlSW5qZWN0b3JTU1Jcblx0ICApIHtcblx0ICAgIHZhciBjb21wb25lbnQgPSAodHlwZW9mIHNjcmlwdCA9PT0gJ2Z1bmN0aW9uJyA/IHNjcmlwdC5vcHRpb25zIDogc2NyaXB0KSB8fCB7fTtcblxuXHQgICAgLy8gRm9yIHNlY3VyaXR5IGNvbmNlcm5zLCB3ZSB1c2Ugb25seSBiYXNlIG5hbWUgaW4gcHJvZHVjdGlvbiBtb2RlLlxuXHQgICAgY29tcG9uZW50Ll9fZmlsZSA9IFwiL1VzZXJzL3lhcmlrL1Byb2plY3RzL2Nsb25lcy9ib290c3RyYXAtdnVlLWRpYWxvZy9zcmMvY29tcG9uZW50cy9Db25maXJtLnZ1ZVwiO1xuXG5cdCAgICBpZiAoIWNvbXBvbmVudC5yZW5kZXIpIHtcblx0ICAgICAgY29tcG9uZW50LnJlbmRlciA9IHRlbXBsYXRlLnJlbmRlcjtcblx0ICAgICAgY29tcG9uZW50LnN0YXRpY1JlbmRlckZucyA9IHRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0ICAgICAgY29tcG9uZW50Ll9jb21waWxlZCA9IHRydWU7XG5cblx0ICAgICAgaWYgKGZ1bmN0aW9uYWwpIHsgY29tcG9uZW50LmZ1bmN0aW9uYWwgPSB0cnVlOyB9XG5cdCAgICB9XG5cblx0ICAgIGNvbXBvbmVudC5fc2NvcGVJZCA9IHNjb3BlO1xuXG5cdCAgICBcblxuXHQgICAgcmV0dXJuIGNvbXBvbmVudFxuXHQgIH1cblx0ICAvKiBzdHlsZSBpbmplY3QgKi9cblx0ICBcblx0ICAvKiBzdHlsZSBpbmplY3QgU1NSICovXG5cdCAgXG5cblx0ICBcblx0ICB2YXIgQ29uZmlybSA9IF9fdnVlX25vcm1hbGl6ZV9fJDMoXG5cdCAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kMywgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQzIH0sXG5cdCAgICBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kMyxcblx0ICAgIF9fdnVlX3NjcmlwdF9fJDMsXG5cdCAgICBfX3Z1ZV9zY29wZV9pZF9fJDMsXG5cdCAgICBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kMyxcblx0ICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kMyxcblx0ICAgIHVuZGVmaW5lZCxcblx0ICAgIHVuZGVmaW5lZFxuXHQgIClcblxuXHQvL1xuXHR2YXIgc2NyaXB0JDQgPSB7XG5cdCAgY29tcG9uZW50czoge1xuXHQgICAgRGlhbG9nQWN0aW9uczogRGlhbG9nQWN0aW9uc1xuXHQgIH0sXG5cdCAgbGF5b3V0OiBbJ25vdGlmaWNhdGlvbicsIHtcblx0ICAgIHNob3dDbG9zZTogZmFsc2Vcblx0ICB9XSxcblx0ICBwcm9wczoge1xuXHQgICAgdHlwZToge1xuXHQgICAgICB0eXBlOiBTdHJpbmcsXG5cdCAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdpbmZvJzsgfVxuXHQgICAgfSxcblx0ICAgIGFjdGlvbnM6IFtBcnJheSwgT2JqZWN0XSxcblx0ICAgIHRleHQ6IFN0cmluZyxcblx0ICAgIGRpc21pc3NpYmxlOiB7XG5cdCAgICAgIHR5cGU6IEJvb2xlYW4sXG5cdCAgICAgIGRlZmF1bHQ6IHRydWVcblx0ICAgIH1cblx0ICB9XG5cdH07XG5cblx0Lyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQ0ID0gc2NyaXB0JDQ7XG5cdCAgICAgICAgICAgIFxuXHQvKiB0ZW1wbGF0ZSAqL1xuXHR2YXIgX192dWVfcmVuZGVyX18kNCA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBfdm0gPSB0aGlzO1xuXHQgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgcmV0dXJuIF9jKFxuXHQgICAgXCJiLWFsZXJ0XCIsXG5cdCAgICB7XG5cdCAgICAgIHN0YXRpY1N0eWxlOiB7IFwibWFyZ2luLWJvdHRvbVwiOiBcIjBcIiB9LFxuXHQgICAgICBhdHRyczogeyBzaG93OiBcIlwiLCB2YXJpYW50OiBfdm0udHlwZSwgZGlzbWlzc2libGU6IF92bS5kaXNtaXNzaWJsZSB9LFxuXHQgICAgICBvbjoge1xuXHQgICAgICAgIGRpc21pc3NlZDogZnVuY3Rpb24oJGV2ZW50KSB7XG5cdCAgICAgICAgICBfdm0uJGVtaXQoXCJzdWJtaXRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9LFxuXHQgICAgW19jKFwic3BhblwiLCB7IGRvbVByb3BzOiB7IGlubmVySFRNTDogX3ZtLl9zKF92bS50ZXh0KSB9IH0pXVxuXHQgIClcblx0fTtcblx0dmFyIF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDQgPSBbXTtcblx0X192dWVfcmVuZGVyX18kNC5fd2l0aFN0cmlwcGVkID0gdHJ1ZTtcblxuXHQgIC8qIHN0eWxlICovXG5cdCAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyQ0ID0gdW5kZWZpbmVkO1xuXHQgIC8qIHNjb3BlZCAqL1xuXHQgIHZhciBfX3Z1ZV9zY29wZV9pZF9fJDQgPSB1bmRlZmluZWQ7XG5cdCAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cblx0ICB2YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQ0ID0gdW5kZWZpbmVkO1xuXHQgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDQgPSBmYWxzZTtcblx0ICAvKiBjb21wb25lbnQgbm9ybWFsaXplciAqL1xuXHQgIGZ1bmN0aW9uIF9fdnVlX25vcm1hbGl6ZV9fJDQoXG5cdCAgICB0ZW1wbGF0ZSwgc3R5bGUsIHNjcmlwdCxcblx0ICAgIHNjb3BlLCBmdW5jdGlvbmFsLCBtb2R1bGVJZGVudGlmaWVyLFxuXHQgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgKSB7XG5cdCAgICB2YXIgY29tcG9uZW50ID0gKHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicgPyBzY3JpcHQub3B0aW9ucyA6IHNjcmlwdCkgfHwge307XG5cblx0ICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgIGNvbXBvbmVudC5fX2ZpbGUgPSBcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvYm9vdHN0cmFwLXZ1ZS1kaWFsb2cvc3JjL2NvbXBvbmVudHMvQWxlcnQudnVlXCI7XG5cblx0ICAgIGlmICghY29tcG9uZW50LnJlbmRlcikge1xuXHQgICAgICBjb21wb25lbnQucmVuZGVyID0gdGVtcGxhdGUucmVuZGVyO1xuXHQgICAgICBjb21wb25lbnQuc3RhdGljUmVuZGVyRm5zID0gdGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuXHQgICAgICBjb21wb25lbnQuX2NvbXBpbGVkID0gdHJ1ZTtcblxuXHQgICAgICBpZiAoZnVuY3Rpb25hbCkgeyBjb21wb25lbnQuZnVuY3Rpb25hbCA9IHRydWU7IH1cblx0ICAgIH1cblxuXHQgICAgY29tcG9uZW50Ll9zY29wZUlkID0gc2NvcGU7XG5cblx0ICAgIFxuXG5cdCAgICByZXR1cm4gY29tcG9uZW50XG5cdCAgfVxuXHQgIC8qIHN0eWxlIGluamVjdCAqL1xuXHQgIFxuXHQgIC8qIHN0eWxlIGluamVjdCBTU1IgKi9cblx0ICBcblxuXHQgIFxuXHQgIHZhciBBbGVydCA9IF9fdnVlX25vcm1hbGl6ZV9fJDQoXG5cdCAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kNCwgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQ0IH0sXG5cdCAgICBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kNCxcblx0ICAgIF9fdnVlX3NjcmlwdF9fJDQsXG5cdCAgICBfX3Z1ZV9zY29wZV9pZF9fJDQsXG5cdCAgICBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kNCxcblx0ICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kNCxcblx0ICAgIHVuZGVmaW5lZCxcblx0ICAgIHVuZGVmaW5lZFxuXHQgIClcblxuXHQvL1xuXHR2YXIgc2NyaXB0JDUgPSB7XG5cdCAgY29tcG9uZW50czoge1xuXHQgICAgRGlhbG9nQWN0aW9uczogRGlhbG9nQWN0aW9uc1xuXHQgIH0sXG5cdCAgcHJvcHM6IHtcblx0ICAgIHRpdGxlOiBTdHJpbmcsXG5cdCAgICBhY3Rpb25zOiBbQXJyYXksIE9iamVjdF0sXG5cdCAgICBoZWFkZXJCZ1ZhcmlhbnQ6IFN0cmluZyxcblx0ICAgIGhlYWRlclRleHRWYXJpYW50OiBTdHJpbmcsXG5cdCAgICBoZWFkZXJCb3JkZXJWYXJpYW50OiBTdHJpbmcsXG5cdCAgICBoZWFkZXJDbGFzczogU3RyaW5nXG5cdCAgfSxcblx0ICBjb21wdXRlZDoge1xuXHQgICAgaGVhZGVyQ2xhc3NlczogZnVuY3Rpb24gaGVhZGVyQ2xhc3NlcygpIHtcblx0ICAgICAgdmFyIG9iajtcblxuXHQgICAgICByZXR1cm4gWydtb2RhbC1oZWFkZXInLCAoIG9iaiA9IHt9LCBvYmpbKFwiYmctXCIgKyAodGhpcy5oZWFkZXJCZ1ZhcmlhbnQpKV0gPSBCb29sZWFuKHRoaXMuaGVhZGVyQmdWYXJpYW50KSwgb2JqWyhcInRleHQtXCIgKyAodGhpcy5oZWFkZXJUZXh0VmFyaWFudCkpXSA9IEJvb2xlYW4odGhpcy5oZWFkZXJUZXh0VmFyaWFudCksIG9ialsoXCJib3JkZXItXCIgKyAodGhpcy5oZWFkZXJCb3JkZXJWYXJpYW50KSldID0gQm9vbGVhbih0aGlzLmhlYWRlckJvcmRlclZhcmlhbnQpLCBvYmopLCB0aGlzLmhlYWRlckNsYXNzXTtcblx0ICAgIH1cblxuXHQgIH0sXG5cdCAgbWV0aG9kczoge1xuXHQgICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihuYW1lKSB7XG5cdCAgICAgIHRoaXMuJHJlZnMuYWN0aW9ucyAmJiB0aGlzLiRyZWZzLmFjdGlvbnMudHJpZ2dlcihuYW1lKTtcblx0ICAgIH1cblxuXHQgIH1cblx0fTtcblxuXHQvKiBzY3JpcHQgKi9cblx0ICAgICAgICAgICAgdmFyIF9fdnVlX3NjcmlwdF9fJDUgPSBzY3JpcHQkNTtcblx0ICAgICAgICAgICAgXG5cdC8qIHRlbXBsYXRlICovXG5cdHZhciBfX3Z1ZV9yZW5kZXJfXyQ1ID0gZnVuY3Rpb24oKSB7XG5cdCAgdmFyIF92bSA9IHRoaXM7XG5cdCAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50O1xuXHQgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaDtcblx0ICByZXR1cm4gX2MoXCJkaXZcIiwgW1xuXHQgICAgX2MoXG5cdCAgICAgIFwiaGVhZGVyXCIsXG5cdCAgICAgIHsgY2xhc3M6IF92bS5oZWFkZXJDbGFzc2VzIH0sXG5cdCAgICAgIFtcblx0ICAgICAgICBfdm0uX3QoXCJ0aXRsZVwiLCBbXG5cdCAgICAgICAgICBfYyhcImg1XCIsIHsgc3RhdGljQ2xhc3M6IFwibW9kYWwtdGl0bGVcIiB9LCBbX3ZtLl92KF92bS5fcyhfdm0udGl0bGUpKV0pXG5cdCAgICAgICAgXSksXG5cdCAgICAgICAgX3ZtLl92KFwiIFwiKSxcblx0ICAgICAgICBfYyhcblx0ICAgICAgICAgIFwiYnV0dG9uXCIsXG5cdCAgICAgICAgICB7XG5cdCAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImNsb3NlXCIsXG5cdCAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIsIFwiYXJpYS1sYWJlbFwiOiBcIkNsb3NlXCIgfVxuXHQgICAgICAgICAgfSxcblx0ICAgICAgICAgIFtfdm0uX3YoXCLDl1wiKV1cblx0ICAgICAgICApXG5cdCAgICAgIF0sXG5cdCAgICAgIDJcblx0ICAgICksXG5cdCAgICBfdm0uX3YoXCIgXCIpLFxuXHQgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1ib2R5XCIgfSwgW192bS5fdChcImRlZmF1bHRcIildLCAyKSxcblx0ICAgIF92bS5fdihcIiBcIiksXG5cdCAgICBfdm0uYWN0aW9uc1xuXHQgICAgICA/IF9jKFxuXHQgICAgICAgICAgXCJmb290ZXJcIixcblx0ICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibW9kYWwtZm9vdGVyXCIgfSxcblx0ICAgICAgICAgIFtcblx0ICAgICAgICAgICAgX2MoXCJEaWFsb2dBY3Rpb25zXCIsIHtcblx0ICAgICAgICAgICAgICByZWY6IFwiYWN0aW9uc1wiLFxuXHQgICAgICAgICAgICAgIGF0dHJzOiB7IGFjdGlvbnM6IF92bS5hY3Rpb25zIH1cblx0ICAgICAgICAgICAgfSlcblx0ICAgICAgICAgIF0sXG5cdCAgICAgICAgICAxXG5cdCAgICAgICAgKVxuXHQgICAgICA6IF92bS5fZSgpXG5cdCAgXSlcblx0fTtcblx0dmFyIF9fdnVlX3N0YXRpY1JlbmRlckZuc19fJDUgPSBbXTtcblx0X192dWVfcmVuZGVyX18kNS5fd2l0aFN0cmlwcGVkID0gdHJ1ZTtcblxuXHQgIC8qIHN0eWxlICovXG5cdCAgdmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyQ1ID0gdW5kZWZpbmVkO1xuXHQgIC8qIHNjb3BlZCAqL1xuXHQgIHZhciBfX3Z1ZV9zY29wZV9pZF9fJDUgPSB1bmRlZmluZWQ7XG5cdCAgLyogbW9kdWxlIGlkZW50aWZpZXIgKi9cblx0ICB2YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyQ1ID0gdW5kZWZpbmVkO1xuXHQgIC8qIGZ1bmN0aW9uYWwgdGVtcGxhdGUgKi9cblx0ICB2YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDUgPSBmYWxzZTtcblx0ICAvKiBjb21wb25lbnQgbm9ybWFsaXplciAqL1xuXHQgIGZ1bmN0aW9uIF9fdnVlX25vcm1hbGl6ZV9fJDUoXG5cdCAgICB0ZW1wbGF0ZSwgc3R5bGUsIHNjcmlwdCxcblx0ICAgIHNjb3BlLCBmdW5jdGlvbmFsLCBtb2R1bGVJZGVudGlmaWVyLFxuXHQgICAgY3JlYXRlSW5qZWN0b3IsIGNyZWF0ZUluamVjdG9yU1NSXG5cdCAgKSB7XG5cdCAgICB2YXIgY29tcG9uZW50ID0gKHR5cGVvZiBzY3JpcHQgPT09ICdmdW5jdGlvbicgPyBzY3JpcHQub3B0aW9ucyA6IHNjcmlwdCkgfHwge307XG5cblx0ICAgIC8vIEZvciBzZWN1cml0eSBjb25jZXJucywgd2UgdXNlIG9ubHkgYmFzZSBuYW1lIGluIHByb2R1Y3Rpb24gbW9kZS5cblx0ICAgIGNvbXBvbmVudC5fX2ZpbGUgPSBcIi9Vc2Vycy95YXJpay9Qcm9qZWN0cy9jbG9uZXMvYm9vdHN0cmFwLXZ1ZS1kaWFsb2cvc3JjL2NvbXBvbmVudHMvRGlhbG9nQ2FyZC52dWVcIjtcblxuXHQgICAgaWYgKCFjb21wb25lbnQucmVuZGVyKSB7XG5cdCAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgIGNvbXBvbmVudC5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG5cdCAgICAgIGNvbXBvbmVudC5fY29tcGlsZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgfVxuXG5cdCAgICBjb21wb25lbnQuX3Njb3BlSWQgPSBzY29wZTtcblxuXHQgICAgXG5cblx0ICAgIHJldHVybiBjb21wb25lbnRcblx0ICB9XG5cdCAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgXG5cdCAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgIFxuXG5cdCAgXG5cdCAgdmFyIERpYWxvZ0NhcmQgPSBfX3Z1ZV9ub3JtYWxpemVfXyQ1KFxuXHQgICAgeyByZW5kZXI6IF9fdnVlX3JlbmRlcl9fJDUsIHN0YXRpY1JlbmRlckZuczogX192dWVfc3RhdGljUmVuZGVyRm5zX18kNSB9LFxuXHQgICAgX192dWVfaW5qZWN0X3N0eWxlc19fJDUsXG5cdCAgICBfX3Z1ZV9zY3JpcHRfXyQ1LFxuXHQgICAgX192dWVfc2NvcGVfaWRfXyQ1LFxuXHQgICAgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fJDUsXG5cdCAgICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fJDUsXG5cdCAgICB1bmRlZmluZWQsXG5cdCAgICB1bmRlZmluZWRcblx0ICApXG5cblx0Ly9cblx0dmFyIHNjcmlwdCQ2ID0ge1xuXHQgIGNvbXBvbmVudHM6IHtcblx0ICAgIERpYWxvZ0NhcmQ6IERpYWxvZ0NhcmRcblx0ICB9LFxuXHQgIGxheW91dDogJ2RlZmF1bHQnLFxuXHQgIG1peGluczogW0NvbmZpcm1hYmxlXSxcblx0ICBwcm9wczoge1xuXHQgICAgdmFsdWU6IFN0cmluZ1xuXHQgIH0sXG5cdCAgY29tcHV0ZWQ6IHtcblx0ICAgIHBhcnNlZEFjdGlvbnM6IGZ1bmN0aW9uIHBhcnNlZEFjdGlvbnMoKSB7XG5cdCAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuXG5cdCAgICAgIGlmIChhY3Rpb25zW3RydWVdKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25zW3RydWVdID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgYWN0aW9uc1t0cnVlXSA9IHtcblx0ICAgICAgICAgICAgJ3RleHQnOiBhY3Rpb25zW3RydWVdLFxuXHQgICAgICAgICAgICBoYW5kbGU6IHRoaXMub25TdWJtaXRcblx0ICAgICAgICAgIH07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgIGFjdGlvbnNbdHJ1ZV0uaGFuZGxlID0gdGhpcy5vblN1Ym1pdDtcblx0ICAgICAgICB9XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4gYWN0aW9ucztcblx0ICAgIH1cblxuXHQgIH0sXG5cblx0ICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZWRpdGVkVmFsdWU6IHRoaXMudmFsdWVcblx0ICAgIH07XG5cdCAgfSxcblxuXHQgIG1ldGhvZHM6IHtcblx0ICAgIG9uU3VibWl0OiBmdW5jdGlvbiBvblN1Ym1pdCgpIHtcblx0ICAgICAgdGhpcy4kZW1pdCgnc3VibWl0JywgdGhpcy5lZGl0ZWRWYWx1ZSk7XG5cdCAgICB9XG5cblx0ICB9XG5cdH07XG5cblx0Lyogc2NyaXB0ICovXG5cdCAgICAgICAgICAgIHZhciBfX3Z1ZV9zY3JpcHRfXyQ2ID0gc2NyaXB0JDY7XG5cdCAgICAgICAgICAgIFxuXHQvKiB0ZW1wbGF0ZSAqL1xuXHR2YXIgX192dWVfcmVuZGVyX18kNiA9IGZ1bmN0aW9uKCkge1xuXHQgIHZhciBfdm0gPSB0aGlzO1xuXHQgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudDtcblx0ICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2g7XG5cdCAgcmV0dXJuIF9jKFxuXHQgICAgXCJkaXZcIixcblx0ICAgIFtcblx0ICAgICAgX2MoXG5cdCAgICAgICAgXCJEaWFsb2dDYXJkXCIsXG5cdCAgICAgICAgeyBhdHRyczogeyB0aXRsZTogX3ZtLnRpdGxlLCBhY3Rpb25zOiBfdm0ucGFyc2VkQWN0aW9ucyB9IH0sXG5cdCAgICAgICAgW1xuXHQgICAgICAgICAgX2MoXCJiLWZvcm0taW5wdXRcIiwge1xuXHQgICAgICAgICAgICBhdHRyczogeyBhdXRvZm9jdXM6IFwiXCIsIHBsYWNlaG9sZGVyOiBfdm0udGV4dCwgcmVxdWlyZWQ6IFwiXCIgfSxcblx0ICAgICAgICAgICAgb246IHtcblx0ICAgICAgICAgICAgICBrZXlwcmVzczogZnVuY3Rpb24oJGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgICAgICAgICEoXCJidXR0b25cIiBpbiAkZXZlbnQpICYmXG5cdCAgICAgICAgICAgICAgICAgIF92bS5faygkZXZlbnQua2V5Q29kZSwgXCJlbnRlclwiLCAxMywgJGV2ZW50LmtleSwgXCJFbnRlclwiKVxuXHQgICAgICAgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLm9uU3VibWl0KCRldmVudClcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIG1vZGVsOiB7XG5cdCAgICAgICAgICAgICAgdmFsdWU6IF92bS5lZGl0ZWRWYWx1ZSxcblx0ICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oJCR2KSB7XG5cdCAgICAgICAgICAgICAgICBfdm0uZWRpdGVkVmFsdWUgPSAkJHY7XG5cdCAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICBleHByZXNzaW9uOiBcImVkaXRlZFZhbHVlXCJcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgfSlcblx0ICAgICAgICBdLFxuXHQgICAgICAgIDFcblx0ICAgICAgKVxuXHQgICAgXSxcblx0ICAgIDFcblx0ICApXG5cdH07XG5cdHZhciBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQ2ID0gW107XG5cdF9fdnVlX3JlbmRlcl9fJDYuX3dpdGhTdHJpcHBlZCA9IHRydWU7XG5cblx0ICAvKiBzdHlsZSAqL1xuXHQgIHZhciBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kNiA9IHVuZGVmaW5lZDtcblx0ICAvKiBzY29wZWQgKi9cblx0ICB2YXIgX192dWVfc2NvcGVfaWRfXyQ2ID0gdW5kZWZpbmVkO1xuXHQgIC8qIG1vZHVsZSBpZGVudGlmaWVyICovXG5cdCAgdmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kNiA9IHVuZGVmaW5lZDtcblx0ICAvKiBmdW5jdGlvbmFsIHRlbXBsYXRlICovXG5cdCAgdmFyIF9fdnVlX2lzX2Z1bmN0aW9uYWxfdGVtcGxhdGVfXyQ2ID0gZmFsc2U7XG5cdCAgLyogY29tcG9uZW50IG5vcm1hbGl6ZXIgKi9cblx0ICBmdW5jdGlvbiBfX3Z1ZV9ub3JtYWxpemVfXyQ2KFxuXHQgICAgdGVtcGxhdGUsIHN0eWxlLCBzY3JpcHQsXG5cdCAgICBzY29wZSwgZnVuY3Rpb25hbCwgbW9kdWxlSWRlbnRpZmllcixcblx0ICAgIGNyZWF0ZUluamVjdG9yLCBjcmVhdGVJbmplY3RvclNTUlxuXHQgICkge1xuXHQgICAgdmFyIGNvbXBvbmVudCA9ICh0eXBlb2Ygc2NyaXB0ID09PSAnZnVuY3Rpb24nID8gc2NyaXB0Lm9wdGlvbnMgOiBzY3JpcHQpIHx8IHt9O1xuXG5cdCAgICAvLyBGb3Igc2VjdXJpdHkgY29uY2VybnMsIHdlIHVzZSBvbmx5IGJhc2UgbmFtZSBpbiBwcm9kdWN0aW9uIG1vZGUuXG5cdCAgICBjb21wb25lbnQuX19maWxlID0gXCIvVXNlcnMveWFyaWsvUHJvamVjdHMvY2xvbmVzL2Jvb3RzdHJhcC12dWUtZGlhbG9nL3NyYy9jb21wb25lbnRzL1Byb21wdC52dWVcIjtcblxuXHQgICAgaWYgKCFjb21wb25lbnQucmVuZGVyKSB7XG5cdCAgICAgIGNvbXBvbmVudC5yZW5kZXIgPSB0ZW1wbGF0ZS5yZW5kZXI7XG5cdCAgICAgIGNvbXBvbmVudC5zdGF0aWNSZW5kZXJGbnMgPSB0ZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG5cdCAgICAgIGNvbXBvbmVudC5fY29tcGlsZWQgPSB0cnVlO1xuXG5cdCAgICAgIGlmIChmdW5jdGlvbmFsKSB7IGNvbXBvbmVudC5mdW5jdGlvbmFsID0gdHJ1ZTsgfVxuXHQgICAgfVxuXG5cdCAgICBjb21wb25lbnQuX3Njb3BlSWQgPSBzY29wZTtcblxuXHQgICAgXG5cblx0ICAgIHJldHVybiBjb21wb25lbnRcblx0ICB9XG5cdCAgLyogc3R5bGUgaW5qZWN0ICovXG5cdCAgXG5cdCAgLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXHQgIFxuXG5cdCAgXG5cdCAgdmFyIFByb21wdCA9IF9fdnVlX25vcm1hbGl6ZV9fJDYoXG5cdCAgICB7IHJlbmRlcjogX192dWVfcmVuZGVyX18kNiwgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfXyQ2IH0sXG5cdCAgICBfX3Z1ZV9pbmplY3Rfc3R5bGVzX18kNixcblx0ICAgIF9fdnVlX3NjcmlwdF9fJDYsXG5cdCAgICBfX3Z1ZV9zY29wZV9pZF9fJDYsXG5cdCAgICBfX3Z1ZV9pc19mdW5jdGlvbmFsX3RlbXBsYXRlX18kNixcblx0ICAgIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18kNixcblx0ICAgIHVuZGVmaW5lZCxcblx0ICAgIHVuZGVmaW5lZFxuXHQgIClcblxuXHR2YXIgUGx1Z2luID0ge1xuXHQgIGluc3RhbGw6IGZ1bmN0aW9uIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHQgICAgdmFyIHByb3BlcnR5ID0gb3B0aW9ucy5wcm9wZXJ0eSB8fCAnJGRpYWxvZyc7IC8vIGNvbnN0IG1lc3NhZ2VQcm9wZXJ0eSA9IG9wdGlvbnMubWVzc2FnZVByb3BlcnR5XG5cblx0ICAgIFZ1ZS51c2UodnVlZGwsIG9wdGlvbnMpO1xuXHQgICAgdmFyIG1hbmFnZXIgPSBWdWUucHJvdG90eXBlW3Byb3BlcnR5XTtcblx0ICAgIG1hbmFnZXIubGF5b3V0KCdkZWZhdWx0JywgRGlhbG9nTGF5b3V0KTtcblx0ICAgIFZ1ZS5jb21wb25lbnQoJ0RpYWxvZ0FjdGlvbnMnLCBEaWFsb2dBY3Rpb25zKTtcblx0ICAgIFZ1ZS5jb21wb25lbnQoJ0RpYWxvZ0NhcmQnLCBEaWFsb2dDYXJkKTtcblx0ICAgIG1hbmFnZXIub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnbW9kYWwtb3BlbicpO1xuXHQgICAgfSk7XG5cdCAgICBtYW5hZ2VyLmNvbXBvbmVudCgnY29uZmlybScsIENvbmZpcm0sIHtcblx0ICAgICAgd2FpdEZvclJlc3VsdDogdHJ1ZSxcblx0ICAgICAgYWN0aW9uczoge1xuXHQgICAgICAgICdmYWxzZSc6ICdDYW5jZWwnLFxuXHQgICAgICAgICd0cnVlJzogJ09LJ1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIG1hbmFnZXIuY29tcG9uZW50KCd3YXJuaW5nJywgQ29uZmlybSwge1xuXHQgICAgICB0eXBlOiAnd2FybmluZycsXG5cdCAgICAgIHdhaXRGb3JSZXN1bHQ6IHRydWUsXG5cdCAgICAgIGFjdGlvbnM6IHtcblx0ICAgICAgICAnZmFsc2UnOiAnQ2FuY2VsJyxcblx0ICAgICAgICAndHJ1ZSc6ICdPSydcblx0ICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICBtYW5hZ2VyLmNvbXBvbmVudCgnaW5mbycsIENvbmZpcm0sIHtcblx0ICAgICAgdHlwZTogJ2luZm8nLFxuXHQgICAgICB3YWl0Rm9yUmVzdWx0OiB0cnVlLFxuXHQgICAgICBhY3Rpb25zOiB7XG5cdCAgICAgICAgJ2ZhbHNlJzogJ0NhbmNlbCcsXG5cdCAgICAgICAgJ3RydWUnOiAnT0snXG5cdCAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgbWFuYWdlci5jb21wb25lbnQoJ2Vycm9yJywgQ29uZmlybSwge1xuXHQgICAgICB0eXBlOiAnZGFuZ2VyJyxcblx0ICAgICAgd2FpdEZvclJlc3VsdDogdHJ1ZSxcblx0ICAgICAgYWN0aW9uczogWydDbG9zZSddXG5cdCAgICB9KTsgLy8gbWFuYWdlci5jb21wb25lbnQoJ3RvYXN0JywgVG9hc3QsIHtcblx0ICAgIC8vICAgd2FpdEZvclJlc3VsdDogdHJ1ZVxuXHQgICAgLy8gfSlcblx0ICAgIC8vIG1hbmFnZXIubWVzc2FnZSA9IHtcblx0ICAgIC8vICAgaW5mbzogKG1lc3NhZ2UsIG9wdGlvbnMpID0+IG1hbmFnZXIudG9hc3QoeyB0ZXh0OiBtZXNzYWdlLCB2YXJpYW50OiAnaW5mbycsIC4uLm9wdGlvbnMgfSksXG5cdCAgICAvLyAgIGVycm9yOiAobWVzc2FnZSwgb3B0aW9ucykgPT4gbWFuYWdlci50b2FzdCh7IHRleHQ6IG1lc3NhZ2UsIHZhcmlhbnQ6ICdkYW5nZXInLCAuLi5vcHRpb25zIH0pLFxuXHQgICAgLy8gICBzdWNjZXNzOiAobWVzc2FnZSwgb3B0aW9ucykgPT4gbWFuYWdlci50b2FzdCh7IHRleHQ6IG1lc3NhZ2UsIHZhcmlhbnQ6ICdzdWNjZXNzJywgLi4ub3B0aW9ucyB9KSxcblx0ICAgIC8vICAgd2FybmluZzogKG1lc3NhZ2UsIG9wdGlvbnMpID0+IG1hbmFnZXIudG9hc3QoeyB0ZXh0OiBtZXNzYWdlLCB2YXJpYW50OiAnd2FybmluZycsIC4uLm9wdGlvbnMgfSlcblx0ICAgIC8vIH1cblx0ICAgIC8vIG1lc3NhZ2VQcm9wZXJ0eSAmJiAoVnVlLnByb3RvdHlwZVttZXNzYWdlUHJvcGVydHldID0gbWFuYWdlci5tZXNzYWdlKVxuXG5cdCAgICBtYW5hZ2VyLmNvbXBvbmVudCgnYWxlcnQnLCBBbGVydCwge1xuXHQgICAgICB3YWl0Rm9yUmVzdWx0OiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIG1hbmFnZXIubm90aWZ5ID0ge1xuXHQgICAgICBpbmZvOiBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykgeyByZXR1cm4gbWFuYWdlci5hbGVydChPYmplY3QuYXNzaWduKHtcblx0ICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuXHQgICAgICAgIHR5cGU6ICdpbmZvJ1xuXHQgICAgICB9LCBvcHRpb25zKSk7IH0sXG5cdCAgICAgIGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykgeyByZXR1cm4gbWFuYWdlci5hbGVydChPYmplY3QuYXNzaWduKHtcblx0ICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuXHQgICAgICAgIHR5cGU6ICdkYW5nZXInXG5cdCAgICAgIH0sIG9wdGlvbnMpKTsgfSxcblx0ICAgICAgc3VjY2VzczogZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHsgcmV0dXJuIG1hbmFnZXIuYWxlcnQoT2JqZWN0LmFzc2lnbih7XG5cdCAgICAgICAgdGV4dDogbWVzc2FnZSxcblx0ICAgICAgICB0eXBlOiAnc3VjY2Vzcydcblx0ICAgICAgfSwgb3B0aW9ucykpOyB9LFxuXHQgICAgICB3YXJuaW5nOiBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykgeyByZXR1cm4gbWFuYWdlci5hbGVydChPYmplY3QuYXNzaWduKHtcblx0ICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuXHQgICAgICAgIHR5cGU6ICd3YXJuaW5nJ1xuXHQgICAgICB9LCBvcHRpb25zKSk7IH1cblx0ICAgIH07XG5cdCAgICBtYW5hZ2VyLmNvbXBvbmVudCgncHJvbXB0JywgUHJvbXB0LCB7XG5cdCAgICAgIHdhaXRGb3JSZXN1bHQ6IHRydWUsXG5cdCAgICAgIGFjdGlvbnM6IHtcblx0ICAgICAgICBmYWxzZTogJ0NhbmNlbCcsXG5cdCAgICAgICAgdHJ1ZTogJ09LJ1xuXHQgICAgICB9XG5cdCAgICB9KTtcblx0ICB9XG5cblx0fTtcblxuXHRyZXR1cm4gUGx1Z2luO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bootstrap-vue-dialog/dist/bootstrap-vue-dialog.js\n");

/***/ })

}]);